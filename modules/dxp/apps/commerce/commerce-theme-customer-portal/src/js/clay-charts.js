this["metal"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 98);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.validators = exports.SoyAop = exports.Soy = exports.Config = undefined;

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(56);

var _metalComponent = __webpack_require__(2);

var _metal = __webpack_require__(1);

var _metalState = __webpack_require__(3);

var _metalIncrementalDom = __webpack_require__(12);

var _metalIncrementalDom2 = _interopRequireDefault(_metalIncrementalDom);

var _SoyAop = __webpack_require__(66);

var _SoyAop2 = _interopRequireDefault(_SoyAop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// The injected data that will be passed to soy templates.
var ijData = {};

/**
 * Soy Renderer
 */

var Soy = function(_IncrementalDomRender) {
	_inherits(Soy, _IncrementalDomRender);

	function Soy() {
		_classCallCheck(this, Soy);

		return _possibleConstructorReturn(this, (Soy.__proto__ || Object.getPrototypeOf(Soy)).apply(this, arguments));
	}

	_createClass(Soy, [{
		key: 'getExtraDataConfig',

		/**
* Adds the template params to the component's state, if they don't exist yet.
* @param {!Component} component
* @return {Object}
*/
		value: function getExtraDataConfig(component) {
			var elementTemplate = component.constructor.TEMPLATE;
			if (!(0, _metal.isFunction)(elementTemplate)) {
				return;
			}

			elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
			this.soyParamTypes_ = elementTemplate.types || {};

			var keys = elementTemplate.params || [];
			var configs = {};
			for (var i = 0; i < keys.length; i++) {
				if (!component[keys[i]]) {
					configs[keys[i]] = {};
				}
			}
			return configs;
		}

		/**
* Copies the component's state to an object so it can be passed as it's
* template call's data. The copying needs to be done because, if the component
* itself is passed directly, some problems occur when soy tries to merge it
* with other data, due to property getters and setters. This is safer.
* Also calls the component's "prepareStateForRender" to let it change the
* data passed to the template.
* @param {!Component} component
* @param {!Array<string>} params The params used by this template.
* @return {!Object}
* @protected
*/

	}, {
		key: 'buildTemplateData_',
		value: function buildTemplateData_(component, params) {
			var _this2 = this;

			var data = _metal.object.mixin({}, this.getConfig(component));
			component.getStateKeys().forEach(function (key) {
				var value = component[key];
				if (_this2.isHtmlParam_(component, key)) {
					value = soyRenderer_.toIncDom(value);
				}
				data[key] = value;
			});

			for (var i = 0; i < params.length; i++) {
				if (!data[params[i]] && (0, _metal.isFunction)(component[params[i]])) {
					data[params[i]] = component[params[i]].bind(component);
				}
			}

			if ((0, _metal.isFunction)(component.prepareStateForRender)) {
				return component.prepareStateForRender(data) || data;
			} else {
				return data;
			}
		}

		/**
* Returns the requested template function. This function will be wrapped in
* another though, just to defer the requirement of the template's module
* being ready until the function is actually called.
* @param {string} namespace The soy template's namespace.
* @param {string} templateName The name of the template function.
* @return {!function()}
*/

	}, {
		key: 'getTemplate',
		value: function getTemplate(namespace, templateName) {
			return function(data, ignored, ijData) {
				if (!goog.loadedModules_[namespace]) {
					throw new Error('No template with namespace "' + namespace + '" has been loaded yet.');
				}
				return goog.loadedModules_[namespace][templateName](data, ignored, ijData);
			};
		}

		/**
* Handles an intercepted soy template call. If the call is for a component's
* main template, then it will be replaced with a call that incremental dom
* can use for both handling an instance of that component and rendering it.
* @param {!function()} originalFn The original template function that was
*     intercepted.
* @param {Object} data The data the template was called with.
* @protected
*/

	}, {
		key: 'handleInterceptedCall_',
		value: function handleInterceptedCall_(originalFn) {
			var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			var args = [originalFn.componentCtor, null, []];
			for (var key in data) {
				if (Object.prototype.hasOwnProperty.call(data, key)) {
					args.push(key, data[key]);
				}
			}
			IncrementalDOM.elementVoid.apply(null, args);
		}

		/**
* Checks if the given param type is html.
* @param {!Component} component
* @param {string} name
* @protected
* @return {boolean}
*/

	}, {
		key: 'isHtmlParam_',
		value: function isHtmlParam_(component, name) {
			var state = component.getDataManager().getStateInstance(component);
			if (state.getStateKeyConfig(name).isHtml) {
				return true;
			}

			var elementTemplate = _SoyAop2.default.getOriginalFn(component.constructor.TEMPLATE);
			var type = (elementTemplate.types || {})[name] || '';
			return type.split('|').indexOf('html') !== -1;
		}

		/**
* Registers the given templates to be used by `Soy` for the specified
* component constructor.
* @param {!Function} componentCtor The constructor of the component that
*     should use the given templates.
* @param {!Object} templates Object containing soy template functions.
* @param {string=} mainTemplate The name of the main template that should be
*     used to render the component. Defaults to "render".
*/

	}, {
		key: 'register',
		value: function register(componentCtor, templates) {
			var mainTemplate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'render';

			componentCtor.RENDERER = soyRenderer_;
			componentCtor.TEMPLATE = _SoyAop2.default.getOriginalFn(templates[mainTemplate]);
			componentCtor.TEMPLATE.componentCtor = componentCtor;
			_SoyAop2.default.registerForInterception(templates, mainTemplate);
			_metalComponent.ComponentRegistry.register(componentCtor);
		}

		/**
* Overrides the default method from `IncrementalDomRenderer` so the component's
* soy template can be used for rendering.
* @param {!Component} component
* @param {!Object} data Data passed to the component when rendering it.
* @override
*/

	}, {
		key: 'renderIncDom',
		value: function renderIncDom(component) {
			var elementTemplate = component.constructor.TEMPLATE;
			if ((0, _metal.isFunction)(elementTemplate) && !component.render) {
				elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
				_SoyAop2.default.startInterception(this.handleInterceptedCall_);
				var data = this.buildTemplateData_(component, elementTemplate.params || []);
				elementTemplate(data, null, ijData);
				_SoyAop2.default.stopInterception();
			} else {
				_get(Soy.prototype.__proto__ || Object.getPrototypeOf(Soy.prototype), 'renderIncDom', this).call(this, component);
			}
		}

		/**
* Sets the injected data object that should be passed to templates.
* @param {Object} data
*/

	}, {
		key: 'setInjectedData',
		value: function setInjectedData(data) {
			ijData = data || {};
		}

		/**
* Overrides the original `IncrementalDomRenderer` method so that only
* state keys used by the main template can cause updates.
* @param {!Component} component
* @param {Object} changes
* @return {boolean}
*/

	}, {
		key: 'shouldUpdate',
		value: function shouldUpdate(component, changes) {
			var should = _get(Soy.prototype.__proto__ || Object.getPrototypeOf(Soy.prototype), 'shouldUpdate', this).call(this, component, changes);
			if (!should || component.shouldUpdate) {
				return should;
			}

			var fn = component.constructor.TEMPLATE;
			var params = fn ? _SoyAop2.default.getOriginalFn(fn).params : [];
			for (var i = 0; i < params.length; i++) {
				if (changes.props[params[i]]) {
					return true;
				}
			}
			return false;
		}

		/**
* Converts the given incremental dom function into an html string.
* @param {!function()} incDomFn
* @return {string}
*/

	}, {
		key: 'toHtmlString',
		value: function toHtmlString(incDomFn) {
			var element = document.createElement('div');
			IncrementalDOM.patch(element, incDomFn);
			return element.innerHTML;
		}

		/**
* Converts the given html string into an incremental dom function.
* @param {string|{contentKind: string, content: string}} value
* @return {!function()}
*/

	}, {
		key: 'toIncDom',
		value: function toIncDom(value) {
			if ((0, _metal.isObject)(value) && (0, _metal.isString)(value.content) && value.contentKind === 'HTML') {
				value = value.content;
			}
			if ((0, _metal.isString)(value)) {
				value = _metalIncrementalDom.HTML2IncDom.buildFn(value);
			}
			return value;
		}
	}]);

	return Soy;
}(_metalIncrementalDom2.default.constructor);

var soyRenderer_ = new Soy();
soyRenderer_.RENDERER_NAME = 'soy';

exports.default = soyRenderer_;
exports.Config = _metalState.Config;
exports.Soy = soyRenderer_;
exports.SoyAop = _SoyAop2.default;
exports.validators = _metalState.validators;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(34);

Object.keys(_core).forEach(function (key) {
if (key === "default" || key === "__esModule") return;
Object.defineProperty(exports, key, {
	enumerable: true,
	get: function get() {
	  return _core[key];
	}
});
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(35);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(36);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(39);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(40);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(41);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ComponentRenderer = exports.ComponentRegistry = exports.ComponentDataManager = exports.Component = undefined;

var _events = __webpack_require__(22);

Object.keys(_events).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _events[key];
		}
	});
});

var _Component = __webpack_require__(47);

var _Component2 = _interopRequireDefault(_Component);

var _ComponentDataManager = __webpack_require__(25);

var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);

var _ComponentRegistry = __webpack_require__(55);

var _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);

var _ComponentRenderer = __webpack_require__(26);

var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Component2.default;
exports.Component = _Component2.default;
exports.ComponentDataManager = _ComponentDataManager2.default;
exports.ComponentRegistry = _ComponentRegistry2.default;
exports.ComponentRenderer = _ComponentRenderer2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.State = exports.Config = exports.validators = undefined;

var _validators = __webpack_require__(18);

var _validators2 = _interopRequireDefault(_validators);

var _Config = __webpack_require__(42);

var _Config2 = _interopRequireDefault(_Config);

var _State = __webpack_require__(43);

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _State2.default;
exports.validators = _validators2.default;
exports.Config = _Config2.default;
exports.State = _State2.default;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.Chart = undefined;

var _ChartBase = __webpack_require__(17);

var _ChartBase2 = _interopRequireDefault(_ChartBase);

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _ChartSoy = __webpack_require__(67);

var _ChartSoy2 = _interopRequireDefault(_ChartSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Metal Chart component.
 * @extends ChartBase
 * @extends Component
 */
var Chart = function(_Component) {
_inherits(Chart, _Component);

function Chart() {
	_classCallCheck(this, Chart);

	return _possibleConstructorReturn(this, (Chart.__proto__ || Object.getPrototypeOf(Chart)).apply(this, arguments));
}

return Chart;
}(_metalComponent2.default);

Object.assign(Chart.prototype, _ChartBase2.default);
Chart.STATE = Object.assign({}, _ChartBase2.default.STATE);

_metalSoy2.default.register(Chart, _ChartSoy2.default);

exports.Chart = Chart;
exports.default = Chart;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var types = {
	all: ['area', 'area-line-range', 'area-spline', 'area-spline-range', 'area-step', 'bar', 'bubble', 'donut', 'gauge', 'line', 'pie', 'scatter', 'spline', 'step'],

	area: ['area', 'area-line-range', 'area-spline', 'area-spline-range', 'area-step'],

	gauge: ['gauge'],

	percentage: ['donut', 'pie'],

	point: ['area', 'area-spline', 'area-step', 'bar', 'line', 'scatter', 'spline', 'step']
};

exports.types = types;
exports.default = types;

/***/ }),
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.dom = undefined;

var _domNamed = __webpack_require__(49);

Object.keys(_domNamed).forEach(function (key) {
if (key === "default" || key === "__esModule") return;
Object.defineProperty(exports, key, {
	enumerable: true,
	get: function get() {
	  return _domNamed[key];
	}
});
});

var dom = _interopRequireWildcard(_domNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = dom;
exports.dom = dom;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.EventHandler = exports.EventHandle = exports.EventEmitterProxy = exports.EventEmitter = undefined;

var _EventEmitter = __webpack_require__(44);

var _EventEmitter2 = _interopRequireDefault(_EventEmitter);

var _EventEmitterProxy = __webpack_require__(45);

var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);

var _EventHandle = __webpack_require__(20);

var _EventHandle2 = _interopRequireDefault(_EventHandle);

var _EventHandler = __webpack_require__(46);

var _EventHandler2 = _interopRequireDefault(_EventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _EventEmitter2.default;
exports.EventEmitter = _EventEmitter2.default;
exports.EventEmitterProxy = _EventEmitterProxy2.default;
exports.EventHandle = _EventHandle2.default;
exports.EventHandler = _EventHandler2.default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.clearData = clearData;
exports.getData = getData;
var RENDERER_DATA = '__METAL_IC_RENDERER_DATA__';

/**
 * Removes the incremental dom renderer data object for this component.
 * @param {!Component} component
 */
function clearData(component) {
component[RENDERER_DATA] = null;
}

/**
 * Gets the incremental dom renderer data object for this component, creating
 * it if it doesn't exist yet.
 * @param {!Component} component
 * @return {!Object}
 */
function getData(component) {
if (!component[RENDERER_DATA]) {
	component[RENDERER_DATA] = {};
}
return component[RENDERER_DATA];
}

/***/ }),
/* 10 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if (typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.globalEvalStyles = exports.globalEval = exports.features = exports.DomEventHandle = exports.DomEventEmitterProxy = exports.domData = undefined;

var _dom = __webpack_require__(7);

Object.keys(_dom).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _dom[key];
		}
	});
});

var _dom2 = _interopRequireDefault(_dom);

var _domData = __webpack_require__(15);

var _domData2 = _interopRequireDefault(_domData);

var _DomEventEmitterProxy = __webpack_require__(51);

var _DomEventEmitterProxy2 = _interopRequireDefault(_DomEventEmitterProxy);

var _DomEventHandle = __webpack_require__(23);

var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

var _features = __webpack_require__(24);

var _features2 = _interopRequireDefault(_features);

var _globalEval = __webpack_require__(52);

var _globalEval2 = _interopRequireDefault(_globalEval);

var _globalEvalStyles = __webpack_require__(53);

var _globalEvalStyles2 = _interopRequireDefault(_globalEvalStyles);

__webpack_require__(54);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.domData = _domData2.default;
exports.DomEventEmitterProxy = _DomEventEmitterProxy2.default;
exports.DomEventHandle = _DomEventHandle2.default;
exports.features = _features2.default;
exports.globalEval = _globalEval2.default;
exports.globalEvalStyles = _globalEvalStyles2.default;
exports.default = _dom2.default;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.HTML2IncDom = undefined;

var _HTML2IncDom = __webpack_require__(57);

var _HTML2IncDom2 = _interopRequireDefault(_HTML2IncDom);

var _IncrementalDomRenderer = __webpack_require__(60);

var _IncrementalDomRenderer2 = _interopRequireDefault(_IncrementalDomRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.HTML2IncDom = _HTML2IncDom2.default;
exports.default = _IncrementalDomRenderer2.default;

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3/dist/package.js
var package_name = "d3";
var version = "5.0.0";
var description = "Data-Driven Documents";
var keywords = ["dom","visualization","svg","animation","canvas"];
var homepage = "https://d3js.org";
var license = "BSD-3-Clause";
var author = {"name":"Mike Bostock","url":"https://bost.ocks.org/mike"};
var main = "dist/d3.node.js";
var unpkg = "dist/d3.min.js";
var jsdelivr = "dist/d3.min.js";
var package_module = "index";
var repository = {"type":"git","url":"https://github.com/d3/d3.git"};
var scripts = {"pretest":"rimraf dist && mkdir dist && json2module package.json > dist/package.js && node rollup.node","test":"tape 'test/**/*-test.js'","prepublishOnly":"npm run test && rollup -c --banner \"$(preamble)\" && uglifyjs -b beautify=false,preamble=\"'$(preamble)'\" dist/d3.js -c negate_iife=false -m -o dist/d3.min.js","postpublish":"git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/dist/d3.js d3.v5.js && cp ../d3/dist/d3.min.js d3.v5.min.js && git add d3.v5.js d3.v5.min.js && git commit -m \"d3 ${npm_package_version}\" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/dist/d3.js ../d3/dist/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m \"${npm_package_version}\" && git tag -am \"${npm_package_version}\" v${npm_package_version} && git push && git push --tags && cd - && zip -j dist/d3.zip -- LICENSE README.md API.md CHANGES.md dist/d3.js dist/d3.min.js"};
var devDependencies = {"json2module":"0.0","package-preamble":"0.1","rimraf":"2","rollup":"0.57","rollup-plugin-ascii":"0.0","rollup-plugin-node-resolve":"3","tape":"4","uglify-js":"3.2"};
var dependencies = {"d3-array":"1","d3-axis":"1","d3-brush":"1","d3-chord":"1","d3-collection":"1","d3-color":"1","d3-contour":"1","d3-dispatch":"1","d3-drag":"1","d3-dsv":"1","d3-ease":"1","d3-fetch":"1","d3-force":"1","d3-format":"1","d3-geo":"1","d3-hierarchy":"1","d3-interpolate":"1","d3-path":"1","d3-polygon":"1","d3-quadtree":"1","d3-random":"1","d3-scale":"2","d3-scale-chromatic":"1","d3-selection":"1","d3-shape":"1","d3-time":"1","d3-time-format":"2","d3-timer":"1","d3-transition":"1","d3-voronoi":"1","d3-zoom":"1"};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/ascending.js
/* harmony default export */ var ascending = (function(a, b) {
return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/bisector.js

/* harmony default export */ var bisector = (function(compare) {
if (compare.length === 1) compare = ascendingComparator(compare);
return {
	left: function(a, x, lo, hi) {
	  if (lo == null) lo = 0;
	  if (hi == null) hi = a.length;
	  while (lo < hi) {
		var mid = lo + hi >>> 1;
		if (compare(a[mid], x) < 0) lo = mid + 1;
		else hi = mid;
	  }
	  return lo;
	},
	right: function(a, x, lo, hi) {
	  if (lo == null) lo = 0;
	  if (hi == null) hi = a.length;
	  while (lo < hi) {
		var mid = lo + hi >>> 1;
		if (compare(a[mid], x) > 0) hi = mid;
		else lo = mid + 1;
	  }
	  return lo;
	}
};
});

function ascendingComparator(f) {
return function(d, x) {
	return ascending(f(d), x);
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/bisect.js

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ var bisect = (bisectRight);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/pairs.js
/* harmony default export */ var pairs = (function(array, f) {
if (f == null) f = pair;
var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
while (i < n) pairs[i] = f(p, p = array[++i]);
return pairs;
});

function pair(a, b) {
return [a, b];
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/cross.js

/* harmony default export */ var cross = (function(values0, values1, reduce) {
var n0 = values0.length,
	  n1 = values1.length,
	  values = new Array(n0 * n1),
	  i0,
	  i1,
	  i,
	  value0;

if (reduce == null) reduce = pair;

for (i0 = i = 0; i0 < n0; ++i0) {
	for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	  values[i] = reduce(value0, values1[i1]);
	}
}

return values;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
return x === null ? NaN : +x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/variance.js

/* harmony default export */ var variance = (function(values, valueof) {
var n = values.length,
	  m = 0,
	  i = -1,
	  mean = 0,
	  value,
	  delta,
	  sum = 0;

if (valueof == null) {
	while (++i < n) {
	  if (!isNaN(value = number(values[i]))) {
		delta = value - mean;
		mean += delta / ++m;
		sum += delta * (value - mean);
	  }
	}
}

else {
	while (++i < n) {
	  if (!isNaN(value = number(valueof(values[i], i, values)))) {
		delta = value - mean;
		mean += delta / ++m;
		sum += delta * (value - mean);
	  }
	}
}

if (m > 1) return sum / (m - 1);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/deviation.js

/* harmony default export */ var deviation = (function(array, f) {
var v = variance(array, f);
return v ? Math.sqrt(v) : v;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/extent.js
/* harmony default export */ var src_extent = (function(values, valueof) {
var n = values.length,
	  i = -1,
	  value,
	  min,
	  max;

if (valueof == null) {
	while (++i < n) { // Find the first comparable value.
	  if ((value = values[i]) != null && value >= value) {
		min = max = value;
		while (++i < n) { // Compare the remaining values.
		  if ((value = values[i]) != null) {
			if (min > value) min = value;
			if (max < value) max = value;
		  }
		}
	  }
	}
}

else {
	while (++i < n) { // Find the first comparable value.
	  if ((value = valueof(values[i], i, values)) != null && value >= value) {
		min = max = value;
		while (++i < n) { // Compare the remaining values.
		  if ((value = valueof(values[i], i, values)) != null) {
			if (min > value) min = value;
			if (max < value) max = value;
		  }
		}
	  }
	}
}

return [min, max];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/array.js
var array_array = Array.prototype;

var slice = array_array.slice;
var map = array_array.map;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
return x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/range.js
/* harmony default export */ var src_range = (function(start, stop, step) {
start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

var i = -1,
	  n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	  range = new Array(n);

while (++i < n) {
	range[i] = start + i * step;
}

return range;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
	e5 = Math.sqrt(10),
	e2 = Math.sqrt(2);

/* harmony default export */ var ticks = (function(start, stop, count) {
var reverse,
	  i = -1,
	  n,
	  ticks,
	  step;

stop = +stop, start = +start, count = +count;
if (start === stop && count > 0) return [start];
if (reverse = stop < start) n = start, start = stop, stop = n;
if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

if (step > 0) {
	start = Math.ceil(start / step);
	stop = Math.floor(stop / step);
	ticks = new Array(n = Math.ceil(stop - start + 1));
	while (++i < n) ticks[i] = (start + i) * step;
} else {
	start = Math.floor(start * step);
	stop = Math.ceil(stop * step);
	ticks = new Array(n = Math.ceil(start - stop + 1));
	while (++i < n) ticks[i] = (start - i) / step;
}

if (reverse) ticks.reverse();

return ticks;
});

function tickIncrement(start, stop, count) {
var step = (stop - start) / Math.max(0, count),
	  power = Math.floor(Math.log(step) / Math.LN10),
	  error = step / Math.pow(10, power);
return power >= 0
	  ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	  : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
var step0 = Math.abs(stop - start) / Math.max(0, count),
	  step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	  error = step0 / step1;
if (error >= e10) step1 *= 10;
else if (error >= e5) step1 *= 5;
else if (error >= e2) step1 *= 2;
return stop < start ? -step1 : step1;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/threshold/sturges.js
/* harmony default export */ var sturges = (function(values) {
return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/histogram.js

/* harmony default export */ var src_histogram = (function() {
var value = identity,
	  domain = src_extent,
	  threshold = sturges;

function histogram(data) {
	var i,
		n = data.length,
		x,
		values = new Array(n);

	for (i = 0; i < n; ++i) {
	  values[i] = value(data[i], i, data);
	}

	var xz = domain(values),
		x0 = xz[0],
		x1 = xz[1],
		tz = threshold(values, x0, x1);

	// Convert number of thresholds into uniform thresholds.
	if (!Array.isArray(tz)) {
	  tz = tickStep(x0, x1, tz);
	  tz = src_range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
	}

	// Remove any thresholds outside the domain.
	var m = tz.length;
	while (tz[0] <= x0) tz.shift(), --m;
	while (tz[m - 1] > x1) tz.pop(), --m;

	var bins = new Array(m + 1),
		bin;

	// Initialize bins.
	for (i = 0; i <= m; ++i) {
	  bin = bins[i] = [];
	  bin.x0 = i > 0 ? tz[i - 1] : x0;
	  bin.x1 = i < m ? tz[i] : x1;
	}

	// Assign data to bins by value, ignoring any outside the domain.
	for (i = 0; i < n; ++i) {
	  x = values[i];
	  if (x0 <= x && x <= x1) {
		bins[bisect(tz, x, 0, m)].push(data[i]);
	  }
	}

	return bins;
}

histogram.value = function(_) {
	return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
};

histogram.domain = function(_) {
	return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
};

histogram.thresholds = function(_) {
	return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
};

return histogram;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/quantile.js

/* harmony default export */ var quantile = (function(values, p, valueof) {
if (valueof == null) valueof = number;
if (!(n = values.length)) return;
if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
if (p >= 1) return +valueof(values[n - 1], n - 1, values);
var n,
	  i = (n - 1) * p,
	  i0 = Math.floor(i),
	  value0 = +valueof(values[i0], i0, values),
	  value1 = +valueof(values[i0 + 1], i0 + 1, values);
return value0 + (value1 - value0) * (i - i0);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/threshold/freedmanDiaconis.js

/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
values = map.call(values, number).sort(ascending);
return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/threshold/scott.js

/* harmony default export */ var scott = (function(values, min, max) {
return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/max.js
/* harmony default export */ var src_max = (function(values, valueof) {
var n = values.length,
	  i = -1,
	  value,
	  max;

if (valueof == null) {
	while (++i < n) { // Find the first comparable value.
	  if ((value = values[i]) != null && value >= value) {
		max = value;
		while (++i < n) { // Compare the remaining values.
		  if ((value = values[i]) != null && value > max) {
			max = value;
		  }
		}
	  }
	}
}

else {
	while (++i < n) { // Find the first comparable value.
	  if ((value = valueof(values[i], i, values)) != null && value >= value) {
		max = value;
		while (++i < n) { // Compare the remaining values.
		  if ((value = valueof(values[i], i, values)) != null && value > max) {
			max = value;
		  }
		}
	  }
	}
}

return max;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/mean.js

/* harmony default export */ var src_mean = (function(values, valueof) {
var n = values.length,
	  m = n,
	  i = -1,
	  value,
	  sum = 0;

if (valueof == null) {
	while (++i < n) {
	  if (!isNaN(value = number(values[i]))) sum += value;
	  else --m;
	}
}

else {
	while (++i < n) {
	  if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	  else --m;
	}
}

if (m) return sum / m;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/median.js

/* harmony default export */ var median = (function(values, valueof) {
var n = values.length,
	  i = -1,
	  value,
	  numbers = [];

if (valueof == null) {
	while (++i < n) {
	  if (!isNaN(value = number(values[i]))) {
		numbers.push(value);
	  }
	}
}

else {
	while (++i < n) {
	  if (!isNaN(value = number(valueof(values[i], i, values)))) {
		numbers.push(value);
	  }
	}
}

return quantile(numbers.sort(ascending), 0.5);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/merge.js
/* harmony default export */ var src_merge = (function(arrays) {
var n = arrays.length,
	  m,
	  i = -1,
	  j = 0,
	  merged,
	  array;

while (++i < n) j += arrays[i].length;
merged = new Array(j);

while (--n >= 0) {
	array = arrays[n];
	m = array.length;
	while (--m >= 0) {
	  merged[--j] = array[m];
	}
}

return merged;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/min.js
/* harmony default export */ var src_min = (function(values, valueof) {
var n = values.length,
	  i = -1,
	  value,
	  min;

if (valueof == null) {
	while (++i < n) { // Find the first comparable value.
	  if ((value = values[i]) != null && value >= value) {
		min = value;
		while (++i < n) { // Compare the remaining values.
		  if ((value = values[i]) != null && min > value) {
			min = value;
		  }
		}
	  }
	}
}

else {
	while (++i < n) { // Find the first comparable value.
	  if ((value = valueof(values[i], i, values)) != null && value >= value) {
		min = value;
		while (++i < n) { // Compare the remaining values.
		  if ((value = valueof(values[i], i, values)) != null && min > value) {
			min = value;
		  }
		}
	  }
	}
}

return min;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(array, indexes) {
var i = indexes.length, permutes = new Array(i);
while (i--) permutes[i] = array[indexes[i]];
return permutes;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/scan.js

/* harmony default export */ var scan = (function(values, compare) {
if (!(n = values.length)) return;
var n,
	  i = 0,
	  j = 0,
	  xi,
	  xj = values[j];

if (compare == null) compare = ascending;

while (++i < n) {
	if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	  xj = xi, j = i;
	}
}

if (compare(xj, xj) === 0) return j;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/shuffle.js
/* harmony default export */ var shuffle = (function(array, i0, i1) {
var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	  t,
	  i;

while (m) {
	i = Math.random() * m-- | 0;
	t = array[m + i0];
	array[m + i0] = array[i + i0];
	array[i + i0] = t;
}

return array;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/sum.js
/* harmony default export */ var src_sum = (function(values, valueof) {
var n = values.length,
	  i = -1,
	  value,
	  sum = 0;

if (valueof == null) {
	while (++i < n) {
	  if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	}
}

else {
	while (++i < n) {
	  if (value = +valueof(values[i], i, values)) sum += value;
	}
}

return sum;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/transpose.js

/* harmony default export */ var src_transpose = (function(matrix) {
if (!(n = matrix.length)) return [];
for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
	for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	  row[j] = matrix[j][i];
	}
}
return transpose;
});

function transpose_length(d) {
return d.length;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/src/zip.js

/* harmony default export */ var zip = (function() {
return src_transpose(arguments);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-array/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-axis/src/array.js
var array_slice = Array.prototype.slice;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-axis/src/identity.js
/* harmony default export */ var src_identity = (function(x) {
return x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-axis/src/axis.js

var axis_top = 1,
	axis_right = 2,
	axis_bottom = 3,
	axis_left = 4,
	epsilon = 1e-6;

function translateX(x) {
return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
return "translate(0," + (y + 0.5) + ")";
}

function axis_number(scale) {
return function(d) {
	return +scale(d);
};
}

function axis_center(scale) {
var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
if (scale.round()) offset = Math.round(offset);
return function(d) {
	return +scale(d) + offset;
};
}

function entering() {
return !this.__axis;
}

function axis_axis(orient, scale) {
var tickArguments = [],
	  tickValues = null,
	  tickFormat = null,
	  tickSizeInner = 6,
	  tickSizeOuter = 6,
	  tickPadding = 3,
	  k = orient === axis_top || orient === axis_left ? -1 : 1,
	  x = orient === axis_left || orient === axis_right ? "x" : "y",
	  transform = orient === axis_top || orient === axis_bottom ? translateX : translateY;

function axis(context) {
	var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
		format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : src_identity) : tickFormat,
		spacing = Math.max(tickSizeInner, 0) + tickPadding,
		range = scale.range(),
		range0 = +range[0] + 0.5,
		range1 = +range[range.length - 1] + 0.5,
		position = (scale.bandwidth ? axis_center : axis_number)(scale.copy()),
		selection = context.selection ? context.selection() : context,
		path = selection.selectAll(".domain").data([null]),
		tick = selection.selectAll(".tick").data(values, scale).order(),
		tickExit = tick.exit(),
		tickEnter = tick.enter().append("g").attr("class", "tick"),
		line = tick.select("line"),
		text = tick.select("text");

	path = path.merge(path.enter().insert("path", ".tick")
		.attr("class", "domain")
		.attr("stroke", "#000"));

	tick = tick.merge(tickEnter);

	line = line.merge(tickEnter.append("line")
		.attr("stroke", "#000")
		.attr(x + "2", k * tickSizeInner));

	text = text.merge(tickEnter.append("text")
		.attr("fill", "#000")
		.attr(x, k * spacing)
		.attr("dy", orient === axis_top ? "0em" : orient === axis_bottom ? "0.71em" : "0.32em"));

	if (context !== selection) {
	  path = path.transition(context);
	  tick = tick.transition(context);
	  line = line.transition(context);
	  text = text.transition(context);

	  tickExit = tickExit.transition(context)
		  .attr("opacity", epsilon)
		  .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

	  tickEnter
		  .attr("opacity", epsilon)
		  .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
	}

	tickExit.remove();

	path
		.attr("d", orient === axis_left || orient == axis_right
			? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
			: "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

	tick
		.attr("opacity", 1)
		.attr("transform", function(d) { return transform(position(d)); });

	line
		.attr(x + "2", k * tickSizeInner);

	text
		.attr(x, k * spacing)
		.text(format);

	selection.filter(entering)
		.attr("fill", "none")
		.attr("font-size", 10)
		.attr("font-family", "sans-serif")
		.attr("text-anchor", orient === axis_right ? "start" : orient === axis_left ? "end" : "middle");

	selection
		.each(function() { this.__axis = position; });
}

axis.scale = function(_) {
	return arguments.length ? (scale = _, axis) : scale;
};

axis.ticks = function() {
	return tickArguments = array_slice.call(arguments), axis;
};

axis.tickArguments = function(_) {
	return arguments.length ? (tickArguments = _ == null ? [] : array_slice.call(_), axis) : tickArguments.slice();
};

axis.tickValues = function(_) {
	return arguments.length ? (tickValues = _ == null ? null : array_slice.call(_), axis) : tickValues && tickValues.slice();
};

axis.tickFormat = function(_) {
	return arguments.length ? (tickFormat = _, axis) : tickFormat;
};

axis.tickSize = function(_) {
	return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
};

axis.tickSizeInner = function(_) {
	return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
};

axis.tickSizeOuter = function(_) {
	return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
};

axis.tickPadding = function(_) {
	return arguments.length ? (tickPadding = +_, axis) : tickPadding;
};

return axis;
}

function axisTop(scale) {
return axis_axis(axis_top, scale);
}

function axisRight(scale) {
return axis_axis(axis_right, scale);
}

function axisBottom(scale) {
return axis_axis(axis_bottom, scale);
}

function axisLeft(scale) {
return axis_axis(axis_left, scale);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-axis/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-dispatch/src/dispatch.js
var noop = {value: function() {}};

function dispatch() {
for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
	_[t] = [];
}
return new Dispatch(_);
}

function Dispatch(_) {
this._ = _;
}

function parseTypenames(typenames, types) {
return typenames.trim().split(/^|\s+/).map(function(t) {
	var name = "", i = t.indexOf(".");
	if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	return {type: t, name: name};
});
}

Dispatch.prototype = dispatch.prototype = {
constructor: Dispatch,
on: function(typename, callback) {
	var _ = this._,
		T = parseTypenames(typename + "", _),
		t,
		i = -1,
		n = T.length;

	// If no callback was specified, return the callback of the given type and name.
	if (arguments.length < 2) {
	  while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
	  return;
	}

	// If a type was specified, set the callback for the given type and name.
	// Otherwise, if a null callback was specified, remove callbacks of the given name.
	if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	while (++i < n) {
	  if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
	  else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
	}

	return this;
},
copy: function() {
	var copy = {}, _ = this._;
	for (var t in _) copy[t] = _[t].slice();
	return new Dispatch(copy);
},
call: function(type, that) {
	if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
},
apply: function(type, that, args) {
	if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
}
};

function get(type, name) {
for (var i = 0, n = type.length, c; i < n; ++i) {
	if ((c = type[i]).name === name) {
	  return c.value;
	}
}
}

function set(type, name, callback) {
for (var i = 0, n = type.length; i < n; ++i) {
	if (type[i].name === name) {
	  type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
	  break;
	}
}
if (callback != null) type.push({name: name, value: callback});
return type;
}

/* harmony default export */ var src_dispatch = (dispatch);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-dispatch/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ var namespaces = ({
svg: "http://www.w3.org/2000/svg",
xhtml: xhtml,
xlink: "http://www.w3.org/1999/xlink",
xml: "http://www.w3.org/XML/1998/namespace",
xmlns: "http://www.w3.org/2000/xmlns/"
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/namespace.js

/* harmony default export */ var namespace = (function(name) {
var prefix = name += "", i = prefix.indexOf(":");
if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/creator.js

function creatorInherit(name) {
return function() {
	var document = this.ownerDocument,
		uri = this.namespaceURI;
	return uri === xhtml && document.documentElement.namespaceURI === xhtml
		? document.createElement(name)
		: document.createElementNS(uri, name);
};
}

function creatorFixed(fullname) {
return function() {
	return this.ownerDocument.createElementNS(fullname.space, fullname.local);
};
}

/* harmony default export */ var creator = (function(name) {
var fullname = namespace(name);
return (fullname.local
	  ? creatorFixed
	  : creatorInherit)(fullname);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selector.js
function none() {}

/* harmony default export */ var src_selector = (function(selector) {
return selector == null ? none : function() {
	return this.querySelector(selector);
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/select.js

/* harmony default export */ var selection_select = (function(select) {
if (typeof select !== "function") select = src_selector(select);

for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	  if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
		if ("__data__" in node) subnode.__data__ = node.__data__;
		subgroup[i] = subnode;
	  }
	}
}

return new Selection(subgroups, this._parents);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selectorAll.js
function selectorAll_empty() {
return [];
}

/* harmony default export */ var selectorAll = (function(selector) {
return selector == null ? selectorAll_empty : function() {
	return this.querySelectorAll(selector);
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/selectAll.js

/* harmony default export */ var selectAll = (function(select) {
if (typeof select !== "function") select = selectorAll(select);

for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	  if (node = group[i]) {
		subgroups.push(select.call(node, node.__data__, i, group));
		parents.push(node);
	  }
	}
}

return new Selection(subgroups, parents);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/matcher.js
var matcher = function(selector) {
return function() {
	return this.matches(selector);
};
};

if (typeof document !== "undefined") {
var matcher_element = document.documentElement;
if (!matcher_element.matches) {
	var vendorMatches = matcher_element.webkitMatchesSelector
		|| matcher_element.msMatchesSelector
		|| matcher_element.mozMatchesSelector
		|| matcher_element.oMatchesSelector;
	matcher = function(selector) {
	  return function() {
		return vendorMatches.call(this, selector);
	  };
	};
}
}

/* harmony default export */ var src_matcher = (matcher);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/filter.js

/* harmony default export */ var selection_filter = (function(match) {
if (typeof match !== "function") match = src_matcher(match);

for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	  if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
		subgroup.push(node);
	  }
	}
}

return new Selection(subgroups, this._parents);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/sparse.js
/* harmony default export */ var sparse = (function(update) {
return new Array(update.length);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/enter.js

/* harmony default export */ var selection_enter = (function() {
return new Selection(this._enter || this._groups.map(sparse), this._parents);
});

function EnterNode(parent, datum) {
this.ownerDocument = parent.ownerDocument;
this.namespaceURI = parent.namespaceURI;
this._next = null;
this._parent = parent;
this.__data__ = datum;
}

EnterNode.prototype = {
constructor: EnterNode,
appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
querySelector: function(selector) { return this._parent.querySelector(selector); },
querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/constant.js
/* harmony default export */ var src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/data.js

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
var i = 0,
	  node,
	  groupLength = group.length,
	  dataLength = data.length;

// Put any non-null nodes that fit into update.
// Put any null nodes into enter.
// Put any remaining data into enter.
for (; i < dataLength; ++i) {
	if (node = group[i]) {
	  node.__data__ = data[i];
	  update[i] = node;
	} else {
	  enter[i] = new EnterNode(parent, data[i]);
	}
}

// Put any non-null nodes that don’t fit into exit.
for (; i < groupLength; ++i) {
	if (node = group[i]) {
	  exit[i] = node;
	}
}
}

function bindKey(parent, group, enter, update, exit, data, key) {
var i,
	  node,
	  nodeByKeyValue = {},
	  groupLength = group.length,
	  dataLength = data.length,
	  keyValues = new Array(groupLength),
	  keyValue;

// Compute the key for each node.
// If multiple nodes have the same key, the duplicates are added to exit.
for (i = 0; i < groupLength; ++i) {
	if (node = group[i]) {
	  keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	  if (keyValue in nodeByKeyValue) {
		exit[i] = node;
	  } else {
		nodeByKeyValue[keyValue] = node;
	  }
	}
}

// Compute the key for each datum.
// If there a node associated with this key, join and add it to update.
// If there is not (or the key is a duplicate), add it to enter.
for (i = 0; i < dataLength; ++i) {
	keyValue = keyPrefix + key.call(parent, data[i], i, data);
	if (node = nodeByKeyValue[keyValue]) {
	  update[i] = node;
	  node.__data__ = data[i];
	  nodeByKeyValue[keyValue] = null;
	} else {
	  enter[i] = new EnterNode(parent, data[i]);
	}
}

// Add any remaining nodes that were not bound to data to exit.
for (i = 0; i < groupLength; ++i) {
	if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	  exit[i] = node;
	}
}
}

/* harmony default export */ var selection_data = (function(value, key) {
if (!value) {
	data = new Array(this.size()), j = -1;
	this.each(function(d) { data[++j] = d; });
	return data;
}

var bind = key ? bindKey : bindIndex,
	  parents = this._parents,
	  groups = this._groups;

if (typeof value !== "function") value = src_constant(value);

for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	var parent = parents[j],
		group = groups[j],
		groupLength = group.length,
		data = value.call(parent, parent && parent.__data__, j, parents),
		dataLength = data.length,
		enterGroup = enter[j] = new Array(dataLength),
		updateGroup = update[j] = new Array(dataLength),
		exitGroup = exit[j] = new Array(groupLength);

	bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	// Now connect the enter nodes to their following update node, such that
	// appendChild can insert the materialized enter node before this node,
	// rather than at the end of the parent node.
	for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	  if (previous = enterGroup[i0]) {
		if (i0 >= i1) i1 = i0 + 1;
		while (!(next = updateGroup[i1]) && ++i1 < dataLength);
		previous._next = next || null;
	  }
	}
}

update = new Selection(update, parents);
update._enter = enter;
update._exit = exit;
return update;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/exit.js

/* harmony default export */ var selection_exit = (function() {
return new Selection(this._exit || this._groups.map(sparse), this._parents);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/merge.js

/* harmony default export */ var selection_merge = (function(selection) {

for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	  if (node = group0[i] || group1[i]) {
		merge[i] = node;
	  }
	}
}

for (; j < m0; ++j) {
	merges[j] = groups0[j];
}

return new Selection(merges, this._parents);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/order.js
/* harmony default export */ var selection_order = (function() {

for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	  if (node = group[i]) {
		if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
		next = node;
	  }
	}
}

return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/sort.js

/* harmony default export */ var selection_sort = (function(compare) {
if (!compare) compare = sort_ascending;

function compareNode(a, b) {
	return a && b ? compare(a.__data__, b.__data__) : !a - !b;
}

for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	  if (node = group[i]) {
		sortgroup[i] = node;
	  }
	}
	sortgroup.sort(compareNode);
}

return new Selection(sortgroups, this._parents).order();
});

function sort_ascending(a, b) {
return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/call.js
/* harmony default export */ var call = (function() {
var callback = arguments[0];
arguments[0] = this;
callback.apply(null, arguments);
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/nodes.js
/* harmony default export */ var selection_nodes = (function() {
var nodes = new Array(this.size()), i = -1;
this.each(function() { nodes[++i] = this; });
return nodes;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/node.js
/* harmony default export */ var selection_node = (function() {

for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	  var node = group[i];
	  if (node) return node;
	}
}

return null;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/size.js
/* harmony default export */ var selection_size = (function() {
var size = 0;
this.each(function() { ++size; });
return size;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/empty.js
/* harmony default export */ var selection_empty = (function() {
return !this.node();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/each.js
/* harmony default export */ var each = (function(callback) {

for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	  if (node = group[i]) callback.call(node, node.__data__, i, group);
	}
}

return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/attr.js

function attrRemove(name) {
return function() {
	this.removeAttribute(name);
};
}

function attrRemoveNS(fullname) {
return function() {
	this.removeAttributeNS(fullname.space, fullname.local);
};
}

function attrConstant(name, value) {
return function() {
	this.setAttribute(name, value);
};
}

function attrConstantNS(fullname, value) {
return function() {
	this.setAttributeNS(fullname.space, fullname.local, value);
};
}

function attrFunction(name, value) {
return function() {
	var v = value.apply(this, arguments);
	if (v == null) this.removeAttribute(name);
	else this.setAttribute(name, v);
};
}

function attrFunctionNS(fullname, value) {
return function() {
	var v = value.apply(this, arguments);
	if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	else this.setAttributeNS(fullname.space, fullname.local, v);
};
}

/* harmony default export */ var attr = (function(name, value) {
var fullname = namespace(name);

if (arguments.length < 2) {
	var node = this.node();
	return fullname.local
		? node.getAttributeNS(fullname.space, fullname.local)
		: node.getAttribute(fullname);
}

return this.each((value == null
	  ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	  ? (fullname.local ? attrFunctionNS : attrFunction)
	  : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/window.js
/* harmony default export */ var src_window = (function(node) {
return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	  || (node.document && node) // node is a Window
	  || node.defaultView; // node is a Document
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/style.js

function styleRemove(name) {
return function() {
	this.style.removeProperty(name);
};
}

function styleConstant(name, value, priority) {
return function() {
	this.style.setProperty(name, value, priority);
};
}

function styleFunction(name, value, priority) {
return function() {
	var v = value.apply(this, arguments);
	if (v == null) this.style.removeProperty(name);
	else this.style.setProperty(name, v, priority);
};
}

/* harmony default export */ var style = (function(name, value, priority) {
return arguments.length > 1
	  ? this.each((value == null
			? styleRemove : typeof value === "function"
			? styleFunction
			: styleConstant)(name, value, priority == null ? "" : priority))
	  : styleValue(this.node(), name);
});

function styleValue(node, name) {
return node.style.getPropertyValue(name)
	  || src_window(node).getComputedStyle(node, null).getPropertyValue(name);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
return function() {
	delete this[name];
};
}

function propertyConstant(name, value) {
return function() {
	this[name] = value;
};
}

function propertyFunction(name, value) {
return function() {
	var v = value.apply(this, arguments);
	if (v == null) delete this[name];
	else this[name] = v;
};
}

/* harmony default export */ var property = (function(name, value) {
return arguments.length > 1
	  ? this.each((value == null
		  ? propertyRemove : typeof value === "function"
		  ? propertyFunction
		  : propertyConstant)(name, value))
	  : this.node()[name];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
return string.trim().split(/^|\s+/);
}

function classList(node) {
return node.classList || new ClassList(node);
}

function ClassList(node) {
this._node = node;
this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
add: function(name) {
	var i = this._names.indexOf(name);
	if (i < 0) {
	  this._names.push(name);
	  this._node.setAttribute("class", this._names.join(" "));
	}
},
remove: function(name) {
	var i = this._names.indexOf(name);
	if (i >= 0) {
	  this._names.splice(i, 1);
	  this._node.setAttribute("class", this._names.join(" "));
	}
},
contains: function(name) {
	return this._names.indexOf(name) >= 0;
}
};

function classedAdd(node, names) {
var list = classList(node), i = -1, n = names.length;
while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
var list = classList(node), i = -1, n = names.length;
while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
return function() {
	classedAdd(this, names);
};
}

function classedFalse(names) {
return function() {
	classedRemove(this, names);
};
}

function classedFunction(names, value) {
return function() {
	(value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
};
}

/* harmony default export */ var classed = (function(name, value) {
var names = classArray(name + "");

if (arguments.length < 2) {
	var list = classList(this.node()), i = -1, n = names.length;
	while (++i < n) if (!list.contains(names[i])) return false;
	return true;
}

return this.each((typeof value === "function"
	  ? classedFunction : value
	  ? classedTrue
	  : classedFalse)(names, value));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/text.js
function textRemove() {
this.textContent = "";
}

function textConstant(value) {
return function() {
	this.textContent = value;
};
}

function textFunction(value) {
return function() {
	var v = value.apply(this, arguments);
	this.textContent = v == null ? "" : v;
};
}

/* harmony default export */ var selection_text = (function(value) {
return arguments.length
	  ? this.each(value == null
		  ? textRemove : (typeof value === "function"
		  ? textFunction
		  : textConstant)(value))
	  : this.node().textContent;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
this.innerHTML = "";
}

function htmlConstant(value) {
return function() {
	this.innerHTML = value;
};
}

function htmlFunction(value) {
return function() {
	var v = value.apply(this, arguments);
	this.innerHTML = v == null ? "" : v;
};
}

/* harmony default export */ var html = (function(value) {
return arguments.length
	  ? this.each(value == null
		  ? htmlRemove : (typeof value === "function"
		  ? htmlFunction
		  : htmlConstant)(value))
	  : this.node().innerHTML;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/raise.js
function raise() {
if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ var selection_raise = (function() {
return this.each(raise);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/lower.js
function lower() {
if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ var selection_lower = (function() {
return this.each(lower);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/append.js

/* harmony default export */ var append = (function(name) {
var create = typeof name === "function" ? name : creator(name);
return this.select(function() {
	return this.appendChild(create.apply(this, arguments));
});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/insert.js

function constantNull() {
return null;
}

/* harmony default export */ var insert = (function(name, before) {
var create = typeof name === "function" ? name : creator(name),
	  select = before == null ? constantNull : typeof before === "function" ? before : src_selector(before);
return this.select(function() {
	return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/remove.js
function remove() {
var parent = this.parentNode;
if (parent) parent.removeChild(this);
}

/* harmony default export */ var selection_remove = (function() {
return this.each(remove);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ var clone = (function(deep) {
return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/datum.js
/* harmony default export */ var datum = (function(value) {
return arguments.length
	  ? this.property("__data__", value)
	  : this.node().__data__;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/on.js
var filterEvents = {};

var on_event = null;

if (typeof document !== "undefined") {
var on_element = document.documentElement;
if (!("onmouseenter" in on_element)) {
	filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
}
}

function filterContextListener(listener, index, group) {
listener = contextListener(listener, index, group);
return function(event) {
	var related = event.relatedTarget;
	if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	  listener.call(this, event);
	}
};
}

function contextListener(listener, index, group) {
return function(event1) {
	var event0 = on_event; // Events can be reentrant (e.g., focus).
	on_event = event1;
	try {
	  listener.call(this, this.__data__, index, group);
	} finally {
	  on_event = event0;
	}
};
}

function on_parseTypenames(typenames) {
return typenames.trim().split(/^|\s+/).map(function(t) {
	var name = "", i = t.indexOf(".");
	if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	return {type: t, name: name};
});
}

function onRemove(typename) {
return function() {
	var on = this.__on;
	if (!on) return;
	for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	  if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
		this.removeEventListener(o.type, o.listener, o.capture);
	  } else {
		on[++i] = o;
	  }
	}
	if (++i) on.length = i;
	else delete this.__on;
};
}

function onAdd(typename, value, capture) {
var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
return function(d, i, group) {
	var on = this.__on, o, listener = wrap(value, i, group);
	if (on) for (var j = 0, m = on.length; j < m; ++j) {
	  if ((o = on[j]).type === typename.type && o.name === typename.name) {
		this.removeEventListener(o.type, o.listener, o.capture);
		this.addEventListener(o.type, o.listener = listener, o.capture = capture);
		o.value = value;
		return;
	  }
	}
	this.addEventListener(typename.type, listener, capture);
	o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	if (!on) this.__on = [o];
	else on.push(o);
};
}

/* harmony default export */ var on = (function(typename, value, capture) {
var typenames = on_parseTypenames(typename + ""), i, n = typenames.length, t;

if (arguments.length < 2) {
	var on = this.node().__on;
	if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	  for (i = 0, o = on[j]; i < n; ++i) {
		if ((t = typenames[i]).type === o.type && t.name === o.name) {
		  return o.value;
		}
	  }
	}
	return;
}

on = value ? onAdd : onRemove;
if (capture == null) capture = false;
for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
return this;
});

function customEvent(event1, listener, that, args) {
var event0 = on_event;
event1.sourceEvent = on_event;
on_event = event1;
try {
	return listener.apply(that, args);
} finally {
	on_event = event0;
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/dispatch.js

function dispatchEvent(node, type, params) {
var window = src_window(node),
	  event = window.CustomEvent;

if (typeof event === "function") {
	event = new event(type, params);
} else {
	event = window.document.createEvent("Event");
	if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	else event.initEvent(type, false, false);
}

node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
return function() {
	return dispatchEvent(this, type, params);
};
}

function dispatchFunction(type, params) {
return function() {
	return dispatchEvent(this, type, params.apply(this, arguments));
};
}

/* harmony default export */ var selection_dispatch = (function(type, params) {
return this.each((typeof params === "function"
	  ? dispatchFunction
	  : dispatchConstant)(type, params));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selection/index.js

var selection_root = [null];

function Selection(groups, parents) {
this._groups = groups;
this._parents = parents;
}

function selection_selection() {
return new Selection([[document.documentElement]], selection_root);
}

Selection.prototype = selection_selection.prototype = {
constructor: Selection,
select: selection_select,
selectAll: selectAll,
filter: selection_filter,
data: selection_data,
enter: selection_enter,
exit: selection_exit,
merge: selection_merge,
order: selection_order,
sort: selection_sort,
call: call,
nodes: selection_nodes,
node: selection_node,
size: selection_size,
empty: selection_empty,
each: each,
attr: attr,
style: style,
property: property,
classed: classed,
text: selection_text,
html: html,
raise: selection_raise,
lower: selection_lower,
append: append,
insert: insert,
remove: selection_remove,
clone: clone,
datum: datum,
on: on,
dispatch: selection_dispatch
};

/* harmony default export */ var src_selection = (selection_selection);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/select.js

/* harmony default export */ var src_select = (function(selector) {
return typeof selector === "string"
	  ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	  : new Selection([[selector]], selection_root);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/create.js

/* harmony default export */ var src_create = (function(name) {
return src_select(creator(name).call(document.documentElement));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/local.js
var nextId = 0;

function local() {
return new Local;
}

function Local() {
this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
constructor: Local,
get: function(node) {
	var id = this._;
	while (!(id in node)) if (!(node = node.parentNode)) return;
	return node[id];
},
set: function(node, value) {
	return node[this._] = value;
},
remove: function(node) {
	return this._ in node && delete node[this._];
},
toString: function() {
	return this._;
}
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/sourceEvent.js

/* harmony default export */ var sourceEvent = (function() {
var current = on_event, source;
while (source = current.sourceEvent) current = source;
return current;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/point.js
/* harmony default export */ var src_point = (function(node, event) {
var svg = node.ownerSVGElement || node;

if (svg.createSVGPoint) {
	var point = svg.createSVGPoint();
	point.x = event.clientX, point.y = event.clientY;
	point = point.matrixTransform(node.getScreenCTM().inverse());
	return [point.x, point.y];
}

var rect = node.getBoundingClientRect();
return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/mouse.js

/* harmony default export */ var mouse = (function(node) {
var event = sourceEvent();
if (event.changedTouches) event = event.changedTouches[0];
return src_point(node, event);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/selectAll.js

/* harmony default export */ var src_selectAll = (function(selector) {
return typeof selector === "string"
	  ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
	  : new Selection([selector == null ? [] : selector], selection_root);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/touch.js

/* harmony default export */ var src_touch = (function(node, touches, identifier) {
if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
	if ((touch = touches[i]).identifier === identifier) {
	  return src_point(node, touch);
	}
}

return null;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/src/touches.js

/* harmony default export */ var src_touches = (function(node, touches) {
if (touches == null) touches = sourceEvent().touches;

for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
	points[i] = src_point(node, touches[i]);
}

return points;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-selection/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-drag/src/noevent.js

function nopropagation() {
on_event.stopImmediatePropagation();
}

/* harmony default export */ var noevent = (function() {
on_event.preventDefault();
on_event.stopImmediatePropagation();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-drag/src/nodrag.js

/* harmony default export */ var nodrag = (function(view) {
var root = view.document.documentElement,
	  selection = src_select(view).on("dragstart.drag", noevent, true);
if ("onselectstart" in root) {
	selection.on("selectstart.drag", noevent, true);
} else {
	root.__noselect = root.style.MozUserSelect;
	root.style.MozUserSelect = "none";
}
});

function yesdrag(view, noclick) {
var root = view.document.documentElement,
	  selection = src_select(view).on("dragstart.drag", null);
if (noclick) {
	selection.on("click.drag", noevent, true);
	setTimeout(function() { selection.on("click.drag", null); }, 0);
}
if ("onselectstart" in root) {
	selection.on("selectstart.drag", null);
} else {
	root.style.MozUserSelect = root.__noselect;
	delete root.__noselect;
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-drag/src/constant.js
/* harmony default export */ var d3_drag_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-drag/src/event.js
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
this.target = target;
this.type = type;
this.subject = subject;
this.identifier = id;
this.active = active;
this.x = x;
this.y = y;
this.dx = dx;
this.dy = dy;
this._ = dispatch;
}

DragEvent.prototype.on = function() {
var value = this._.on.apply(this._, arguments);
return value === this._ ? this : value;
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-drag/src/drag.js

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
return !on_event.button;
}

function defaultContainer() {
return this.parentNode;
}

function defaultSubject(d) {
return d == null ? {x: on_event.x, y: on_event.y} : d;
}

function defaultTouchable() {
return "ontouchstart" in this;
}

/* harmony default export */ var src_drag = (function() {
var filter = defaultFilter,
	  container = defaultContainer,
	  subject = defaultSubject,
	  touchable = defaultTouchable,
	  gestures = {},
	  listeners = src_dispatch("start", "drag", "end"),
	  active = 0,
	  mousedownx,
	  mousedowny,
	  mousemoving,
	  touchending,
	  clickDistance2 = 0;

function drag(selection) {
	selection
		.on("mousedown.drag", mousedowned)
	  .filter(touchable)
		.on("touchstart.drag", touchstarted)
		.on("touchmove.drag", touchmoved)
		.on("touchend.drag touchcancel.drag", touchended)
		.style("touch-action", "none")
		.style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
}

function mousedowned() {
	if (touchending || !filter.apply(this, arguments)) return;
	var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
	if (!gesture) return;
	src_select(on_event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
	nodrag(on_event.view);
	nopropagation();
	mousemoving = false;
	mousedownx = on_event.clientX;
	mousedowny = on_event.clientY;
	gesture("start");
}

function mousemoved() {
	noevent();
	if (!mousemoving) {
	  var dx = on_event.clientX - mousedownx, dy = on_event.clientY - mousedowny;
	  mousemoving = dx * dx + dy * dy > clickDistance2;
	}
	gestures.mouse("drag");
}

function mouseupped() {
	src_select(on_event.view).on("mousemove.drag mouseup.drag", null);
	yesdrag(on_event.view, mousemoving);
	noevent();
	gestures.mouse("end");
}

function touchstarted() {
	if (!filter.apply(this, arguments)) return;
	var touches = on_event.changedTouches,
		c = container.apply(this, arguments),
		n = touches.length, i, gesture;

	for (i = 0; i < n; ++i) {
	  if (gesture = beforestart(touches[i].identifier, c, src_touch, this, arguments)) {
		nopropagation();
		gesture("start");
	  }
	}
}

function touchmoved() {
	var touches = on_event.changedTouches,
		n = touches.length, i, gesture;

	for (i = 0; i < n; ++i) {
	  if (gesture = gestures[touches[i].identifier]) {
		noevent();
		gesture("drag");
	  }
	}
}

function touchended() {
	var touches = on_event.changedTouches,
		n = touches.length, i, gesture;

	if (touchending) clearTimeout(touchending);
	touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	for (i = 0; i < n; ++i) {
	  if (gesture = gestures[touches[i].identifier]) {
		nopropagation();
		gesture("end");
	  }
	}
}

function beforestart(id, container, point, that, args) {
	var p = point(container, id), s, dx, dy,
		sublisteners = listeners.copy();

	if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
	  if ((on_event.subject = s = subject.apply(that, args)) == null) return false;
	  dx = s.x - p[0] || 0;
	  dy = s.y - p[1] || 0;
	  return true;
	})) return;

	return function gesture(type) {
	  var p0 = p, n;
	  switch (type) {
		case "start": gestures[id] = gesture, n = active++; break;
		case "end": delete gestures[id], --active; // nobreak
		case "drag": p = point(container, id), n = active; break;
	  }
	  customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
	};
}

drag.filter = function(_) {
	return arguments.length ? (filter = typeof _ === "function" ? _ : d3_drag_src_constant(!!_), drag) : filter;
};

drag.container = function(_) {
	return arguments.length ? (container = typeof _ === "function" ? _ : d3_drag_src_constant(_), drag) : container;
};

drag.subject = function(_) {
	return arguments.length ? (subject = typeof _ === "function" ? _ : d3_drag_src_constant(_), drag) : subject;
};

drag.touchable = function(_) {
	return arguments.length ? (touchable = typeof _ === "function" ? _ : d3_drag_src_constant(!!_), drag) : touchable;
};

drag.on = function() {
	var value = listeners.on.apply(listeners, arguments);
	return value === listeners ? drag : value;
};

drag.clickDistance = function(_) {
	return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
};

return drag;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-drag/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-color/src/define.js
/* harmony default export */ var define = (function(constructor, factory, prototype) {
constructor.prototype = factory.prototype = prototype;
prototype.constructor = constructor;
});

function extend(parent, definition) {
var prototype = Object.create(parent.prototype);
for (var key in definition) prototype[key] = definition[key];
return prototype;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-color/src/color.js

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
	reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	reHex3 = /^#([0-9a-f]{3})$/,
	reHex6 = /^#([0-9a-f]{6})$/,
	reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
aliceblue: 0xf0f8ff,
antiquewhite: 0xfaebd7,
aqua: 0x00ffff,
aquamarine: 0x7fffd4,
azure: 0xf0ffff,
beige: 0xf5f5dc,
bisque: 0xffe4c4,
black: 0x000000,
blanchedalmond: 0xffebcd,
blue: 0x0000ff,
blueviolet: 0x8a2be2,
brown: 0xa52a2a,
burlywood: 0xdeb887,
cadetblue: 0x5f9ea0,
chartreuse: 0x7fff00,
chocolate: 0xd2691e,
coral: 0xff7f50,
cornflowerblue: 0x6495ed,
cornsilk: 0xfff8dc,
crimson: 0xdc143c,
cyan: 0x00ffff,
darkblue: 0x00008b,
darkcyan: 0x008b8b,
darkgoldenrod: 0xb8860b,
darkgray: 0xa9a9a9,
darkgreen: 0x006400,
darkgrey: 0xa9a9a9,
darkkhaki: 0xbdb76b,
darkmagenta: 0x8b008b,
darkolivegreen: 0x556b2f,
darkorange: 0xff8c00,
darkorchid: 0x9932cc,
darkred: 0x8b0000,
darksalmon: 0xe9967a,
darkseagreen: 0x8fbc8f,
darkslateblue: 0x483d8b,
darkslategray: 0x2f4f4f,
darkslategrey: 0x2f4f4f,
darkturquoise: 0x00ced1,
darkviolet: 0x9400d3,
deeppink: 0xff1493,
deepskyblue: 0x00bfff,
dimgray: 0x696969,
dimgrey: 0x696969,
dodgerblue: 0x1e90ff,
firebrick: 0xb22222,
floralwhite: 0xfffaf0,
forestgreen: 0x228b22,
fuchsia: 0xff00ff,
gainsboro: 0xdcdcdc,
ghostwhite: 0xf8f8ff,
gold: 0xffd700,
goldenrod: 0xdaa520,
gray: 0x808080,
green: 0x008000,
greenyellow: 0xadff2f,
grey: 0x808080,
honeydew: 0xf0fff0,
hotpink: 0xff69b4,
indianred: 0xcd5c5c,
indigo: 0x4b0082,
ivory: 0xfffff0,
khaki: 0xf0e68c,
lavender: 0xe6e6fa,
lavenderblush: 0xfff0f5,
lawngreen: 0x7cfc00,
lemonchiffon: 0xfffacd,
lightblue: 0xadd8e6,
lightcoral: 0xf08080,
lightcyan: 0xe0ffff,
lightgoldenrodyellow: 0xfafad2,
lightgray: 0xd3d3d3,
lightgreen: 0x90ee90,
lightgrey: 0xd3d3d3,
lightpink: 0xffb6c1,
lightsalmon: 0xffa07a,
lightseagreen: 0x20b2aa,
lightskyblue: 0x87cefa,
lightslategray: 0x778899,
lightslategrey: 0x778899,
lightsteelblue: 0xb0c4de,
lightyellow: 0xffffe0,
lime: 0x00ff00,
limegreen: 0x32cd32,
linen: 0xfaf0e6,
magenta: 0xff00ff,
maroon: 0x800000,
mediumaquamarine: 0x66cdaa,
mediumblue: 0x0000cd,
mediumorchid: 0xba55d3,
mediumpurple: 0x9370db,
mediumseagreen: 0x3cb371,
mediumslateblue: 0x7b68ee,
mediumspringgreen: 0x00fa9a,
mediumturquoise: 0x48d1cc,
mediumvioletred: 0xc71585,
midnightblue: 0x191970,
mintcream: 0xf5fffa,
mistyrose: 0xffe4e1,
moccasin: 0xffe4b5,
navajowhite: 0xffdead,
navy: 0x000080,
oldlace: 0xfdf5e6,
olive: 0x808000,
olivedrab: 0x6b8e23,
orange: 0xffa500,
orangered: 0xff4500,
orchid: 0xda70d6,
palegoldenrod: 0xeee8aa,
palegreen: 0x98fb98,
paleturquoise: 0xafeeee,
palevioletred: 0xdb7093,
papayawhip: 0xffefd5,
peachpuff: 0xffdab9,
peru: 0xcd853f,
pink: 0xffc0cb,
plum: 0xdda0dd,
powderblue: 0xb0e0e6,
purple: 0x800080,
rebeccapurple: 0x663399,
red: 0xff0000,
rosybrown: 0xbc8f8f,
royalblue: 0x4169e1,
saddlebrown: 0x8b4513,
salmon: 0xfa8072,
sandybrown: 0xf4a460,
seagreen: 0x2e8b57,
seashell: 0xfff5ee,
sienna: 0xa0522d,
silver: 0xc0c0c0,
skyblue: 0x87ceeb,
slateblue: 0x6a5acd,
slategray: 0x708090,
slategrey: 0x708090,
snow: 0xfffafa,
springgreen: 0x00ff7f,
steelblue: 0x4682b4,
tan: 0xd2b48c,
teal: 0x008080,
thistle: 0xd8bfd8,
tomato: 0xff6347,
turquoise: 0x40e0d0,
violet: 0xee82ee,
wheat: 0xf5deb3,
white: 0xffffff,
whitesmoke: 0xf5f5f5,
yellow: 0xffff00,
yellowgreen: 0x9acd32
};

define(Color, color_color, {
displayable: function() {
	return this.rgb().displayable();
},
toString: function() {
	return this.rgb() + "";
}
});

function color_color(format) {
var m;
format = (format + "").trim().toLowerCase();
return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
	  : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
	  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	  : named.hasOwnProperty(format) ? rgbn(named[format])
	  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	  : null;
}

function rgbn(n) {
return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
if (a <= 0) r = g = b = NaN;
return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
if (!(o instanceof Color)) o = color_color(o);
if (!o) return new Rgb;
o = o.rgb();
return new Rgb(o.r, o.g, o.b, o.opacity);
}

function color_rgb(r, g, b, opacity) {
return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
this.r = +r;
this.g = +g;
this.b = +b;
this.opacity = +opacity;
}

define(Rgb, color_rgb, extend(Color, {
brighter: function(k) {
	k = k == null ? brighter : Math.pow(brighter, k);
	return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
},
darker: function(k) {
	k = k == null ? darker : Math.pow(darker, k);
	return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
},
rgb: function() {
	return this;
},
displayable: function() {
	return (0 <= this.r && this.r <= 255)
		&& (0 <= this.g && this.g <= 255)
		&& (0 <= this.b && this.b <= 255)
		&& (0 <= this.opacity && this.opacity <= 1);
},
toString: function() {
	var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	return (a === 1 ? "rgb(" : "rgba(")
		+ Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
		+ Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
		+ Math.max(0, Math.min(255, Math.round(this.b) || 0))
		+ (a === 1 ? ")" : ", " + a + ")");
}
}));

function hsla(h, s, l, a) {
if (a <= 0) h = s = l = NaN;
else if (l <= 0 || l >= 1) h = s = NaN;
else if (s <= 0) h = NaN;
return new Hsl(h, s, l, a);
}

function hslConvert(o) {
if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
if (!(o instanceof Color)) o = color_color(o);
if (!o) return new Hsl;
if (o instanceof Hsl) return o;
o = o.rgb();
var r = o.r / 255,
	  g = o.g / 255,
	  b = o.b / 255,
	  min = Math.min(r, g, b),
	  max = Math.max(r, g, b),
	  h = NaN,
	  s = max - min,
	  l = (max + min) / 2;
if (s) {
	if (r === max) h = (g - b) / s + (g < b) * 6;
	else if (g === max) h = (b - r) / s + 2;
	else h = (r - g) / s + 4;
	s /= l < 0.5 ? max + min : 2 - max - min;
	h *= 60;
} else {
	s = l > 0 && l < 1 ? 0 : h;
}
return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
this.h = +h;
this.s = +s;
this.l = +l;
this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
brighter: function(k) {
	k = k == null ? brighter : Math.pow(brighter, k);
	return new Hsl(this.h, this.s, this.l * k, this.opacity);
},
darker: function(k) {
	k = k == null ? darker : Math.pow(darker, k);
	return new Hsl(this.h, this.s, this.l * k, this.opacity);
},
rgb: function() {
	var h = this.h % 360 + (this.h < 0) * 360,
		s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
		l = this.l,
		m2 = l + (l < 0.5 ? l : 1 - l) * s,
		m1 = 2 * l - m2;
	return new Rgb(
	  hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	  hsl2rgb(h, m1, m2),
	  hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	  this.opacity
	);
},
displayable: function() {
	return (0 <= this.s && this.s <= 1 || isNaN(this.s))
		&& (0 <= this.l && this.l <= 1)
		&& (0 <= this.opacity && this.opacity <= 1);
}
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
return (h < 60 ? m1 + (m2 - m1) * h / 60
	  : h < 180 ? m2
	  : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	  : m1) * 255;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-color/src/lab.js

var Kn = 18,
	Xn = 0.950470, // D65 standard referent
	Yn = 1,
	Zn = 1.088830,
	lab_t0 = 4 / 29,
	lab_t1 = 6 / 29,
	lab_t2 = 3 * lab_t1 * lab_t1,
	t3 = lab_t1 * lab_t1 * lab_t1;

function labConvert(o) {
if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
if (o instanceof Hcl) {
	var h = o.h * deg2rad;
	return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
if (!(o instanceof Rgb)) o = rgbConvert(o);
var b = rgb2xyz(o.r),
	  a = rgb2xyz(o.g),
	  l = rgb2xyz(o.b),
	  x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
	  y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
	  z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
this.l = +l;
this.a = +a;
this.b = +b;
this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
brighter: function(k) {
	return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
},
darker: function(k) {
	return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
},
rgb: function() {
	var y = (this.l + 16) / 116,
		x = isNaN(this.a) ? y : y + this.a / 500,
		z = isNaN(this.b) ? y : y - this.b / 200;
	y = Yn * lab2xyz(y);
	x = Xn * lab2xyz(x);
	z = Zn * lab2xyz(z);
	return new Rgb(
	  xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
	  xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
	  xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
	  this.opacity
	);
}
}));

function xyz2lab(t) {
return t > t3 ? Math.pow(t, 1 / 3) : t / lab_t2 + lab_t0;
}

function lab2xyz(t) {
return t > lab_t1 ? t * t * t : lab_t2 * (t - lab_t0);
}

function xyz2rgb(x) {
return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
if (!(o instanceof Lab)) o = labConvert(o);
var h = Math.atan2(o.b, o.a) * rad2deg;
return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
this.h = +h;
this.c = +c;
this.l = +l;
this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
brighter: function(k) {
	return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
},
darker: function(k) {
	return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
},
rgb: function() {
	return labConvert(this).rgb();
}
}));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-color/src/cubehelix.js

var cubehelix_A = -0.14861,
	cubehelix_B = +1.78277,
	C = -0.29227,
	cubehelix_D = -0.90649,
	cubehelix_E = +1.97294,
	ED = cubehelix_E * cubehelix_D,
	EB = cubehelix_E * cubehelix_B,
	BC_DA = cubehelix_B * C - cubehelix_D * cubehelix_A;

function cubehelixConvert(o) {
if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
if (!(o instanceof Rgb)) o = rgbConvert(o);
var r = o.r / 255,
	  g = o.g / 255,
	  b = o.b / 255,
	  l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
	  bl = b - l,
	  k = (cubehelix_E * (g - l) - C * bl) / cubehelix_D,
	  s = Math.sqrt(k * k + bl * bl) / (cubehelix_E * l * (1 - l)), // NaN if l=0 or l=1
	  h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix_cubehelix(h, s, l, opacity) {
return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
this.h = +h;
this.s = +s;
this.l = +l;
this.opacity = +opacity;
}

define(Cubehelix, cubehelix_cubehelix, extend(Color, {
brighter: function(k) {
	k = k == null ? brighter : Math.pow(brighter, k);
	return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
},
darker: function(k) {
	k = k == null ? darker : Math.pow(darker, k);
	return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
},
rgb: function() {
	var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
		l = +this.l,
		a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
		cosh = Math.cos(h),
		sinh = Math.sin(h);
	return new Rgb(
	  255 * (l + a * (cubehelix_A * cosh + cubehelix_B * sinh)),
	  255 * (l + a * (C * cosh + cubehelix_D * sinh)),
	  255 * (l + a * (cubehelix_E * cosh)),
	  this.opacity
	);
}
}));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-color/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
var t2 = t1 * t1, t3 = t2 * t1;
return ((1 - 3 * t1 + 3 * t2 - t3) * v0
	  + (4 - 6 * t2 + 3 * t3) * v1
	  + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
	  + t3 * v3) / 6;
}

/* harmony default export */ var src_basis = (function(values) {
var n = values.length - 1;
return function(t) {
	var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
		v1 = values[i],
		v2 = values[i + 1],
		v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
		v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
	return basis((t - i / n) * n, v0, v1, v2, v3);
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/basisClosed.js

/* harmony default export */ var basisClosed = (function(values) {
var n = values.length;
return function(t) {
	var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
		v0 = values[(i + n - 1) % n],
		v1 = values[i % n],
		v2 = values[(i + 1) % n],
		v3 = values[(i + 2) % n];
	return basis((t - i / n) * n, v0, v1, v2, v3);
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/constant.js
/* harmony default export */ var d3_interpolate_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/color.js

function linear(a, d) {
return function(t) {
	return a + t * d;
};
}

function exponential(a, b, y) {
return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	return Math.pow(a + t * b, y);
};
}

function color_hue(a, b) {
var d = b - a;
return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : d3_interpolate_src_constant(isNaN(a) ? b : a);
}

function gamma(y) {
return (y = +y) === 1 ? nogamma : function(a, b) {
	return b - a ? exponential(a, b, y) : d3_interpolate_src_constant(isNaN(a) ? b : a);
};
}

function nogamma(a, b) {
var d = b - a;
return d ? linear(a, d) : d3_interpolate_src_constant(isNaN(a) ? b : a);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/rgb.js

/* harmony default export */ var src_rgb = ((function rgbGamma(y) {
var color = gamma(y);

function rgb(start, end) {
	var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
		g = color(start.g, end.g),
		b = color(start.b, end.b),
		opacity = nogamma(start.opacity, end.opacity);
	return function(t) {
	  start.r = r(t);
	  start.g = g(t);
	  start.b = b(t);
	  start.opacity = opacity(t);
	  return start + "";
	};
}

rgb.gamma = rgbGamma;

return rgb;
})(1));

function rgbSpline(spline) {
return function(colors) {
	var n = colors.length,
		r = new Array(n),
		g = new Array(n),
		b = new Array(n),
		i, color;
	for (i = 0; i < n; ++i) {
	  color = color_rgb(colors[i]);
	  r[i] = color.r || 0;
	  g[i] = color.g || 0;
	  b[i] = color.b || 0;
	}
	r = spline(r);
	g = spline(g);
	b = spline(b);
	color.opacity = 1;
	return function(t) {
	  color.r = r(t);
	  color.g = g(t);
	  color.b = b(t);
	  return color + "";
	};
};
}

var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/array.js

/* harmony default export */ var src_array = (function(a, b) {
var nb = b ? b.length : 0,
	  na = a ? Math.min(nb, a.length) : 0,
	  x = new Array(na),
	  c = new Array(nb),
	  i;

for (i = 0; i < na; ++i) x[i] = src_value(a[i], b[i]);
for (; i < nb; ++i) c[i] = b[i];

return function(t) {
	for (i = 0; i < na; ++i) c[i] = x[i](t);
	return c;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/date.js
/* harmony default export */ var src_date = (function(a, b) {
var d = new Date;
return a = +a, b -= a, function(t) {
	return d.setTime(a + b * t), d;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/number.js
/* harmony default export */ var src_number = (function(a, b) {
return a = +a, b -= a, function(t) {
	return a + b * t;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/object.js

/* harmony default export */ var src_object = (function(a, b) {
var i = {},
	  c = {},
	  k;

if (a === null || typeof a !== "object") a = {};
if (b === null || typeof b !== "object") b = {};

for (k in b) {
	if (k in a) {
	  i[k] = src_value(a[k], b[k]);
	} else {
	  c[k] = b[k];
	}
}

return function(t) {
	for (k in i) c[k] = i[k](t);
	return c;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/string.js

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
	reB = new RegExp(reA.source, "g");

function string_zero(b) {
return function() {
	return b;
};
}

function one(b) {
return function(t) {
	return b(t) + "";
};
}

/* harmony default export */ var src_string = (function(a, b) {
var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	  am, // current match in a
	  bm, // current match in b
	  bs, // string preceding current number in b, if any
	  i = -1, // index in s
	  s = [], // string constants and placeholders
	  q = []; // number interpolators

// Coerce inputs to strings.
a = a + "", b = b + "";

// Interpolate pairs of numbers in a & b.
while ((am = reA.exec(a))
	  && (bm = reB.exec(b))) {
	if ((bs = bm.index) > bi) { // a string precedes the next number in b
	  bs = b.slice(bi, bs);
	  if (s[i]) s[i] += bs; // coalesce with previous string
	  else s[++i] = bs;
	}
	if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	  if (s[i]) s[i] += bm; // coalesce with previous string
	  else s[++i] = bm;
	} else { // interpolate non-matching numbers
	  s[++i] = null;
	  q.push({i: i, x: src_number(am, bm)});
	}
	bi = reB.lastIndex;
}

// Add remains of b.
if (bi < b.length) {
	bs = b.slice(bi);
	if (s[i]) s[i] += bs; // coalesce with previous string
	else s[++i] = bs;
}

// Special optimization for only a single match.
// Otherwise, interpolate each of the numbers and rejoin the string.
return s.length < 2 ? (q[0]
	  ? one(q[0].x)
	  : string_zero(b))
	  : (b = q.length, function(t) {
		  for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
		  return s.join("");
		});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/value.js

/* harmony default export */ var src_value = (function(a, b) {
var t = typeof b, c;
return b == null || t === "boolean" ? d3_interpolate_src_constant(b)
	  : (t === "number" ? src_number
	  : t === "string" ? ((c = color_color(b)) ? (b = c, src_rgb) : src_string)
	  : b instanceof color_color ? src_rgb
	  : b instanceof Date ? src_date
	  : Array.isArray(b) ? src_array
	  : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? src_object
	  : src_number)(a, b);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/round.js
/* harmony default export */ var src_round = (function(a, b) {
return a = +a, b -= a, function(t) {
	return Math.round(a + b * t);
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var decompose_identity = {
translateX: 0,
translateY: 0,
rotate: 0,
skewX: 0,
scaleX: 1,
scaleY: 1
};

/* harmony default export */ var decompose = (function(a, b, c, d, e, f) {
var scaleX, scaleY, skewX;
if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
return {
	translateX: e,
	translateY: f,
	rotate: Math.atan2(b, a) * degrees,
	skewX: Math.atan(skewX) * degrees,
	scaleX: scaleX,
	scaleY: scaleY
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/transform/parse.js

var cssNode,
	cssRoot,
	cssView,
	svgNode;

function parseCss(value) {
if (value === "none") return decompose_identity;
if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
cssNode.style.transform = value;
value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
cssRoot.removeChild(cssNode);
value = value.slice(7, -1).split(",");
return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
if (value == null) return decompose_identity;
if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
svgNode.setAttribute("transform", value);
if (!(value = svgNode.transform.baseVal.consolidate())) return decompose_identity;
value = value.matrix;
return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/transform/index.js

function interpolateTransform(parse, pxComma, pxParen, degParen) {

function pop(s) {
	return s.length ? s.pop() + " " : "";
}

function translate(xa, ya, xb, yb, s, q) {
	if (xa !== xb || ya !== yb) {
	  var i = s.push("translate(", null, pxComma, null, pxParen);
	  q.push({i: i - 4, x: src_number(xa, xb)}, {i: i - 2, x: src_number(ya, yb)});
	} else if (xb || yb) {
	  s.push("translate(" + xb + pxComma + yb + pxParen);
	}
}

function rotate(a, b, s, q) {
	if (a !== b) {
	  if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	  q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: src_number(a, b)});
	} else if (b) {
	  s.push(pop(s) + "rotate(" + b + degParen);
	}
}

function skewX(a, b, s, q) {
	if (a !== b) {
	  q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: src_number(a, b)});
	} else if (b) {
	  s.push(pop(s) + "skewX(" + b + degParen);
	}
}

function scale(xa, ya, xb, yb, s, q) {
	if (xa !== xb || ya !== yb) {
	  var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	  q.push({i: i - 4, x: src_number(xa, xb)}, {i: i - 2, x: src_number(ya, yb)});
	} else if (xb !== 1 || yb !== 1) {
	  s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	}
}

return function(a, b) {
	var s = [], // string constants and placeholders
		q = []; // number interpolators
	a = parse(a), b = parse(b);
	translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	rotate(a.rotate, b.rotate, s, q);
	skewX(a.skewX, b.skewX, s, q);
	scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	a = b = null; // gc
	return function(t) {
	  var i = -1, n = q.length, o;
	  while (++i < n) s[(o = q[i]).i] = o.x(t);
	  return s.join("");
	};
};
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/zoom.js
var rho = Math.SQRT2,
	rho2 = 2,
	rho4 = 4,
	epsilon2 = 1e-12;

function zoom_cosh(x) {
return ((x = Math.exp(x)) + 1 / x) / 2;
}

function zoom_sinh(x) {
return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ var src_zoom = (function(p0, p1) {
var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
	  ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
	  dx = ux1 - ux0,
	  dy = uy1 - uy0,
	  d2 = dx * dx + dy * dy,
	  i,
	  S;

// Special case for u0 ≅ u1.
if (d2 < epsilon2) {
	S = Math.log(w1 / w0) / rho;
	i = function(t) {
	  return [
		ux0 + t * dx,
		uy0 + t * dy,
		w0 * Math.exp(rho * t * S)
	  ];
	}
}

// General case.
else {
	var d1 = Math.sqrt(d2),
		b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
		b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
		r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
		r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	S = (r1 - r0) / rho;
	i = function(t) {
	  var s = t * S,
		  coshr0 = zoom_cosh(r0),
		  u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - zoom_sinh(r0));
	  return [
		ux0 + u * dx,
		uy0 + u * dy,
		w0 * coshr0 / zoom_cosh(rho * s + r0)
	  ];
	}
}

i.duration = S * 1000;

return i;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/hsl.js

function hsl_hsl(hue) {
return function(start, end) {
	var h = hue((start = hsl(start)).h, (end = hsl(end)).h),
		s = nogamma(start.s, end.s),
		l = nogamma(start.l, end.l),
		opacity = nogamma(start.opacity, end.opacity);
	return function(t) {
	  start.h = h(t);
	  start.s = s(t);
	  start.l = l(t);
	  start.opacity = opacity(t);
	  return start + "";
	};
}
}

/* harmony default export */ var src_hsl = (hsl_hsl(color_hue));
var hslLong = hsl_hsl(nogamma);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/lab.js

function lab_lab(start, end) {
var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
	  a = nogamma(start.a, end.a),
	  b = nogamma(start.b, end.b),
	  opacity = nogamma(start.opacity, end.opacity);
return function(t) {
	start.l = l(t);
	start.a = a(t);
	start.b = b(t);
	start.opacity = opacity(t);
	return start + "";
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/hcl.js

function hcl_hcl(hue) {
return function(start, end) {
	var h = hue((start = hcl(start)).h, (end = hcl(end)).h),
		c = nogamma(start.c, end.c),
		l = nogamma(start.l, end.l),
		opacity = nogamma(start.opacity, end.opacity);
	return function(t) {
	  start.h = h(t);
	  start.c = c(t);
	  start.l = l(t);
	  start.opacity = opacity(t);
	  return start + "";
	};
}
}

/* harmony default export */ var src_hcl = (hcl_hcl(color_hue));
var hclLong = hcl_hcl(nogamma);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/cubehelix.js

function src_cubehelix_cubehelix(hue) {
return (function cubehelixGamma(y) {
	y = +y;

	function cubehelix(start, end) {
	  var h = hue((start = cubehelix_cubehelix(start)).h, (end = cubehelix_cubehelix(end)).h),
		  s = nogamma(start.s, end.s),
		  l = nogamma(start.l, end.l),
		  opacity = nogamma(start.opacity, end.opacity);
	  return function(t) {
		start.h = h(t);
		start.s = s(t);
		start.l = l(Math.pow(t, y));
		start.opacity = opacity(t);
		return start + "";
	  };
	}

	cubehelix.gamma = cubehelixGamma;

	return cubehelix;
})(1);
}

/* harmony default export */ var src_cubehelix = (src_cubehelix_cubehelix(color_hue));
var cubehelixLong = src_cubehelix_cubehelix(nogamma);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/src/quantize.js
/* harmony default export */ var quantize = (function(interpolator, n) {
var samples = new Array(n);
for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
return samples;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-interpolate/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-timer/src/timer.js
var timer_frame = 0, // is an animation frame pending?
	timeout = 0, // is a timeout pending?
	timer_interval = 0, // are any timers active?
	pokeDelay = 1000, // how frequently we check for clock skew
	taskHead,
	taskTail,
	clockLast = 0,
	clockNow = 0,
	clockSkew = 0,
	clock = typeof performance === "object" && performance.now ? performance : Date,
	setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
clockNow = 0;
}

function Timer() {
this._call =
this._time =
this._next = null;
}

Timer.prototype = timer.prototype = {
constructor: Timer,
restart: function(callback, delay, time) {
	if (typeof callback !== "function") throw new TypeError("callback is not a function");
	time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
	if (!this._next && taskTail !== this) {
	  if (taskTail) taskTail._next = this;
	  else taskHead = this;
	  taskTail = this;
	}
	this._call = callback;
	this._time = time;
	sleep();
},
stop: function() {
	if (this._call) {
	  this._call = null;
	  this._time = Infinity;
	  sleep();
	}
}
};

function timer(callback, delay, time) {
var t = new Timer;
t.restart(callback, delay, time);
return t;
}

function timerFlush() {
now(); // Get the current time, if not already set.
++timer_frame; // Pretend we’ve set an alarm, if we haven’t already.
var t = taskHead, e;
while (t) {
	if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	t = t._next;
}
--timer_frame;
}

function wake() {
clockNow = (clockLast = clock.now()) + clockSkew;
timer_frame = timeout = 0;
try {
	timerFlush();
} finally {
	timer_frame = 0;
	nap();
	clockNow = 0;
}
}

function poke() {
var now = clock.now(), delay = now - clockLast;
if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
var t0, t1 = taskHead, t2, time = Infinity;
while (t1) {
	if (t1._call) {
	  if (time > t1._time) time = t1._time;
	  t0 = t1, t1 = t1._next;
	} else {
	  t2 = t1._next, t1._next = null;
	  t1 = t0 ? t0._next = t2 : taskHead = t2;
	}
}
taskTail = t0;
sleep(time);
}

function sleep(time) {
if (timer_frame) return; // Soonest alarm already set, or will be.
if (timeout) timeout = clearTimeout(timeout);
var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
if (delay > 24) {
	if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
	if (timer_interval) timer_interval = clearInterval(timer_interval);
} else {
	if (!timer_interval) clockLast = clock.now(), timer_interval = setInterval(poke, pokeDelay);
	timer_frame = 1, setFrame(wake);
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-timer/src/timeout.js

/* harmony default export */ var src_timeout = (function(callback, delay, time) {
var t = new Timer;
delay = delay == null ? 0 : +delay;
t.restart(function(elapsed) {
	t.stop();
	callback(elapsed + delay);
}, delay, time);
return t;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-timer/src/interval.js

/* harmony default export */ var src_interval = (function(callback, delay, time) {
var t = new Timer, total = delay;
if (delay == null) return t.restart(callback, delay, time), t;
delay = +delay, time = time == null ? now() : +time;
t.restart(function tick(elapsed) {
	elapsed += total;
	t.restart(tick, total += delay, time);
	callback(elapsed);
}, delay, time);
return t;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-timer/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/schedule.js

var emptyOn = src_dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ var transition_schedule = (function(node, name, id, index, group, timing) {
var schedules = node.__transition;
if (!schedules) node.__transition = {};
else if (id in schedules) return;
schedule_create(node, id, {
	name: name,
	index: index, // For context during callback.
	group: group, // For context during callback.
	on: emptyOn,
	tween: emptyTween,
	time: timing.time,
	delay: timing.delay,
	duration: timing.duration,
	ease: timing.ease,
	timer: null,
	state: CREATED
});
});

function schedule_init(node, id) {
var schedule = schedule_get(node, id);
if (schedule.state > CREATED) throw new Error("too late; already scheduled");
return schedule;
}

function schedule_set(node, id) {
var schedule = schedule_get(node, id);
if (schedule.state > STARTING) throw new Error("too late; already started");
return schedule;
}

function schedule_get(node, id) {
var schedule = node.__transition;
if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
return schedule;
}

function schedule_create(node, id, self) {
var schedules = node.__transition,
	  tween;

// Initialize the self timer when the transition is created.
// Note the actual delay is not known until the first callback!
schedules[id] = self;
self.timer = timer(schedule, 0, self.time);

function schedule(elapsed) {
	self.state = SCHEDULED;
	self.timer.restart(start, self.delay, self.time);

	// If the elapsed delay is less than our first sleep, start immediately.
	if (self.delay <= elapsed) start(elapsed - self.delay);
}

function start(elapsed) {
	var i;
	var j;
	var n;
	var o;

	// If the state is not SCHEDULED, then we previously errored on start.
	if (self.state !== SCHEDULED) return stop();

	for (i in schedules) {
	  o = schedules[i];
	  if (o.name !== self.name) continue;

	  // While this element already has a starting transition during this frame,
	  // defer starting an interrupting transition until that transition has a
	  // chance to tick (and possibly end); see d3/d3-transition#54!
	  if (o.state === STARTED) return src_timeout(start);

	  // Interrupt the active transition, if any.
	  // Dispatch the interrupt event.
	  if (o.state === RUNNING) {
		o.state = ENDED;
		o.timer.stop();
		o.on.call("interrupt", node, node.__data__, o.index, o.group);
		delete schedules[i];
	  }

	  // Cancel any pre-empted transitions. No interrupt event is dispatched
	  // because the cancelled transitions never started. Note that this also
	  // removes this transition from the pending list!
	  else if (+i < id) {
		o.state = ENDED;
		o.timer.stop();
		delete schedules[i];
	  }
	}

	// Defer the first tick to end of the current frame; see d3/d3#1576.
	// Note the transition may be canceled after start and before the first tick!
	// Note this must be scheduled before the start event; see d3/d3-transition#16!
	// Assuming this is successful, subsequent callbacks go straight to tick.
	src_timeout(function() {
	  if (self.state === STARTED) {
		self.state = RUNNING;
		self.timer.restart(tick, self.delay, self.time);
		tick(elapsed);
	  }
	});

	// Dispatch the start event.
	// Note this must be done before the tween are initialized.
	self.state = STARTING;
	self.on.call("start", node, node.__data__, self.index, self.group);
	if (self.state !== STARTING) return; // interrupted
	self.state = STARTED;

	// Initialize the tween, deleting null tween.
	tween = new Array(n = self.tween.length);
	for (i = 0, j = -1; i < n; ++i) {
	  if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
		tween[++j] = o;
	  }
	}
	tween.length = j + 1;
}

function tick(elapsed) {
	var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
		i = -1,
		n = tween.length;

	while (++i < n) {
	  tween[i].call(null, t);
	}

	// Dispatch the end event.
	if (self.state === ENDING) {
	  self.on.call("end", node, node.__data__, self.index, self.group);
	  stop();
	}
}

function stop() {
	self.state = ENDED;
	self.timer.stop();
	delete schedules[id];
	for (var i in schedules) return; // eslint-disable-line no-unused-vars
	delete node.__transition;
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/interrupt.js

/* harmony default export */ var interrupt = (function(node, name) {
var schedules = node.__transition,
	  schedule,
	  active,
	  empty = true,
	  i;

if (!schedules) return;

name = name == null ? null : name + "";

for (i in schedules) {
	if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
	active = schedule.state > STARTING && schedule.state < ENDING;
	schedule.state = ENDED;
	schedule.timer.stop();
	if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
	delete schedules[i];
}

if (empty) delete node.__transition;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/selection/interrupt.js

/* harmony default export */ var selection_interrupt = (function(name) {
return this.each(function() {
	interrupt(this, name);
});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/tween.js

function tweenRemove(id, name) {
var tween0, tween1;
return function() {
	var schedule = schedule_set(this, id),
		tween = schedule.tween;

	// If this node shared tween with the previous node,
	// just assign the updated shared tween and we’re done!
	// Otherwise, copy-on-write.
	if (tween !== tween0) {
	  tween1 = tween0 = tween;
	  for (var i = 0, n = tween1.length; i < n; ++i) {
		if (tween1[i].name === name) {
		  tween1 = tween1.slice();
		  tween1.splice(i, 1);
		  break;
		}
	  }
	}

	schedule.tween = tween1;
};
}

function tweenFunction(id, name, value) {
var tween0, tween1;
if (typeof value !== "function") throw new Error;
return function() {
	var schedule = schedule_set(this, id),
		tween = schedule.tween;

	// If this node shared tween with the previous node,
	// just assign the updated shared tween and we’re done!
	// Otherwise, copy-on-write.
	if (tween !== tween0) {
	  tween1 = (tween0 = tween).slice();
	  for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
		if (tween1[i].name === name) {
		  tween1[i] = t;
		  break;
		}
	  }
	  if (i === n) tween1.push(t);
	}

	schedule.tween = tween1;
};
}

/* harmony default export */ var transition_tween = (function(name, value) {
var id = this._id;

name += "";

if (arguments.length < 2) {
	var tween = schedule_get(this.node(), id).tween;
	for (var i = 0, n = tween.length, t; i < n; ++i) {
	  if ((t = tween[i]).name === name) {
		return t.value;
	  }
	}
	return null;
}

return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
var id = transition._id;

transition.each(function() {
	var schedule = schedule_set(this, id);
	(schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
});

return function(node) {
	return schedule_get(node, id).value[name];
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/interpolate.js

/* harmony default export */ var transition_interpolate = (function(a, b) {
var c;
return (typeof b === "number" ? src_number
	  : b instanceof color_color ? src_rgb
	  : (c = color_color(b)) ? (b = c, src_rgb)
	  : src_string)(a, b);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/attr.js

function attr_attrRemove(name) {
return function() {
	this.removeAttribute(name);
};
}

function attr_attrRemoveNS(fullname) {
return function() {
	this.removeAttributeNS(fullname.space, fullname.local);
};
}

function attr_attrConstant(name, interpolate, value1) {
var value00,
	  interpolate0;
return function() {
	var value0 = this.getAttribute(name);
	return value0 === value1 ? null
		: value0 === value00 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value1);
};
}

function attr_attrConstantNS(fullname, interpolate, value1) {
var value00,
	  interpolate0;
return function() {
	var value0 = this.getAttributeNS(fullname.space, fullname.local);
	return value0 === value1 ? null
		: value0 === value00 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value1);
};
}

function attr_attrFunction(name, interpolate, value) {
var value00,
	  value10,
	  interpolate0;
return function() {
	var value0;
	var value1 = value(this);
	if (value1 == null) return void this.removeAttribute(name);
	value0 = this.getAttribute(name);
	return value0 === value1 ? null
		: value0 === value00 && value1 === value10 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value10 = value1);
};
}

function attr_attrFunctionNS(fullname, interpolate, value) {
var value00,
	  value10,
	  interpolate0;
return function() {
	var value0;
	var value1 = value(this);
	if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	value0 = this.getAttributeNS(fullname.space, fullname.local);
	return value0 === value1 ? null
		: value0 === value00 && value1 === value10 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value10 = value1);
};
}

/* harmony default export */ var transition_attr = (function(name, value) {
var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : transition_interpolate;
return this.attrTween(name, typeof value === "function"
	  ? (fullname.local ? attr_attrFunctionNS : attr_attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
	  : value == null ? (fullname.local ? attr_attrRemoveNS : attr_attrRemove)(fullname)
	  : (fullname.local ? attr_attrConstantNS : attr_attrConstant)(fullname, i, value + ""));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/attrTween.js

function attrTweenNS(fullname, value) {
function tween() {
	var node = this, i = value.apply(node, arguments);
	return i && function(t) {
	  node.setAttributeNS(fullname.space, fullname.local, i(t));
	};
}
tween._value = value;
return tween;
}

function attrTween(name, value) {
function tween() {
	var node = this, i = value.apply(node, arguments);
	return i && function(t) {
	  node.setAttribute(name, i(t));
	};
}
tween._value = value;
return tween;
}

/* harmony default export */ var transition_attrTween = (function(name, value) {
var key = "attr." + name;
if (arguments.length < 2) return (key = this.tween(key)) && key._value;
if (value == null) return this.tween(key, null);
if (typeof value !== "function") throw new Error;
var fullname = namespace(name);
return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/delay.js

function delayFunction(id, value) {
return function() {
	schedule_init(this, id).delay = +value.apply(this, arguments);
};
}

function delayConstant(id, value) {
return value = +value, function() {
	schedule_init(this, id).delay = value;
};
}

/* harmony default export */ var transition_delay = (function(value) {
var id = this._id;

return arguments.length
	  ? this.each((typeof value === "function"
		  ? delayFunction
		  : delayConstant)(id, value))
	  : schedule_get(this.node(), id).delay;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/duration.js

function durationFunction(id, value) {
return function() {
	schedule_set(this, id).duration = +value.apply(this, arguments);
};
}

function durationConstant(id, value) {
return value = +value, function() {
	schedule_set(this, id).duration = value;
};
}

/* harmony default export */ var transition_duration = (function(value) {
var id = this._id;

return arguments.length
	  ? this.each((typeof value === "function"
		  ? durationFunction
		  : durationConstant)(id, value))
	  : schedule_get(this.node(), id).duration;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/ease.js

function easeConstant(id, value) {
if (typeof value !== "function") throw new Error;
return function() {
	schedule_set(this, id).ease = value;
};
}

/* harmony default export */ var ease = (function(value) {
var id = this._id;

return arguments.length
	  ? this.each(easeConstant(id, value))
	  : schedule_get(this.node(), id).ease;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/filter.js

/* harmony default export */ var transition_filter = (function(match) {
if (typeof match !== "function") match = src_matcher(match);

for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	  if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
		subgroup.push(node);
	  }
	}
}

return new Transition(subgroups, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/merge.js

/* harmony default export */ var transition_merge = (function(transition) {
if (transition._id !== this._id) throw new Error;

for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	  if (node = group0[i] || group1[i]) {
		merge[i] = node;
	  }
	}
}

for (; j < m0; ++j) {
	merges[j] = groups0[j];
}

return new Transition(merges, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/on.js

function on_start(name) {
return (name + "").trim().split(/^|\s+/).every(function(t) {
	var i = t.indexOf(".");
	if (i >= 0) t = t.slice(0, i);
	return !t || t === "start";
});
}

function onFunction(id, name, listener) {
var on0, on1, sit = on_start(name) ? schedule_init : schedule_set;
return function() {
	var schedule = sit(this, id),
		on = schedule.on;

	// If this node shared a dispatch with the previous node,
	// just assign the updated shared dispatch and we’re done!
	// Otherwise, copy-on-write.
	if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	schedule.on = on1;
};
}

/* harmony default export */ var transition_on = (function(name, listener) {
var id = this._id;

return arguments.length < 2
	  ? schedule_get(this.node(), id).on.on(name)
	  : this.each(onFunction(id, name, listener));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/remove.js
function removeFunction(id) {
return function() {
	var parent = this.parentNode;
	for (var i in this.__transition) if (+i !== id) return;
	if (parent) parent.removeChild(this);
};
}

/* harmony default export */ var transition_remove = (function() {
return this.on("end.remove", removeFunction(this._id));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/select.js

/* harmony default export */ var transition_select = (function(select) {
var name = this._name,
	  id = this._id;

if (typeof select !== "function") select = src_selector(select);

for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	  if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
		if ("__data__" in node) subnode.__data__ = node.__data__;
		subgroup[i] = subnode;
		transition_schedule(subgroup[i], name, id, i, subgroup, schedule_get(node, id));
	  }
	}
}

return new Transition(subgroups, this._parents, name, id);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/selectAll.js

/* harmony default export */ var transition_selectAll = (function(select) {
var name = this._name,
	  id = this._id;

if (typeof select !== "function") select = selectorAll(select);

for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	  if (node = group[i]) {
		for (var children = select.call(node, node.__data__, i, group), child, inherit = schedule_get(node, id), k = 0, l = children.length; k < l; ++k) {
		  if (child = children[k]) {
			transition_schedule(child, name, id, k, children, inherit);
		  }
		}
		subgroups.push(children);
		parents.push(node);
	  }
	}
}

return new Transition(subgroups, parents, name, id);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/selection.js

var selection_Selection = src_selection.prototype.constructor;

/* harmony default export */ var transition_selection = (function() {
return new selection_Selection(this._groups, this._parents);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/style.js

function style_styleRemove(name, interpolate) {
var value00,
	  value10,
	  interpolate0;
return function() {
	var value0 = styleValue(this, name),
		value1 = (this.style.removeProperty(name), styleValue(this, name));
	return value0 === value1 ? null
		: value0 === value00 && value1 === value10 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value10 = value1);
};
}

function styleRemoveEnd(name) {
return function() {
	this.style.removeProperty(name);
};
}

function style_styleConstant(name, interpolate, value1) {
var value00,
	  interpolate0;
return function() {
	var value0 = styleValue(this, name);
	return value0 === value1 ? null
		: value0 === value00 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value1);
};
}

function style_styleFunction(name, interpolate, value) {
var value00,
	  value10,
	  interpolate0;
return function() {
	var value0 = styleValue(this, name),
		value1 = value(this);
	if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
	return value0 === value1 ? null
		: value0 === value00 && value1 === value10 ? interpolate0
		: interpolate0 = interpolate(value00 = value0, value10 = value1);
};
}

/* harmony default export */ var transition_style = (function(name, value, priority) {
var i = (name += "") === "transform" ? interpolateTransformCss : transition_interpolate;
return value == null ? this
		  .styleTween(name, style_styleRemove(name, i))
		  .on("end.style." + name, styleRemoveEnd(name))
	  : this.styleTween(name, typeof value === "function"
		  ? style_styleFunction(name, i, tweenValue(this, "style." + name, value))
		  : style_styleConstant(name, i, value + ""), priority);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/styleTween.js
function styleTween(name, value, priority) {
function tween() {
	var node = this, i = value.apply(node, arguments);
	return i && function(t) {
	  node.style.setProperty(name, i(t), priority);
	};
}
tween._value = value;
return tween;
}

/* harmony default export */ var transition_styleTween = (function(name, value, priority) {
var key = "style." + (name += "");
if (arguments.length < 2) return (key = this.tween(key)) && key._value;
if (value == null) return this.tween(key, null);
if (typeof value !== "function") throw new Error;
return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/text.js

function text_textConstant(value) {
return function() {
	this.textContent = value;
};
}

function text_textFunction(value) {
return function() {
	var value1 = value(this);
	this.textContent = value1 == null ? "" : value1;
};
}

/* harmony default export */ var transition_text = (function(value) {
return this.tween("text", typeof value === "function"
	  ? text_textFunction(tweenValue(this, "text", value))
	  : text_textConstant(value == null ? "" : value + ""));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/transition.js

/* harmony default export */ var transition_transition = (function() {
var name = this._name,
	  id0 = this._id,
	  id1 = newId();

for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	  if (node = group[i]) {
		var inherit = schedule_get(node, id0);
		transition_schedule(node, name, id1, i, group, {
		  time: inherit.time + inherit.delay + inherit.duration,
		  delay: 0,
		  duration: inherit.duration,
		  ease: inherit.ease
		});
	  }
	}
}

return new Transition(groups, this._parents, name, id1);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/transition/index.js

var transition_id = 0;

function Transition(groups, parents, name, id) {
this._groups = groups;
this._parents = parents;
this._name = name;
this._id = id;
}

function src_transition_transition(name) {
return src_selection().transition(name);
}

function newId() {
return ++transition_id;
}

var selection_prototype = src_selection.prototype;

Transition.prototype = src_transition_transition.prototype = {
constructor: Transition,
select: transition_select,
selectAll: transition_selectAll,
filter: transition_filter,
merge: transition_merge,
selection: transition_selection,
transition: transition_transition,
call: selection_prototype.call,
nodes: selection_prototype.nodes,
node: selection_prototype.node,
size: selection_prototype.size,
empty: selection_prototype.empty,
each: selection_prototype.each,
on: transition_on,
attr: transition_attr,
attrTween: transition_attrTween,
style: transition_style,
styleTween: transition_styleTween,
text: transition_text,
remove: transition_remove,
tween: transition_tween,
delay: transition_delay,
duration: transition_duration,
ease: ease
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/linear.js
function linear_linear(t) {
return +t;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/quad.js
function quadIn(t) {
return t * t;
}

function quadOut(t) {
return t * (2 - t);
}

function quadInOut(t) {
return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
return t * t * t;
}

function cubicOut(t) {
return --t * t * t + 1;
}

function cubicInOut(t) {
return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/poly.js
var poly_exponent = 3;

var polyIn = (function custom(e) {
e = +e;

function polyIn(t) {
	return Math.pow(t, e);
}

polyIn.exponent = custom;

return polyIn;
})(poly_exponent);

var polyOut = (function custom(e) {
e = +e;

function polyOut(t) {
	return 1 - Math.pow(1 - t, e);
}

polyOut.exponent = custom;

return polyOut;
})(poly_exponent);

var polyInOut = (function custom(e) {
e = +e;

function polyInOut(t) {
	return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
}

polyInOut.exponent = custom;

return polyInOut;
})(poly_exponent);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/sin.js
var pi = Math.PI,
	halfPi = pi / 2;

function sinIn(t) {
return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
return Math.sin(t * halfPi);
}

function sinInOut(t) {
return (1 - Math.cos(pi * t)) / 2;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/exp.js
function expIn(t) {
return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/circle.js
function circleIn(t) {
return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/bounce.js
var bounce_b1 = 4 / 11,
	b2 = 6 / 11,
	b3 = 8 / 11,
	b4 = 3 / 4,
	b5 = 9 / 11,
	b6 = 10 / 11,
	b7 = 15 / 16,
	b8 = 21 / 22,
	b9 = 63 / 64,
	bounce_b0 = 1 / bounce_b1 / bounce_b1;

function bounceIn(t) {
return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
return (t = +t) < bounce_b1 ? bounce_b0 * t * t : t < b3 ? bounce_b0 * (t -= b2) * t + b4 : t < b6 ? bounce_b0 * (t -= b5) * t + b7 : bounce_b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/back.js
var overshoot = 1.70158;

var backIn = (function custom(s) {
s = +s;

function backIn(t) {
	return t * t * ((s + 1) * t - s);
}

backIn.overshoot = custom;

return backIn;
})(overshoot);

var backOut = (function custom(s) {
s = +s;

function backOut(t) {
	return --t * t * ((s + 1) * t + s) + 1;
}

backOut.overshoot = custom;

return backOut;
})(overshoot);

var backInOut = (function custom(s) {
s = +s;

function backInOut(t) {
	return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
}

backInOut.overshoot = custom;

return backInOut;
})(overshoot);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI,
	amplitude = 1,
	period = 0.3;

var elasticIn = (function custom(a, p) {
var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

function elasticIn(t) {
	return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
}

elasticIn.amplitude = function(a) { return custom(a, p * tau); };
elasticIn.period = function(p) { return custom(a, p); };

return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

function elasticOut(t) {
	return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
}

elasticOut.amplitude = function(a) { return custom(a, p * tau); };
elasticOut.period = function(p) { return custom(a, p); };

return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

function elasticInOut(t) {
	return ((t = t * 2 - 1) < 0
		? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
		: 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
}

elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
elasticInOut.period = function(p) { return custom(a, p); };

return elasticInOut;
})(amplitude, period);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-ease/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/selection/transition.js

var defaultTiming = {
time: null, // Set on use.
delay: 0,
duration: 250,
ease: cubicInOut
};

function transition_inherit(node, id) {
var timing;
while (!(timing = node.__transition) || !(timing = timing[id])) {
	if (!(node = node.parentNode)) {
	  return defaultTiming.time = now(), defaultTiming;
	}
}
return timing;
}

/* harmony default export */ var selection_transition = (function(name) {
var id,
	  timing;

if (name instanceof Transition) {
	id = name._id, name = name._name;
} else {
	id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
}

for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	  if (node = group[i]) {
		transition_schedule(node, name, id, i, group, timing || transition_inherit(node, id));
	  }
	}
}

return new Transition(groups, this._parents, name, id);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/selection/index.js

src_selection.prototype.interrupt = selection_interrupt;
src_selection.prototype.transition = selection_transition;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/src/active.js

var active_root = [null];

/* harmony default export */ var src_active = (function(node, name) {
var schedules = node.__transition,
	  schedule,
	  i;

if (schedules) {
	name = name == null ? null : name + "";
	for (i in schedules) {
	  if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
		return new Transition([[node]], active_root, name, +i);
	  }
	}
}

return null;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-transition/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-brush/src/constant.js
/* harmony default export */ var d3_brush_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-brush/src/event.js
/* harmony default export */ var src_event = (function(target, type, selection) {
this.target = target;
this.type = type;
this.selection = selection;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-brush/src/noevent.js

function noevent_nopropagation() {
on_event.stopImmediatePropagation();
}

/* harmony default export */ var src_noevent = (function() {
on_event.preventDefault();
on_event.stopImmediatePropagation();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-brush/src/brush.js

var MODE_DRAG = {name: "drag"},
	MODE_SPACE = {name: "space"},
	MODE_HANDLE = {name: "handle"},
	MODE_CENTER = {name: "center"};

var brush_X = {
name: "x",
handles: ["e", "w"].map(brush_type),
input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var brush_Y = {
name: "y",
handles: ["n", "s"].map(brush_type),
input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
name: "xy",
handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(brush_type),
input: function(xy) { return xy; },
output: function(xy) { return xy; }
};

var cursors = {
overlay: "crosshair",
selection: "move",
n: "ns-resize",
e: "ew-resize",
s: "ns-resize",
w: "ew-resize",
nw: "nwse-resize",
ne: "nesw-resize",
se: "nwse-resize",
sw: "nesw-resize"
};

var flipX = {
e: "w",
w: "e",
nw: "ne",
ne: "nw",
se: "sw",
sw: "se"
};

var flipY = {
n: "s",
s: "n",
nw: "sw",
ne: "se",
se: "ne",
sw: "nw"
};

var signsX = {
overlay: +1,
selection: +1,
n: null,
e: +1,
s: null,
w: -1,
nw: -1,
ne: +1,
se: +1,
sw: -1
};

var signsY = {
overlay: +1,
selection: +1,
n: -1,
e: null,
s: +1,
w: null,
nw: -1,
ne: -1,
se: +1,
sw: +1
};

function brush_type(t) {
return {type: t};
}

// Ignore right-click, since that should open the context menu.
function brush_defaultFilter() {
return !on_event.button;
}

function defaultExtent() {
var svg = this.ownerSVGElement || this;
return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function brush_local(node) {
while (!node.__brush) if (!(node = node.parentNode)) return;
return node.__brush;
}

function brush_empty(extent) {
return extent[0][0] === extent[1][0]
	  || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
var state = node.__brush;
return state ? state.dim.output(state.selection) : null;
}

function brushX() {
return brush_brush(brush_X);
}

function brushY() {
return brush_brush(brush_Y);
}

/* harmony default export */ var src_brush = (function() {
return brush_brush(XY);
});

function brush_brush(dim) {
var extent = defaultExtent,
	  filter = brush_defaultFilter,
	  listeners = src_dispatch(brush, "start", "brush", "end"),
	  handleSize = 6,
	  touchending;

function brush(group) {
	var overlay = group
		.property("__brush", initialize)
	  .selectAll(".overlay")
	  .data([brush_type("overlay")]);

	overlay.enter().append("rect")
		.attr("class", "overlay")
		.attr("pointer-events", "all")
		.attr("cursor", cursors.overlay)
	  .merge(overlay)
		.each(function() {
		  var extent = brush_local(this).extent;
		  src_select(this)
			  .attr("x", extent[0][0])
			  .attr("y", extent[0][1])
			  .attr("width", extent[1][0] - extent[0][0])
			  .attr("height", extent[1][1] - extent[0][1]);
		});

	group.selectAll(".selection")
	  .data([brush_type("selection")])
	  .enter().append("rect")
		.attr("class", "selection")
		.attr("cursor", cursors.selection)
		.attr("fill", "#777")
		.attr("fill-opacity", 0.3)
		.attr("stroke", "#fff")
		.attr("shape-rendering", "crispEdges");

	var handle = group.selectAll(".handle")
	  .data(dim.handles, function(d) { return d.type; });

	handle.exit().remove();

	handle.enter().append("rect")
		.attr("class", function(d) { return "handle handle--" + d.type; })
		.attr("cursor", function(d) { return cursors[d.type]; });

	group
		.each(redraw)
		.attr("fill", "none")
		.attr("pointer-events", "all")
		.style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
		.on("mousedown.brush touchstart.brush", started);
}

brush.move = function(group, selection) {
	if (group.selection) {
	  group
		  .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
		  .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
		  .tween("brush", function() {
			var that = this,
				state = that.__brush,
				emit = emitter(that, arguments),
				selection0 = state.selection,
				selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
				i = src_value(selection0, selection1);

			function tween(t) {
			  state.selection = t === 1 && brush_empty(selection1) ? null : i(t);
			  redraw.call(that);
			  emit.brush();
			}

			return selection0 && selection1 ? tween : tween(1);
		  });
	} else {
	  group
		  .each(function() {
			var that = this,
				args = arguments,
				state = that.__brush,
				selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
				emit = emitter(that, args).beforestart();

			interrupt(that);
			state.selection = selection1 == null || brush_empty(selection1) ? null : selection1;
			redraw.call(that);
			emit.start().brush().end();
		  });
	}
};

function redraw() {
	var group = src_select(this),
		selection = brush_local(this).selection;

	if (selection) {
	  group.selectAll(".selection")
		  .style("display", null)
		  .attr("x", selection[0][0])
		  .attr("y", selection[0][1])
		  .attr("width", selection[1][0] - selection[0][0])
		  .attr("height", selection[1][1] - selection[0][1]);

	  group.selectAll(".handle")
		  .style("display", null)
		  .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
		  .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
		  .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
		  .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
	}

	else {
	  group.selectAll(".selection,.handle")
		  .style("display", "none")
		  .attr("x", null)
		  .attr("y", null)
		  .attr("width", null)
		  .attr("height", null);
	}
}

function emitter(that, args) {
	return that.__brush.emitter || new Emitter(that, args);
}

function Emitter(that, args) {
	this.that = that;
	this.args = args;
	this.state = that.__brush;
	this.active = 0;
}

Emitter.prototype = {
	beforestart: function() {
	  if (++this.active === 1) this.state.emitter = this, this.starting = true;
	  return this;
	},
	start: function() {
	  if (this.starting) this.starting = false, this.emit("start");
	  return this;
	},
	brush: function() {
	  this.emit("brush");
	  return this;
	},
	end: function() {
	  if (--this.active === 0) delete this.state.emitter, this.emit("end");
	  return this;
	},
	emit: function(type) {
	  customEvent(new src_event(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
	}
};

function started() {
	if (on_event.touches) { if (on_event.changedTouches.length < on_event.touches.length) return src_noevent(); }
	else if (touchending) return;
	if (!filter.apply(this, arguments)) return;

	var that = this,
		type = on_event.target.__data__.type,
		mode = (on_event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (on_event.altKey ? MODE_CENTER : MODE_HANDLE),
		signX = dim === brush_Y ? null : signsX[type],
		signY = dim === brush_X ? null : signsY[type],
		state = brush_local(that),
		extent = state.extent,
		selection = state.selection,
		W = extent[0][0], w0, w1,
		N = extent[0][1], n0, n1,
		E = extent[1][0], e0, e1,
		S = extent[1][1], s0, s1,
		dx,
		dy,
		moving,
		shifting = signX && signY && on_event.shiftKey,
		lockX,
		lockY,
		point0 = mouse(that),
		point = point0,
		emit = emitter(that, arguments).beforestart();

	if (type === "overlay") {
	  state.selection = selection = [
		[w0 = dim === brush_Y ? W : point0[0], n0 = dim === brush_X ? N : point0[1]],
		[e0 = dim === brush_Y ? E : w0, s0 = dim === brush_X ? S : n0]
	  ];
	} else {
	  w0 = selection[0][0];
	  n0 = selection[0][1];
	  e0 = selection[1][0];
	  s0 = selection[1][1];
	}

	w1 = w0;
	n1 = n0;
	e1 = e0;
	s1 = s0;

	var group = src_select(that)
		.attr("pointer-events", "none");

	var overlay = group.selectAll(".overlay")
		.attr("cursor", cursors[type]);

	if (on_event.touches) {
	  group
		  .on("touchmove.brush", moved, true)
		  .on("touchend.brush touchcancel.brush", ended, true);
	} else {
	  var view = src_select(on_event.view)
		  .on("keydown.brush", keydowned, true)
		  .on("keyup.brush", keyupped, true)
		  .on("mousemove.brush", moved, true)
		  .on("mouseup.brush", ended, true);

	  nodrag(on_event.view);
	}

	noevent_nopropagation();
	interrupt(that);
	redraw.call(that);
	emit.start();

	function moved() {
	  var point1 = mouse(that);
	  if (shifting && !lockX && !lockY) {
		if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
		else lockX = true;
	  }
	  point = point1;
	  moving = true;
	  src_noevent();
	  move();
	}

	function move() {
	  var t;

	  dx = point[0] - point0[0];
	  dy = point[1] - point0[1];

	  switch (mode) {
		case MODE_SPACE:
		case MODE_DRAG: {
		  if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
		  if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
		  break;
		}
		case MODE_HANDLE: {
		  if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
		  else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
		  if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
		  else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
		  break;
		}
		case MODE_CENTER: {
		  if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
		  if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
		  break;
		}
	  }

	  if (e1 < w1) {
		signX *= -1;
		t = w0, w0 = e0, e0 = t;
		t = w1, w1 = e1, e1 = t;
		if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
	  }

	  if (s1 < n1) {
		signY *= -1;
		t = n0, n0 = s0, s0 = t;
		t = n1, n1 = s1, s1 = t;
		if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
	  }

	  if (state.selection) selection = state.selection; // May be set by brush.move!
	  if (lockX) w1 = selection[0][0], e1 = selection[1][0];
	  if (lockY) n1 = selection[0][1], s1 = selection[1][1];

	  if (selection[0][0] !== w1
		  || selection[0][1] !== n1
		  || selection[1][0] !== e1
		  || selection[1][1] !== s1) {
		state.selection = [[w1, n1], [e1, s1]];
		redraw.call(that);
		emit.brush();
	  }
	}

	function ended() {
	  noevent_nopropagation();
	  if (on_event.touches) {
		if (on_event.touches.length) return;
		if (touchending) clearTimeout(touchending);
		touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
		group.on("touchmove.brush touchend.brush touchcancel.brush", null);
	  } else {
		yesdrag(on_event.view, moving);
		view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
	  }
	  group.attr("pointer-events", "all");
	  overlay.attr("cursor", cursors.overlay);
	  if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
	  if (brush_empty(selection)) state.selection = null, redraw.call(that);
	  emit.end();
	}

	function keydowned() {
	  switch (on_event.keyCode) {
		case 16: { // SHIFT
		  shifting = signX && signY;
		  break;
		}
		case 18: { // ALT
		  if (mode === MODE_HANDLE) {
			if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
			if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
			mode = MODE_CENTER;
			move();
		  }
		  break;
		}
		case 32: { // SPACE; takes priority over ALT
		  if (mode === MODE_HANDLE || mode === MODE_CENTER) {
			if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
			if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
			mode = MODE_SPACE;
			overlay.attr("cursor", cursors.selection);
			move();
		  }
		  break;
		}
		default: return;
	  }
	  src_noevent();
	}

	function keyupped() {
	  switch (on_event.keyCode) {
		case 16: { // SHIFT
		  if (shifting) {
			lockX = lockY = shifting = false;
			move();
		  }
		  break;
		}
		case 18: { // ALT
		  if (mode === MODE_CENTER) {
			if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
			if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
			mode = MODE_HANDLE;
			move();
		  }
		  break;
		}
		case 32: { // SPACE
		  if (mode === MODE_SPACE) {
			if (on_event.altKey) {
			  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
			  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
			  mode = MODE_CENTER;
			} else {
			  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
			  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
			  mode = MODE_HANDLE;
			}
			overlay.attr("cursor", cursors[type]);
			move();
		  }
		  break;
		}
		default: return;
	  }
	  src_noevent();
	}
}

function initialize() {
	var state = this.__brush || {selection: null};
	state.extent = extent.apply(this, arguments);
	state.dim = dim;
	return state;
}

brush.extent = function(_) {
	return arguments.length ? (extent = typeof _ === "function" ? _ : d3_brush_src_constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
};

brush.filter = function(_) {
	return arguments.length ? (filter = typeof _ === "function" ? _ : d3_brush_src_constant(!!_), brush) : filter;
};

brush.handleSize = function(_) {
	return arguments.length ? (handleSize = +_, brush) : handleSize;
};

brush.on = function() {
	var value = listeners.on.apply(listeners, arguments);
	return value === listeners ? brush : value;
};

return brush;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-brush/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-chord/src/math.js
var cos = Math.cos;
var sin = Math.sin;
var math_pi = Math.PI;
var math_halfPi = math_pi / 2;
var math_tau = math_pi * 2;
var math_max = Math.max;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-chord/src/chord.js

function compareValue(compare) {
return function(a, b) {
	return compare(
	  a.source.value + a.target.value,
	  b.source.value + b.target.value
	);
};
}

/* harmony default export */ var src_chord = (function() {
var padAngle = 0,
	  sortGroups = null,
	  sortSubgroups = null,
	  sortChords = null;

function chord(matrix) {
	var n = matrix.length,
		groupSums = [],
		groupIndex = src_range(n),
		subgroupIndex = [],
		chords = [],
		groups = chords.groups = new Array(n),
		subgroups = new Array(n * n),
		k,
		x,
		x0,
		dx,
		i,
		j;

	// Compute the sum.
	k = 0, i = -1; while (++i < n) {
	  x = 0, j = -1; while (++j < n) {
		x += matrix[i][j];
	  }
	  groupSums.push(x);
	  subgroupIndex.push(src_range(n));
	  k += x;
	}

	// Sort groups…
	if (sortGroups) groupIndex.sort(function(a, b) {
	  return sortGroups(groupSums[a], groupSums[b]);
	});

	// Sort subgroups…
	if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
	  d.sort(function(a, b) {
		return sortSubgroups(matrix[i][a], matrix[i][b]);
	  });
	});

	// Convert the sum to scaling factor for [0, 2pi].
	// TODO Allow start and end angle to be specified?
	// TODO Allow padding to be specified as percentage?
	k = math_max(0, math_tau - padAngle * n) / k;
	dx = k ? padAngle : math_tau / n;

	// Compute the start and end angle for each group and subgroup.
	// Note: Opera has a bug reordering object literal properties!
	x = 0, i = -1; while (++i < n) {
	  x0 = x, j = -1; while (++j < n) {
		var di = groupIndex[i],
			dj = subgroupIndex[di][j],
			v = matrix[di][dj],
			a0 = x,
			a1 = x += v * k;
		subgroups[dj * n + di] = {
		  index: di,
		  subindex: dj,
		  startAngle: a0,
		  endAngle: a1,
		  value: v
		};
	  }
	  groups[di] = {
		index: di,
		startAngle: x0,
		endAngle: x,
		value: groupSums[di]
	  };
	  x += dx;
	}

	// Generate chords for each (non-empty) subgroup-subgroup link.
	i = -1; while (++i < n) {
	  j = i - 1; while (++j < n) {
		var source = subgroups[j * n + i],
			target = subgroups[i * n + j];
		if (source.value || target.value) {
		  chords.push(source.value < target.value
			  ? {source: target, target: source}
			  : {source: source, target: target});
		}
	  }
	}

	return sortChords ? chords.sort(sortChords) : chords;
}

chord.padAngle = function(_) {
	return arguments.length ? (padAngle = math_max(0, _), chord) : padAngle;
};

chord.sortGroups = function(_) {
	return arguments.length ? (sortGroups = _, chord) : sortGroups;
};

chord.sortSubgroups = function(_) {
	return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
};

chord.sortChords = function(_) {
	return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
};

return chord;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-chord/src/array.js
var src_array_slice = Array.prototype.slice;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-chord/src/constant.js
/* harmony default export */ var d3_chord_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-path/src/path.js
var path_pi = Math.PI,
	path_tau = 2 * path_pi,
	path_epsilon = 1e-6,
	tauEpsilon = path_tau - path_epsilon;

function Path() {
this._x0 = this._y0 = // start of current subpath
this._x1 = this._y1 = null; // end of current subpath
this._ = "";
}

function path_path() {
return new Path;
}

Path.prototype = path_path.prototype = {
constructor: Path,
moveTo: function(x, y) {
	this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
},
closePath: function() {
	if (this._x1 !== null) {
	  this._x1 = this._x0, this._y1 = this._y0;
	  this._ += "Z";
	}
},
lineTo: function(x, y) {
	this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
},
quadraticCurveTo: function(x1, y1, x, y) {
	this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
},
bezierCurveTo: function(x1, y1, x2, y2, x, y) {
	this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
},
arcTo: function(x1, y1, x2, y2, r) {
	x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
	var x0 = this._x1,
		y0 = this._y1,
		x21 = x2 - x1,
		y21 = y2 - y1,
		x01 = x0 - x1,
		y01 = y0 - y1,
		l01_2 = x01 * x01 + y01 * y01;

	// Is the radius negative? Error.
	if (r < 0) throw new Error("negative radius: " + r);

	// Is this path empty? Move to (x1,y1).
	if (this._x1 === null) {
	  this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
	}

	// Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
	else if (!(l01_2 > path_epsilon)) {}

	// Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
	// Equivalently, is (x1,y1) coincident with (x2,y2)?
	// Or, is the radius zero? Line to (x1,y1).
	else if (!(Math.abs(y01 * x21 - y21 * x01) > path_epsilon) || !r) {
	  this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
	}

	// Otherwise, draw an arc!
	else {
	  var x20 = x2 - x0,
		  y20 = y2 - y0,
		  l21_2 = x21 * x21 + y21 * y21,
		  l20_2 = x20 * x20 + y20 * y20,
		  l21 = Math.sqrt(l21_2),
		  l01 = Math.sqrt(l01_2),
		  l = r * Math.tan((path_pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
		  t01 = l / l01,
		  t21 = l / l21;

	  // If the start tangent is not coincident with (x0,y0), line to.
	  if (Math.abs(t01 - 1) > path_epsilon) {
		this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
	  }

	  this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
	}
},
arc: function(x, y, r, a0, a1, ccw) {
	x = +x, y = +y, r = +r;
	var dx = r * Math.cos(a0),
		dy = r * Math.sin(a0),
		x0 = x + dx,
		y0 = y + dy,
		cw = 1 ^ ccw,
		da = ccw ? a0 - a1 : a1 - a0;

	// Is the radius negative? Error.
	if (r < 0) throw new Error("negative radius: " + r);

	// Is this path empty? Move to (x0,y0).
	if (this._x1 === null) {
	  this._ += "M" + x0 + "," + y0;
	}

	// Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
	else if (Math.abs(this._x1 - x0) > path_epsilon || Math.abs(this._y1 - y0) > path_epsilon) {
	  this._ += "L" + x0 + "," + y0;
	}

	// Is this arc empty? We’re done.
	if (!r) return;

	// Does the angle go the wrong way? Flip the direction.
	if (da < 0) da = da % path_tau + path_tau;

	// Is this a complete circle? Draw two arcs to complete the circle.
	if (da > tauEpsilon) {
	  this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
	}

	// Is this arc non-empty? Draw an arc!
	else if (da > path_epsilon) {
	  this._ += "A" + r + "," + r + ",0," + (+(da >= path_pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
	}
},
rect: function(x, y, w, h) {
	this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
},
toString: function() {
	return this._;
}
};

/* harmony default export */ var src_path = (path_path);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-path/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-chord/src/ribbon.js

function defaultSource(d) {
return d.source;
}

function defaultTarget(d) {
return d.target;
}

function defaultRadius(d) {
return d.radius;
}

function defaultStartAngle(d) {
return d.startAngle;
}

function defaultEndAngle(d) {
return d.endAngle;
}

/* harmony default export */ var src_ribbon = (function() {
var source = defaultSource,
	  target = defaultTarget,
	  radius = defaultRadius,
	  startAngle = defaultStartAngle,
	  endAngle = defaultEndAngle,
	  context = null;

function ribbon() {
	var buffer,
		argv = src_array_slice.call(arguments),
		s = source.apply(this, argv),
		t = target.apply(this, argv),
		sr = +radius.apply(this, (argv[0] = s, argv)),
		sa0 = startAngle.apply(this, argv) - math_halfPi,
		sa1 = endAngle.apply(this, argv) - math_halfPi,
		sx0 = sr * cos(sa0),
		sy0 = sr * sin(sa0),
		tr = +radius.apply(this, (argv[0] = t, argv)),
		ta0 = startAngle.apply(this, argv) - math_halfPi,
		ta1 = endAngle.apply(this, argv) - math_halfPi;

	if (!context) context = buffer = src_path();

	context.moveTo(sx0, sy0);
	context.arc(0, 0, sr, sa0, sa1);
	if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
	  context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
	  context.arc(0, 0, tr, ta0, ta1);
	}
	context.quadraticCurveTo(0, 0, sx0, sy0);
	context.closePath();

	if (buffer) return context = null, buffer + "" || null;
}

ribbon.radius = function(_) {
	return arguments.length ? (radius = typeof _ === "function" ? _ : d3_chord_src_constant(+_), ribbon) : radius;
};

ribbon.startAngle = function(_) {
	return arguments.length ? (startAngle = typeof _ === "function" ? _ : d3_chord_src_constant(+_), ribbon) : startAngle;
};

ribbon.endAngle = function(_) {
	return arguments.length ? (endAngle = typeof _ === "function" ? _ : d3_chord_src_constant(+_), ribbon) : endAngle;
};

ribbon.source = function(_) {
	return arguments.length ? (source = _, ribbon) : source;
};

ribbon.target = function(_) {
	return arguments.length ? (target = _, ribbon) : target;
};

ribbon.context = function(_) {
	return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
};

return ribbon;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-chord/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/src/map.js
var map_prefix = "$";

function Map() {}

Map.prototype = map_map.prototype = {
constructor: Map,
has: function(key) {
	return (map_prefix + key) in this;
},
get: function(key) {
	return this[map_prefix + key];
},
set: function(key, value) {
	this[map_prefix + key] = value;
	return this;
},
remove: function(key) {
	var property = map_prefix + key;
	return property in this && delete this[property];
},
clear: function() {
	for (var property in this) if (property[0] === map_prefix) delete this[property];
},
keys: function() {
	var keys = [];
	for (var property in this) if (property[0] === map_prefix) keys.push(property.slice(1));
	return keys;
},
values: function() {
	var values = [];
	for (var property in this) if (property[0] === map_prefix) values.push(this[property]);
	return values;
},
entries: function() {
	var entries = [];
	for (var property in this) if (property[0] === map_prefix) entries.push({key: property.slice(1), value: this[property]});
	return entries;
},
size: function() {
	var size = 0;
	for (var property in this) if (property[0] === map_prefix) ++size;
	return size;
},
empty: function() {
	for (var property in this) if (property[0] === map_prefix) return false;
	return true;
},
each: function(f) {
	for (var property in this) if (property[0] === map_prefix) f(this[property], property.slice(1), this);
}
};

function map_map(object, f) {
var map = new Map;

// Copy constructor.
if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

// Index array by numeric index or specified key function.
else if (Array.isArray(object)) {
	var i = -1,
		n = object.length,
		o;

	if (f == null) while (++i < n) map.set(i, object[i]);
	else while (++i < n) map.set(f(o = object[i], i, object), o);
}

// Convert object to map.
else if (object) for (var key in object) map.set(key, object[key]);

return map;
}

/* harmony default export */ var src_map = (map_map);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/src/nest.js

/* harmony default export */ var src_nest = (function() {
var keys = [],
	  sortKeys = [],
	  sortValues,
	  rollup,
	  nest;

function apply(array, depth, createResult, setResult) {
	if (depth >= keys.length) {
	  if (sortValues != null) array.sort(sortValues);
	  return rollup != null ? rollup(array) : array;
	}

	var i = -1,
		n = array.length,
		key = keys[depth++],
		keyValue,
		value,
		valuesByKey = src_map(),
		values,
		result = createResult();

	while (++i < n) {
	  if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
		values.push(value);
	  } else {
		valuesByKey.set(keyValue, [value]);
	  }
	}

	valuesByKey.each(function(values, key) {
	  setResult(result, key, apply(values, depth, createResult, setResult));
	});

	return result;
}

function entries(map, depth) {
	if (++depth > keys.length) return map;
	var array;
	var sortKey = sortKeys[depth - 1];
	if (rollup != null && depth >= keys.length) array = map.entries();
	else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
	return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
}

return nest = {
	object: function(array) { return apply(array, 0, createObject, setObject); },
	map: function(array) { return apply(array, 0, createMap, setMap); },
	entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
	key: function(d) { keys.push(d); return nest; },
	sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
	sortValues: function(order) { sortValues = order; return nest; },
	rollup: function(f) { rollup = f; return nest; }
};
});

function createObject() {
return {};
}

function setObject(object, key, value) {
object[key] = value;
}

function createMap() {
return src_map();
}

function setMap(map, key, value) {
map.set(key, value);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/src/set.js

function Set() {}

var proto = src_map.prototype;

Set.prototype = set_set.prototype = {
constructor: Set,
has: proto.has,
add: function(value) {
	value += "";
	this[map_prefix + value] = value;
	return this;
},
remove: proto.remove,
clear: proto.clear,
values: proto.keys,
size: proto.size,
empty: proto.empty,
each: proto.each
};

function set_set(object, f) {
var set = new Set;

// Copy constructor.
if (object instanceof Set) object.each(function(value) { set.add(value); });

// Otherwise, assume it’s an array.
else if (object) {
	var i = -1, n = object.length;
	if (f == null) while (++i < n) set.add(object[i]);
	else while (++i < n) set.add(f(object[i], i, object));
}

return set;
}

/* harmony default export */ var src_set = (set_set);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/src/keys.js
/* harmony default export */ var src_keys = (function(map) {
var keys = [];
for (var key in map) keys.push(key);
return keys;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/src/values.js
/* harmony default export */ var src_values = (function(map) {
var values = [];
for (var key in map) values.push(map[key]);
return values;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/src/entries.js
/* harmony default export */ var src_entries = (function(map) {
var entries = [];
for (var key in map) entries.push({key: key, value: map[key]});
return entries;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-collection/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/array.js
var src_array_array = Array.prototype;

var d3_contour_src_array_slice = src_array_array.slice;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/ascending.js
/* harmony default export */ var src_ascending = (function(a, b) {
return a - b;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/area.js
/* harmony default export */ var src_area = (function(ring) {
var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
return area;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/constant.js
/* harmony default export */ var d3_contour_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/contains.js
/* harmony default export */ var contains = (function(ring, hole) {
var i = -1, n = hole.length, c;
while (++i < n) if (c = ringContains(ring, hole[i])) return c;
return 0;
});

function ringContains(ring, point) {
var x = point[0], y = point[1], contains = -1;
for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
	var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
	if (segmentContains(pi, pj, point)) return 0;
	if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
}
return contains;
}

function segmentContains(a, b, c) {
var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
return p <= q && q <= r || r <= q && q <= p;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/noop.js
/* harmony default export */ var src_noop = (function() {});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/contours.js

var cases = [
[],
[[[1.0, 1.5], [0.5, 1.0]]],
[[[1.5, 1.0], [1.0, 1.5]]],
[[[1.5, 1.0], [0.5, 1.0]]],
[[[1.0, 0.5], [1.5, 1.0]]],
[[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
[[[1.0, 0.5], [1.0, 1.5]]],
[[[1.0, 0.5], [0.5, 1.0]]],
[[[0.5, 1.0], [1.0, 0.5]]],
[[[1.0, 1.5], [1.0, 0.5]]],
[[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
[[[1.5, 1.0], [1.0, 0.5]]],
[[[0.5, 1.0], [1.5, 1.0]]],
[[[1.0, 1.5], [1.5, 1.0]]],
[[[0.5, 1.0], [1.0, 1.5]]],
[]
];

/* harmony default export */ var src_contours = (function() {
var dx = 1,
	  dy = 1,
	  threshold = sturges,
	  smooth = smoothLinear;

function contours(values) {
	var tz = threshold(values);

	// Convert number of thresholds into uniform thresholds.
	if (!Array.isArray(tz)) {
	  var domain = src_extent(values), start = domain[0], stop = domain[1];
	  tz = tickStep(start, stop, tz);
	  tz = src_range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
	} else {
	  tz = tz.slice().sort(src_ascending);
	}

	return tz.map(function(value) {
	  return contour(values, value);
	});
}

// Accumulate, smooth contour rings, assign holes to exterior rings.
// Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
function contour(values, value) {
	var polygons = [],
		holes = [];

	isorings(values, value, function(ring) {
	  smooth(ring, values, value);
	  if (src_area(ring) > 0) polygons.push([ring]);
	  else holes.push(ring);
	});

	holes.forEach(function(hole) {
	  for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
		if (contains((polygon = polygons[i])[0], hole) !== -1) {
		  polygon.push(hole);
		  return;
		}
	  }
	});

	return {
	  type: "MultiPolygon",
	  value: value,
	  coordinates: polygons
	};
}

// Marching squares with isolines stitched into rings.
// Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
function isorings(values, value, callback) {
	var fragmentByStart = new Array,
		fragmentByEnd = new Array,
		x, y, t0, t1, t2, t3;

	// Special case for the first row (y = -1, t2 = t3 = 0).
	x = y = -1;
	t1 = values[0] >= value;
	cases[t1 << 1].forEach(stitch);
	while (++x < dx - 1) {
	  t0 = t1, t1 = values[x + 1] >= value;
	  cases[t0 | t1 << 1].forEach(stitch);
	}
	cases[t1 << 0].forEach(stitch);

	// General case for the intermediate rows.
	while (++y < dy - 1) {
	  x = -1;
	  t1 = values[y * dx + dx] >= value;
	  t2 = values[y * dx] >= value;
	  cases[t1 << 1 | t2 << 2].forEach(stitch);
	  while (++x < dx - 1) {
		t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
		t3 = t2, t2 = values[y * dx + x + 1] >= value;
		cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
	  }
	  cases[t1 | t2 << 3].forEach(stitch);
	}

	// Special case for the last row (y = dy - 1, t0 = t1 = 0).
	x = -1;
	t2 = values[y * dx] >= value;
	cases[t2 << 2].forEach(stitch);
	while (++x < dx - 1) {
	  t3 = t2, t2 = values[y * dx + x + 1] >= value;
	  cases[t2 << 2 | t3 << 3].forEach(stitch);
	}
	cases[t2 << 3].forEach(stitch);

	function stitch(line) {
	  var start = [line[0][0] + x, line[0][1] + y],
		  end = [line[1][0] + x, line[1][1] + y],
		  startIndex = index(start),
		  endIndex = index(end),
		  f, g;
	  if (f = fragmentByEnd[startIndex]) {
		if (g = fragmentByStart[endIndex]) {
		  delete fragmentByEnd[f.end];
		  delete fragmentByStart[g.start];
		  if (f === g) {
			f.ring.push(end);
			callback(f.ring);
		  } else {
			fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
		  }
		} else {
		  delete fragmentByEnd[f.end];
		  f.ring.push(end);
		  fragmentByEnd[f.end = endIndex] = f;
		}
	  } else if (f = fragmentByStart[endIndex]) {
		if (g = fragmentByEnd[startIndex]) {
		  delete fragmentByStart[f.start];
		  delete fragmentByEnd[g.end];
		  if (f === g) {
			f.ring.push(end);
			callback(f.ring);
		  } else {
			fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
		  }
		} else {
		  delete fragmentByStart[f.start];
		  f.ring.unshift(start);
		  fragmentByStart[f.start = startIndex] = f;
		}
	  } else {
		fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
	  }
	}
}

function index(point) {
	return point[0] * 2 + point[1] * (dx + 1) * 4;
}

function smoothLinear(ring, values, value) {
	ring.forEach(function(point) {
	  var x = point[0],
		  y = point[1],
		  xt = x | 0,
		  yt = y | 0,
		  v0,
		  v1 = values[yt * dx + xt];
	  if (x > 0 && x < dx && xt === x) {
		v0 = values[yt * dx + xt - 1];
		point[0] = x + (value - v0) / (v1 - v0) - 0.5;
	  }
	  if (y > 0 && y < dy && yt === y) {
		v0 = values[(yt - 1) * dx + xt];
		point[1] = y + (value - v0) / (v1 - v0) - 0.5;
	  }
	});
}

contours.contour = contour;

contours.size = function(_) {
	if (!arguments.length) return [dx, dy];
	var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
	return dx = _0, dy = _1, contours;
};

contours.thresholds = function(_) {
	return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? d3_contour_src_constant(d3_contour_src_array_slice.call(_)) : d3_contour_src_constant(_), contours) : threshold;
};

contours.smooth = function(_) {
	return arguments.length ? (smooth = _ ? smoothLinear : src_noop, contours) : smooth === smoothLinear;
};

return contours;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/blur.js
// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
var n = source.width,
	  m = source.height,
	  w = (r << 1) + 1;
for (var j = 0; j < m; ++j) {
	for (var i = 0, sr = 0; i < n + r; ++i) {
	  if (i < n) {
		sr += source.data[i + j * n];
	  }
	  if (i >= r) {
		if (i >= w) {
		  sr -= source.data[i - w + j * n];
		}
		target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
	  }
	}
}
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
var n = source.width,
	  m = source.height,
	  w = (r << 1) + 1;
for (var i = 0; i < n; ++i) {
	for (var j = 0, sr = 0; j < m + r; ++j) {
	  if (j < m) {
		sr += source.data[i + j * n];
	  }
	  if (j >= r) {
		if (j >= w) {
		  sr -= source.data[i + (j - w) * n];
		}
		target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
	  }
	}
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/src/density.js

function defaultX(d) {
return d[0];
}

function defaultY(d) {
return d[1];
}

/* harmony default export */ var src_density = (function() {
var x = defaultX,
	  y = defaultY,
	  dx = 960,
	  dy = 500,
	  r = 20, // blur radius
	  k = 2, // log2(grid cell size)
	  o = r * 3, // grid offset, to pad for blur
	  n = (dx + o * 2) >> k, // grid width
	  m = (dy + o * 2) >> k, // grid height
	  threshold = d3_contour_src_constant(20);

function density(data) {
	var values0 = new Float32Array(n * m),
		values1 = new Float32Array(n * m);

	data.forEach(function(d, i, data) {
	  var xi = (x(d, i, data) + o) >> k,
		  yi = (y(d, i, data) + o) >> k;
	  if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
		++values0[xi + yi * n];
	  }
	});

	// TODO Optimize.
	blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

	var tz = threshold(values0);

	// Convert number of thresholds into uniform thresholds.
	if (!Array.isArray(tz)) {
	  var stop = src_max(values0);
	  tz = tickStep(0, stop, tz);
	  tz = src_range(0, Math.floor(stop / tz) * tz, tz);
	  tz.shift();
	}

	return src_contours()
		.thresholds(tz)
		.size([n, m])
	  (values0)
		.map(transform);
}

function transform(geometry) {
	geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
	geometry.coordinates.forEach(transformPolygon);
	return geometry;
}

function transformPolygon(coordinates) {
	coordinates.forEach(transformRing);
}

function transformRing(coordinates) {
	coordinates.forEach(transformPoint);
}

// TODO Optimize.
function transformPoint(coordinates) {
	coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
	coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
}

function resize() {
	o = r * 3;
	n = (dx + o * 2) >> k;
	m = (dy + o * 2) >> k;
	return density;
}

density.x = function(_) {
	return arguments.length ? (x = typeof _ === "function" ? _ : d3_contour_src_constant(+_), density) : x;
};

density.y = function(_) {
	return arguments.length ? (y = typeof _ === "function" ? _ : d3_contour_src_constant(+_), density) : y;
};

density.size = function(_) {
	if (!arguments.length) return [dx, dy];
	var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
	return dx = _0, dy = _1, resize();
};

density.cellSize = function(_) {
	if (!arguments.length) return 1 << k;
	if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
	return k = Math.floor(Math.log(_) / Math.LN2), resize();
};

density.thresholds = function(_) {
	return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? d3_contour_src_constant(d3_contour_src_array_slice.call(_)) : d3_contour_src_constant(_), density) : threshold;
};

density.bandwidth = function(_) {
	if (!arguments.length) return Math.sqrt(r * (r + 1));
	if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
	return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
};

return density;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-contour/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-dsv/src/dsv.js
var EOL = {},
	EOF = {},
	QUOTE = 34,
	NEWLINE = 10,
	RETURN = 13;

function objectConverter(columns) {
return new Function("d", "return {" + columns.map(function(name, i) {
	return JSON.stringify(name) + ": d[" + i + "]";
}).join(",") + "}");
}

function customConverter(columns, f) {
var object = objectConverter(columns);
return function(row, i) {
	return f(object(row), i, columns);
};
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
var columnSet = Object.create(null),
	  columns = [];

rows.forEach(function(row) {
	for (var column in row) {
	  if (!(column in columnSet)) {
		columns.push(columnSet[column] = column);
	  }
	}
});

return columns;
}

/* harmony default export */ var dsv = (function(delimiter) {
var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
	  DELIMITER = delimiter.charCodeAt(0);

function parse(text, f) {
	var convert;
	var columns;
	var rows = parseRows(text, function(row, i) {
	  if (convert) return convert(row, i - 1);
	  columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
	});
	rows.columns = columns || [];
	return rows;
}

function parseRows(text, f) {
	var rows = [], // output rows
		N = text.length,
		I = 0, // current character index
		n = 0, // current line number
		t, // current token
		eof = N <= 0, // current token followed by EOF?
		eol = false; // current token followed by EOL?

	// Strip the trailing newline.
	if (text.charCodeAt(N - 1) === NEWLINE) --N;
	if (text.charCodeAt(N - 1) === RETURN) --N;

	function token() {
	  if (eof) return EOF;
	  if (eol) return eol = false, EOL;

	  // Unescape quotes.
	  var i, j = I, c;
	  if (text.charCodeAt(j) === QUOTE) {
		while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
		if ((i = I) >= N) eof = true;
		else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
		else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
		return text.slice(j + 1, i - 1).replace(/""/g, "\"");
	  }

	  // Find next delimiter or newline.
	  while (I < N) {
		if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
		else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
		else if (c !== DELIMITER) continue;
		return text.slice(j, i);
	  }

	  // Return last token before EOF.
	  return eof = true, text.slice(j, N);
	}

	while ((t = token()) !== EOF) {
	  var row = [];
	  while (t !== EOL && t !== EOF) row.push(t), t = token();
	  if (f && (row = f(row, n++)) == null) continue;
	  rows.push(row);
	}

	return rows;
}

function format(rows, columns) {
	if (columns == null) columns = inferColumns(rows);
	return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
	  return columns.map(function(column) {
		return formatValue(row[column]);
	  }).join(delimiter);
	})).join("\n");
}

function formatRows(rows) {
	return rows.map(formatRow).join("\n");
}

function formatRow(row) {
	return row.map(formatValue).join(delimiter);
}

function formatValue(text) {
	return text == null ? ""
		: reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
		: text;
}

return {
	parse: parse,
	parseRows: parseRows,
	format: format,
	formatRows: formatRows
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-dsv/src/csv.js

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-dsv/src/tsv.js

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-dsv/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/blob.js
function responseBlob(response) {
if (!response.ok) throw new Error(response.status + " " + response.statusText);
return response.blob();
}

/* harmony default export */ var blob = (function(input, init) {
return fetch(input, init).then(responseBlob);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/buffer.js
function responseArrayBuffer(response) {
if (!response.ok) throw new Error(response.status + " " + response.statusText);
return response.arrayBuffer();
}

/* harmony default export */ var src_buffer = (function(input, init) {
return fetch(input, init).then(responseArrayBuffer);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/text.js
function responseText(response) {
if (!response.ok) throw new Error(response.status + " " + response.statusText);
return response.text();
}

/* harmony default export */ var src_text = (function(input, init) {
return fetch(input, init).then(responseText);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/dsv.js

function dsvParse(parse) {
return function(input, init, row) {
	if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
	return src_text(input, init).then(function(response) {
	  return parse(response, row);
	});
};
}

function dsv_dsv(delimiter, input, init, row) {
if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
var format = dsv(delimiter);
return src_text(input, init).then(function(response) {
	return format.parse(response, row);
});
}

var dsv_csv = dsvParse(csvParse);
var dsv_tsv = dsvParse(tsvParse);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/image.js
/* harmony default export */ var src_image = (function(input, init) {
return new Promise(function(resolve, reject) {
	var image = new Image;
	for (var key in init) image[key] = init[key];
	image.onerror = reject;
	image.onload = function() { resolve(image); };
	image.src = input;
});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/json.js
function responseJson(response) {
if (!response.ok) throw new Error(response.status + " " + response.statusText);
return response.json();
}

/* harmony default export */ var json = (function(input, init) {
return fetch(input, init).then(responseJson);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/src/xml.js

function parser(type) {
return function(input, init)  {
	return src_text(input, init).then(function(text) {
	  return (new DOMParser).parseFromString(text, type);
	});
};
}

/* harmony default export */ var xml = (parser("application/xml"));

var xml_html = parser("text/html");

var svg = parser("image/svg+xml");

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-fetch/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/center.js
/* harmony default export */ var src_center = (function(x, y) {
var nodes;

if (x == null) x = 0;
if (y == null) y = 0;

function force() {
	var i,
		n = nodes.length,
		node,
		sx = 0,
		sy = 0;

	for (i = 0; i < n; ++i) {
	  node = nodes[i], sx += node.x, sy += node.y;
	}

	for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
	  node = nodes[i], node.x -= sx, node.y -= sy;
	}
}

force.initialize = function(_) {
	nodes = _;
};

force.x = function(_) {
	return arguments.length ? (x = +_, force) : x;
};

force.y = function(_) {
	return arguments.length ? (y = +_, force) : y;
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/constant.js
/* harmony default export */ var d3_force_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/jiggle.js
/* harmony default export */ var jiggle = (function() {
return (Math.random() - 0.5) * 1e-6;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/add.js
/* harmony default export */ var add = (function(d) {
var x = +this._x.call(null, d),
	  y = +this._y.call(null, d);
return add_add(this.cover(x, y), x, y, d);
});

function add_add(tree, x, y, d) {
if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

var parent,
	  node = tree._root,
	  leaf = {data: d},
	  x0 = tree._x0,
	  y0 = tree._y0,
	  x1 = tree._x1,
	  y1 = tree._y1,
	  xm,
	  ym,
	  xp,
	  yp,
	  right,
	  bottom,
	  i,
	  j;

// If the tree is empty, initialize the root as a leaf.
if (!node) return tree._root = leaf, tree;

// Find the existing leaf for the new point, or add it.
while (node.length) {
	if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
}

// Is the new point is exactly coincident with the existing point?
xp = +tree._x.call(null, node.data);
yp = +tree._y.call(null, node.data);
if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

// Otherwise, split the leaf node until the old and new point are separated.
do {
	parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
	if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
} while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
var d, i, n = data.length,
	  x,
	  y,
	  xz = new Array(n),
	  yz = new Array(n),
	  x0 = Infinity,
	  y0 = Infinity,
	  x1 = -Infinity,
	  y1 = -Infinity;

// Compute the points and their extent.
for (i = 0; i < n; ++i) {
	if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
	xz[i] = x;
	yz[i] = y;
	if (x < x0) x0 = x;
	if (x > x1) x1 = x;
	if (y < y0) y0 = y;
	if (y > y1) y1 = y;
}

// If there were no (valid) points, inherit the existing extent.
if (x1 < x0) x0 = this._x0, x1 = this._x1;
if (y1 < y0) y0 = this._y0, y1 = this._y1;

// Expand the tree to cover the new points.
this.cover(x0, y0).cover(x1, y1);

// Add the new points.
for (i = 0; i < n; ++i) {
	add_add(this, xz[i], yz[i], data[i]);
}

return this;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/cover.js
/* harmony default export */ var src_cover = (function(x, y) {
if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

var x0 = this._x0,
	  y0 = this._y0,
	  x1 = this._x1,
	  y1 = this._y1;

// If the quadtree has no extent, initialize them.
// Integer extent are necessary so that if we later double the extent,
// the existing quadrant boundaries don’t change due to floating point error!
if (isNaN(x0)) {
	x1 = (x0 = Math.floor(x)) + 1;
	y1 = (y0 = Math.floor(y)) + 1;
}

// Otherwise, double repeatedly to cover.
else if (x0 > x || x > x1 || y0 > y || y > y1) {
	var z = x1 - x0,
		node = this._root,
		parent,
		i;

	switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
	  case 0: {
		do parent = new Array(4), parent[i] = node, node = parent;
		while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
		break;
	  }
	  case 1: {
		do parent = new Array(4), parent[i] = node, node = parent;
		while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
		break;
	  }
	  case 2: {
		do parent = new Array(4), parent[i] = node, node = parent;
		while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
		break;
	  }
	  case 3: {
		do parent = new Array(4), parent[i] = node, node = parent;
		while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
		break;
	  }
	}

	if (this._root && this._root.length) this._root = node;
}

// If the quadtree covers the point already, just return.
else return this;

this._x0 = x0;
this._y0 = y0;
this._x1 = x1;
this._y1 = y1;
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/data.js
/* harmony default export */ var src_data = (function() {
var data = [];
this.visit(function(node) {
	if (!node.length) do data.push(node.data); while (node = node.next)
});
return data;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/extent.js
/* harmony default export */ var d3_quadtree_src_extent = (function(_) {
return arguments.length
	  ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
	  : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/quad.js
/* harmony default export */ var src_quad = (function(node, x0, y0, x1, y1) {
this.node = node;
this.x0 = x0;
this.y0 = y0;
this.x1 = x1;
this.y1 = y1;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/find.js

/* harmony default export */ var find = (function(x, y, radius) {
var data,
	  x0 = this._x0,
	  y0 = this._y0,
	  x1,
	  y1,
	  x2,
	  y2,
	  x3 = this._x1,
	  y3 = this._y1,
	  quads = [],
	  node = this._root,
	  q,
	  i;

if (node) quads.push(new src_quad(node, x0, y0, x3, y3));
if (radius == null) radius = Infinity;
else {
	x0 = x - radius, y0 = y - radius;
	x3 = x + radius, y3 = y + radius;
	radius *= radius;
}

while (q = quads.pop()) {

	// Stop searching if this quadrant can’t contain a closer node.
	if (!(node = q.node)
		|| (x1 = q.x0) > x3
		|| (y1 = q.y0) > y3
		|| (x2 = q.x1) < x0
		|| (y2 = q.y1) < y0) continue;

	// Bisect the current quadrant.
	if (node.length) {
	  var xm = (x1 + x2) / 2,
		  ym = (y1 + y2) / 2;

	  quads.push(
		new src_quad(node[3], xm, ym, x2, y2),
		new src_quad(node[2], x1, ym, xm, y2),
		new src_quad(node[1], xm, y1, x2, ym),
		new src_quad(node[0], x1, y1, xm, ym)
	  );

	  // Visit the closest quadrant first.
	  if (i = (y >= ym) << 1 | (x >= xm)) {
		q = quads[quads.length - 1];
		quads[quads.length - 1] = quads[quads.length - 1 - i];
		quads[quads.length - 1 - i] = q;
	  }
	}

	// Visit this point. (Visiting coincident points isn’t necessary!)
	else {
	  var dx = x - +this._x.call(null, node.data),
		  dy = y - +this._y.call(null, node.data),
		  d2 = dx * dx + dy * dy;
	  if (d2 < radius) {
		var d = Math.sqrt(radius = d2);
		x0 = x - d, y0 = y - d;
		x3 = x + d, y3 = y + d;
		data = node.data;
	  }
	}
}

return data;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/remove.js
/* harmony default export */ var src_remove = (function(d) {
if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

var parent,
	  node = this._root,
	  retainer,
	  previous,
	  next,
	  x0 = this._x0,
	  y0 = this._y0,
	  x1 = this._x1,
	  y1 = this._y1,
	  x,
	  y,
	  xm,
	  ym,
	  right,
	  bottom,
	  i,
	  j;

// If the tree is empty, initialize the root as a leaf.
if (!node) return this;

// Find the leaf node for the point.
// While descending, also retain the deepest parent with a non-removed sibling.
if (node.length) while (true) {
	if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
	if (!node.length) break;
	if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
}

// Find the point to remove.
while (node.data !== d) if (!(previous = node, node = node.next)) return this;
if (next = node.next) delete node.next;

// If there are multiple coincident points, remove just the point.
if (previous) return (next ? previous.next = next : delete previous.next), this;

// If this is the root point, remove it.
if (!parent) return this._root = next, this;

// Remove this leaf.
next ? parent[i] = next : delete parent[i];

// If the parent now contains exactly one leaf, collapse superfluous parents.
if ((node = parent[0] || parent[1] || parent[2] || parent[3])
	  && node === (parent[3] || parent[2] || parent[1] || parent[0])
	  && !node.length) {
	if (retainer) retainer[j] = node;
	else this._root = node;
}

return this;
});

function removeAll(data) {
for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
return this;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/root.js
/* harmony default export */ var src_root = (function() {
return this._root;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/size.js
/* harmony default export */ var src_size = (function() {
var size = 0;
this.visit(function(node) {
	if (!node.length) do ++size; while (node = node.next)
});
return size;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/visit.js

/* harmony default export */ var visit = (function(callback) {
var quads = [], q, node = this._root, child, x0, y0, x1, y1;
if (node) quads.push(new src_quad(node, this._x0, this._y0, this._x1, this._y1));
while (q = quads.pop()) {
	if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
	  var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	  if (child = node[3]) quads.push(new src_quad(child, xm, ym, x1, y1));
	  if (child = node[2]) quads.push(new src_quad(child, x0, ym, xm, y1));
	  if (child = node[1]) quads.push(new src_quad(child, xm, y0, x1, ym));
	  if (child = node[0]) quads.push(new src_quad(child, x0, y0, xm, ym));
	}
}
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/visitAfter.js

/* harmony default export */ var visitAfter = (function(callback) {
var quads = [], next = [], q;
if (this._root) quads.push(new src_quad(this._root, this._x0, this._y0, this._x1, this._y1));
while (q = quads.pop()) {
	var node = q.node;
	if (node.length) {
	  var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	  if (child = node[0]) quads.push(new src_quad(child, x0, y0, xm, ym));
	  if (child = node[1]) quads.push(new src_quad(child, xm, y0, x1, ym));
	  if (child = node[2]) quads.push(new src_quad(child, x0, ym, xm, y1));
	  if (child = node[3]) quads.push(new src_quad(child, xm, ym, x1, y1));
	}
	next.push(q);
}
while (q = next.pop()) {
	callback(q.node, q.x0, q.y0, q.x1, q.y1);
}
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/x.js
function x_defaultX(d) {
return d[0];
}

/* harmony default export */ var src_x = (function(_) {
return arguments.length ? (this._x = _, this) : this._x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/y.js
function y_defaultY(d) {
return d[1];
}

/* harmony default export */ var src_y = (function(_) {
return arguments.length ? (this._y = _, this) : this._y;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/src/quadtree.js

function quadtree(nodes, x, y) {
var tree = new Quadtree(x == null ? x_defaultX : x, y == null ? y_defaultY : y, NaN, NaN, NaN, NaN);
return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
this._x = x;
this._y = y;
this._x0 = x0;
this._y0 = y0;
this._x1 = x1;
this._y1 = y1;
this._root = undefined;
}

function leaf_copy(leaf) {
var copy = {data: leaf.data}, next = copy;
while (leaf = leaf.next) next = next.next = {data: leaf.data};
return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
	  node = this._root,
	  nodes,
	  child;

if (!node) return copy;

if (!node.length) return copy._root = leaf_copy(node), copy;

nodes = [{source: node, target: copy._root = new Array(4)}];
while (node = nodes.pop()) {
	for (var i = 0; i < 4; ++i) {
	  if (child = node.source[i]) {
		if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
		else node.target[i] = leaf_copy(child);
	  }
	}
}

return copy;
};

treeProto.add = add;
treeProto.addAll = addAll;
treeProto.cover = src_cover;
treeProto.data = src_data;
treeProto.extent = d3_quadtree_src_extent;
treeProto.find = find;
treeProto.remove = src_remove;
treeProto.removeAll = removeAll;
treeProto.root = src_root;
treeProto.size = src_size;
treeProto.visit = visit;
treeProto.visitAfter = visitAfter;
treeProto.x = src_x;
treeProto.y = src_y;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-quadtree/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/collide.js

function collide_x(d) {
return d.x + d.vx;
}

function collide_y(d) {
return d.y + d.vy;
}

/* harmony default export */ var collide = (function(radius) {
var nodes,
	  radii,
	  strength = 1,
	  iterations = 1;

if (typeof radius !== "function") radius = d3_force_src_constant(radius == null ? 1 : +radius);

function force() {
	var i;
	var n = nodes.length,
		tree,
		node,
		xi,
		yi,
		ri,
		ri2;

	for (var k = 0; k < iterations; ++k) {
	  tree = quadtree(nodes, collide_x, collide_y).visitAfter(prepare);
	  for (i = 0; i < n; ++i) {
		node = nodes[i];
		ri = radii[node.index], ri2 = ri * ri;
		xi = node.x + node.vx;
		yi = node.y + node.vy;
		tree.visit(apply);
	  }
	}

	function apply(quad, x0, y0, x1, y1) {
	  var data = quad.data, rj = quad.r, r = ri + rj;
	  if (data) {
		if (data.index > node.index) {
		  var x = xi - data.x - data.vx,
			  y = yi - data.y - data.vy,
			  l = x * x + y * y;
		  if (l < r * r) {
			if (x === 0) x = jiggle(), l += x * x;
			if (y === 0) y = jiggle(), l += y * y;
			l = (r - (l = Math.sqrt(l))) / l * strength;
			node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
			node.vy += (y *= l) * r;
			data.vx -= x * (r = 1 - r);
			data.vy -= y * r;
		  }
		}
		return;
	  }
	  return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
	}
}

function prepare(quad) {
	if (quad.data) return quad.r = radii[quad.data.index];
	for (var i = quad.r = 0; i < 4; ++i) {
	  if (quad[i] && quad[i].r > quad.r) {
		quad.r = quad[i].r;
	  }
	}
}

function initialize() {
	if (!nodes) return;
	var i;
	var n = nodes.length, node;
	radii = new Array(n);
	for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
}

force.initialize = function(_) {
	nodes = _;
	initialize();
};

force.iterations = function(_) {
	return arguments.length ? (iterations = +_, force) : iterations;
};

force.strength = function(_) {
	return arguments.length ? (strength = +_, force) : strength;
};

force.radius = function(_) {
	return arguments.length ? (radius = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : radius;
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/link.js

function link_index(d) {
return d.index;
}

function link_find(nodeById, nodeId) {
var node = nodeById.get(nodeId);
if (!node) throw new Error("missing: " + nodeId);
return node;
}

/* harmony default export */ var src_link = (function(links) {
var id = link_index,
	  strength = defaultStrength,
	  strengths,
	  distance = d3_force_src_constant(30),
	  distances,
	  nodes,
	  count,
	  bias,
	  iterations = 1;

if (links == null) links = [];

function defaultStrength(link) {
	return 1 / Math.min(count[link.source.index], count[link.target.index]);
}

function force(alpha) {
	for (var k = 0, n = links.length; k < iterations; ++k) {
	  for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
		link = links[i], source = link.source, target = link.target;
		x = target.x + target.vx - source.x - source.vx || jiggle();
		y = target.y + target.vy - source.y - source.vy || jiggle();
		l = Math.sqrt(x * x + y * y);
		l = (l - distances[i]) / l * alpha * strengths[i];
		x *= l, y *= l;
		target.vx -= x * (b = bias[i]);
		target.vy -= y * b;
		source.vx += x * (b = 1 - b);
		source.vy += y * b;
	  }
	}
}

function initialize() {
	if (!nodes) return;

	var i,
		n = nodes.length,
		m = links.length,
		nodeById = src_map(nodes, id),
		link;

	for (i = 0, count = new Array(n); i < m; ++i) {
	  link = links[i], link.index = i;
	  if (typeof link.source !== "object") link.source = link_find(nodeById, link.source);
	  if (typeof link.target !== "object") link.target = link_find(nodeById, link.target);
	  count[link.source.index] = (count[link.source.index] || 0) + 1;
	  count[link.target.index] = (count[link.target.index] || 0) + 1;
	}

	for (i = 0, bias = new Array(m); i < m; ++i) {
	  link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
	}

	strengths = new Array(m), initializeStrength();
	distances = new Array(m), initializeDistance();
}

function initializeStrength() {
	if (!nodes) return;

	for (var i = 0, n = links.length; i < n; ++i) {
	  strengths[i] = +strength(links[i], i, links);
	}
}

function initializeDistance() {
	if (!nodes) return;

	for (var i = 0, n = links.length; i < n; ++i) {
	  distances[i] = +distance(links[i], i, links);
	}
}

force.initialize = function(_) {
	nodes = _;
	initialize();
};

force.links = function(_) {
	return arguments.length ? (links = _, initialize(), force) : links;
};

force.id = function(_) {
	return arguments.length ? (id = _, force) : id;
};

force.iterations = function(_) {
	return arguments.length ? (iterations = +_, force) : iterations;
};

force.strength = function(_) {
	return arguments.length ? (strength = typeof _ === "function" ? _ : d3_force_src_constant(+_), initializeStrength(), force) : strength;
};

force.distance = function(_) {
	return arguments.length ? (distance = typeof _ === "function" ? _ : d3_force_src_constant(+_), initializeDistance(), force) : distance;
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/simulation.js

function simulation_x(d) {
return d.x;
}

function simulation_y(d) {
return d.y;
}

var initialRadius = 10,
	initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ var src_simulation = (function(nodes) {
var simulation,
	  alpha = 1,
	  alphaMin = 0.001,
	  alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
	  alphaTarget = 0,
	  velocityDecay = 0.6,
	  forces = src_map(),
	  stepper = timer(step),
	  event = src_dispatch("tick", "end");

if (nodes == null) nodes = [];

function step() {
	tick();
	event.call("tick", simulation);
	if (alpha < alphaMin) {
	  stepper.stop();
	  event.call("end", simulation);
	}
}

function tick() {
	var i;
	var n = nodes.length, node;

	alpha += (alphaTarget - alpha) * alphaDecay;

	forces.each(function(force) {
	  force(alpha);
	});

	for (i = 0; i < n; ++i) {
	  node = nodes[i];
	  if (node.fx == null) node.x += node.vx *= velocityDecay;
	  else node.x = node.fx, node.vx = 0;
	  if (node.fy == null) node.y += node.vy *= velocityDecay;
	  else node.y = node.fy, node.vy = 0;
	}
}

function initializeNodes() {
	for (var i = 0, n = nodes.length, node; i < n; ++i) {
	  node = nodes[i], node.index = i;
	  if (isNaN(node.x) || isNaN(node.y)) {
		var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
		node.x = radius * Math.cos(angle);
		node.y = radius * Math.sin(angle);
	  }
	  if (isNaN(node.vx) || isNaN(node.vy)) {
		node.vx = node.vy = 0;
	  }
	}
}

function initializeForce(force) {
	if (force.initialize) force.initialize(nodes);
	return force;
}

initializeNodes();

return simulation = {
	tick: tick,

	restart: function() {
	  return stepper.restart(step), simulation;
	},

	stop: function() {
	  return stepper.stop(), simulation;
	},

	nodes: function(_) {
	  return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
	},

	alpha: function(_) {
	  return arguments.length ? (alpha = +_, simulation) : alpha;
	},

	alphaMin: function(_) {
	  return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
	},

	alphaDecay: function(_) {
	  return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
	},

	alphaTarget: function(_) {
	  return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
	},

	velocityDecay: function(_) {
	  return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
	},

	force: function(name, _) {
	  return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
	},

	find: function(x, y, radius) {
	  var i = 0,
		  n = nodes.length,
		  dx,
		  dy,
		  d2,
		  node,
		  closest;

	  if (radius == null) radius = Infinity;
	  else radius *= radius;

	  for (i = 0; i < n; ++i) {
		node = nodes[i];
		dx = x - node.x;
		dy = y - node.y;
		d2 = dx * dx + dy * dy;
		if (d2 < radius) closest = node, radius = d2;
	  }

	  return closest;
	},

	on: function(name, _) {
	  return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
	}
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/manyBody.js

/* harmony default export */ var manyBody = (function() {
var nodes,
	  node,
	  alpha,
	  strength = d3_force_src_constant(-30),
	  strengths,
	  distanceMin2 = 1,
	  distanceMax2 = Infinity,
	  theta2 = 0.81;

function force(_) {
	var i;
	var n = nodes.length, tree = quadtree(nodes, simulation_x, simulation_y).visitAfter(accumulate);
	for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
}

function initialize() {
	if (!nodes) return;
	var i;
	var n = nodes.length, node;
	strengths = new Array(n);
	for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
}

function accumulate(quad) {
	var strength = 0, q, c, weight = 0, x, y, i;

	// For internal nodes, accumulate forces from child quadrants.
	if (quad.length) {
	  for (x = y = i = 0; i < 4; ++i) {
		if ((q = quad[i]) && (c = Math.abs(q.value))) {
		  strength += q.value, weight += c, x += c * q.x, y += c * q.y;
		}
	  }
	  quad.x = x / weight;
	  quad.y = y / weight;
	}

	// For leaf nodes, accumulate forces from coincident quadrants.
	else {
	  q = quad;
	  q.x = q.data.x;
	  q.y = q.data.y;
	  do strength += strengths[q.data.index];
	  while (q = q.next);
	}

	quad.value = strength;
}

function apply(quad, x1, _, x2) {
	if (!quad.value) return true;

	var x = quad.x - node.x,
		y = quad.y - node.y,
		w = x2 - x1,
		l = x * x + y * y;

	// Apply the Barnes-Hut approximation if possible.
	// Limit forces for very close nodes; randomize direction if coincident.
	if (w * w / theta2 < l) {
	  if (l < distanceMax2) {
		if (x === 0) x = jiggle(), l += x * x;
		if (y === 0) y = jiggle(), l += y * y;
		if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
		node.vx += x * quad.value * alpha / l;
		node.vy += y * quad.value * alpha / l;
	  }
	  return true;
	}

	// Otherwise, process points directly.
	else if (quad.length || l >= distanceMax2) return;

	// Limit forces for very close nodes; randomize direction if coincident.
	if (quad.data !== node || quad.next) {
	  if (x === 0) x = jiggle(), l += x * x;
	  if (y === 0) y = jiggle(), l += y * y;
	  if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	}

	do if (quad.data !== node) {
	  w = strengths[quad.data.index] * alpha / l;
	  node.vx += x * w;
	  node.vy += y * w;
	} while (quad = quad.next);
}

force.initialize = function(_) {
	nodes = _;
	initialize();
};

force.strength = function(_) {
	return arguments.length ? (strength = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : strength;
};

force.distanceMin = function(_) {
	return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
};

force.distanceMax = function(_) {
	return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
};

force.theta = function(_) {
	return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/radial.js

/* harmony default export */ var radial = (function(radius, x, y) {
var nodes,
	  strength = d3_force_src_constant(0.1),
	  strengths,
	  radiuses;

if (typeof radius !== "function") radius = d3_force_src_constant(+radius);
if (x == null) x = 0;
if (y == null) y = 0;

function force(alpha) {
	for (var i = 0, n = nodes.length; i < n; ++i) {
	  var node = nodes[i],
		  dx = node.x - x || 1e-6,
		  dy = node.y - y || 1e-6,
		  r = Math.sqrt(dx * dx + dy * dy),
		  k = (radiuses[i] - r) * strengths[i] * alpha / r;
	  node.vx += dx * k;
	  node.vy += dy * k;
	}
}

function initialize() {
	if (!nodes) return;
	var i;
	var n = nodes.length;
	strengths = new Array(n);
	radiuses = new Array(n);
	for (i = 0; i < n; ++i) {
	  radiuses[i] = +radius(nodes[i], i, nodes);
	  strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
	}
}

force.initialize = function(_) {
	nodes = _, initialize();
};

force.strength = function(_) {
	return arguments.length ? (strength = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : strength;
};

force.radius = function(_) {
	return arguments.length ? (radius = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : radius;
};

force.x = function(_) {
	return arguments.length ? (x = +_, force) : x;
};

force.y = function(_) {
	return arguments.length ? (y = +_, force) : y;
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/x.js

/* harmony default export */ var d3_force_src_x = (function(x) {
var strength = d3_force_src_constant(0.1),
	  nodes,
	  strengths,
	  xz;

if (typeof x !== "function") x = d3_force_src_constant(x == null ? 0 : +x);

function force(alpha) {
	for (var i = 0, n = nodes.length, node; i < n; ++i) {
	  node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
	}
}

function initialize() {
	if (!nodes) return;
	var i;
	var n = nodes.length;
	strengths = new Array(n);
	xz = new Array(n);
	for (i = 0; i < n; ++i) {
	  strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	}
}

force.initialize = function(_) {
	nodes = _;
	initialize();
};

force.strength = function(_) {
	return arguments.length ? (strength = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : strength;
};

force.x = function(_) {
	return arguments.length ? (x = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : x;
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/src/y.js

/* harmony default export */ var d3_force_src_y = (function(y) {
var strength = d3_force_src_constant(0.1),
	  nodes,
	  strengths,
	  yz;

if (typeof y !== "function") y = d3_force_src_constant(y == null ? 0 : +y);

function force(alpha) {
	for (var i = 0, n = nodes.length, node; i < n; ++i) {
	  node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
	}
}

function initialize() {
	if (!nodes) return;
	var i;
	var n = nodes.length;
	strengths = new Array(n);
	yz = new Array(n);
	for (i = 0; i < n; ++i) {
	  strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	}
}

force.initialize = function(_) {
	nodes = _;
	initialize();
};

force.strength = function(_) {
	return arguments.length ? (strength = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : strength;
};

force.y = function(_) {
	return arguments.length ? (y = typeof _ === "function" ? _ : d3_force_src_constant(+_), initialize(), force) : y;
};

return force;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-force/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatDecimal.js
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ var formatDecimal = (function(x, p) {
if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
var i, coefficient = x.slice(0, i);

// The string returned by toExponential either has the form \d\.\d+e[-+]\d+
// (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
return [
	coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	+x.slice(i + 1)
];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/exponent.js

/* harmony default export */ var src_exponent = (function(x) {
return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatGroup.js
/* harmony default export */ var formatGroup = (function(grouping, thousands) {
return function(value, width) {
	var i = value.length,
		t = [],
		j = 0,
		g = grouping[0],
		length = 0;

	while (i > 0 && g > 0) {
	  if (length + g + 1 > width) g = Math.max(1, width - length);
	  t.push(value.substring(i -= g, i + g));
	  if ((length += g + 1) > width) break;
	  g = grouping[j = (j + 1) % grouping.length];
	}

	return t.reverse().join(thousands);
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ var formatNumerals = (function(numerals) {
return function(value) {
	return value.replace(/[0-9]/g, function(i) {
	  return numerals[+i];
	});
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatDefault.js
/* harmony default export */ var formatDefault = (function(x, p) {
x = x.toPrecision(p);

out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
	switch (x[i]) {
	  case ".": i0 = i1 = i; break;
	  case "0": if (i0 === 0) i0 = i; i1 = i; break;
	  case "e": break out;
	  default: if (i0 > 0) i0 = 0; break;
	}
}

return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatPrefixAuto.js

var prefixExponent;

/* harmony default export */ var formatPrefixAuto = (function(x, p) {
var d = formatDecimal(x, p);
if (!d) return x + "";
var coefficient = d[0],
	  exponent = d[1],
	  i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	  n = coefficient.length;
return i === n ? coefficient
	  : i > n ? coefficient + new Array(i - n + 1).join("0")
	  : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	  : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatRounded.js

/* harmony default export */ var formatRounded = (function(x, p) {
var d = formatDecimal(x, p);
if (!d) return x + "";
var coefficient = d[0],
	  exponent = d[1];
return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	  : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	  : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatTypes.js

/* harmony default export */ var formatTypes = ({
"": formatDefault,
"%": function(x, p) { return (x * 100).toFixed(p); },
"b": function(x) { return Math.round(x).toString(2); },
"c": function(x) { return x + ""; },
"d": function(x) { return Math.round(x).toString(10); },
"e": function(x, p) { return x.toExponential(p); },
"f": function(x, p) { return x.toFixed(p); },
"g": function(x, p) { return x.toPrecision(p); },
"o": function(x) { return Math.round(x).toString(8); },
"p": function(x, p) { return formatRounded(x * 100, p); },
"r": formatRounded,
"s": formatPrefixAuto,
"X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
"x": function(x) { return Math.round(x).toString(16); }
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/formatSpecifier.js

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

var match,
	  fill = match[1] || " ",
	  align = match[2] || ">",
	  sign = match[3] || "-",
	  symbol = match[4] || "",
	  zero = !!match[5],
	  width = match[6] && +match[6],
	  comma = !!match[7],
	  precision = match[8] && +match[8].slice(1),
	  type = match[9] || "";

// The "n" type is an alias for ",g".
if (type === "n") comma = true, type = "g";

// Map invalid types to the default format.
else if (!formatTypes[type]) type = "";

// If zero fill is specified, padding goes after sign and before digits.
if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

this.fill = fill;
this.align = align;
this.sign = sign;
this.symbol = symbol;
this.zero = zero;
this.width = width;
this.comma = comma;
this.precision = precision;
this.type = type;
}

FormatSpecifier.prototype.toString = function() {
return this.fill
	  + this.align
	  + this.sign
	  + this.symbol
	  + (this.zero ? "0" : "")
	  + (this.width == null ? "" : Math.max(1, this.width | 0))
	  + (this.comma ? "," : "")
	  + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
	  + this.type;
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/identity.js
/* harmony default export */ var d3_format_src_identity = (function(x) {
return x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/locale.js

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ var src_locale = (function(locale) {
var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : d3_format_src_identity,
	  currency = locale.currency,
	  decimal = locale.decimal,
	  numerals = locale.numerals ? formatNumerals(locale.numerals) : d3_format_src_identity,
	  percent = locale.percent || "%";

function newFormat(specifier) {
	specifier = formatSpecifier(specifier);

	var fill = specifier.fill,
		align = specifier.align,
		sign = specifier.sign,
		symbol = specifier.symbol,
		zero = specifier.zero,
		width = specifier.width,
		comma = specifier.comma,
		precision = specifier.precision,
		type = specifier.type;

	// Compute the prefix and suffix.
	// For SI-prefix, the suffix is lazily computed.
	var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
		suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

	// What format function should we use?
	// Is this an integer type?
	// Can this type generate exponential notation?
	var formatType = formatTypes[type],
		maybeSuffix = !type || /[defgprs%]/.test(type);

	// Set the default precision if not specified,
	// or clamp the specified precision to the supported range.
	// For significant precision, it must be in [1, 21].
	// For fixed precision, it must be in [0, 20].
	precision = precision == null ? (type ? 6 : 12)
		: /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
		: Math.max(0, Math.min(20, precision));

	function format(value) {
	  var valuePrefix = prefix,
		  valueSuffix = suffix,
		  i, n, c;

	  if (type === "c") {
		valueSuffix = formatType(value) + valueSuffix;
		value = "";
	  } else {
		value = +value;

		// Perform the initial formatting.
		var valueNegative = value < 0;
		value = formatType(Math.abs(value), precision);

		// If a negative value rounds to zero during formatting, treat as positive.
		if (valueNegative && +value === 0) valueNegative = false;

		// Compute the prefix and suffix.
		valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
		valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

		// Break the formatted value into the integer “value” part that can be
		// grouped, and fractional or exponential “suffix” part that is not.
		if (maybeSuffix) {
		  i = -1, n = value.length;
		  while (++i < n) {
			if (c = value.charCodeAt(i), 48 > c || c > 57) {
			  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
			  value = value.slice(0, i);
			  break;
			}
		  }
		}
	  }

	  // If the fill character is not "0", grouping is applied before padding.
	  if (comma && !zero) value = group(value, Infinity);

	  // Compute the padding.
	  var length = valuePrefix.length + value.length + valueSuffix.length,
		  padding = length < width ? new Array(width - length + 1).join(fill) : "";

	  // If the fill character is "0", grouping is applied after padding.
	  if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	  // Reconstruct the final output based on the desired alignment.
	  switch (align) {
		case "<": value = valuePrefix + value + valueSuffix + padding; break;
		case "=": value = valuePrefix + padding + value + valueSuffix; break;
		case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
		default: value = padding + valuePrefix + value + valueSuffix; break;
	  }

	  return numerals(value);
	}

	format.toString = function() {
	  return specifier + "";
	};

	return format;
}

function formatPrefix(specifier, value) {
	var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
		e = Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) * 3,
		k = Math.pow(10, -e),
		prefix = prefixes[8 + e / 3];
	return function(value) {
	  return f(k * value) + prefix;
	};
}

return {
	format: newFormat,
	formatPrefix: formatPrefix
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/defaultLocale.js

var defaultLocale_locale;
var defaultLocale_format;
var defaultLocale_formatPrefix;

defaultLocale({
decimal: ".",
thousands: ",",
grouping: [3],
currency: ["$", ""]
});

function defaultLocale(definition) {
defaultLocale_locale = src_locale(definition);
defaultLocale_format = defaultLocale_locale.format;
defaultLocale_formatPrefix = defaultLocale_locale.formatPrefix;
return defaultLocale_locale;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/precisionFixed.js

/* harmony default export */ var precisionFixed = (function(step) {
return Math.max(0, -src_exponent(Math.abs(step)));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/precisionPrefix.js

/* harmony default export */ var precisionPrefix = (function(step, value) {
return Math.max(0, Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) * 3 - src_exponent(Math.abs(step)));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/src/precisionRound.js

/* harmony default export */ var precisionRound = (function(step, max) {
step = Math.abs(step), max = Math.abs(max) - step;
return Math.max(0, src_exponent(max) - src_exponent(step)) + 1;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-format/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/adder.js
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

/* harmony default export */ var adder = (function() {
return new Adder;
});

function Adder() {
this.reset();
}

Adder.prototype = {
constructor: Adder,
reset: function() {
	this.s = // rounded value
	this.t = 0; // exact error
},
add: function(y) {
	adder_add(temp, y, this.t);
	adder_add(this, temp.s, this.s);
	if (this.s) this.t += temp.t;
	else this.s = temp.t;
},
valueOf: function() {
	return this.s;
}
};

var temp = new Adder;

function adder_add(adder, a, b) {
var x = adder.s = a + b,
	  bv = x - a,
	  av = x - bv;
adder.t = (a - av) + (b - bv);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/math.js
var math_epsilon = 1e-6;
var math_epsilon2 = 1e-12;
var src_math_pi = Math.PI;
var src_math_halfPi = src_math_pi / 2;
var quarterPi = src_math_pi / 4;
var src_math_tau = src_math_pi * 2;

var math_degrees = 180 / src_math_pi;
var radians = src_math_pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var math_cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var math_sin = Math.sin;
var math_sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
return x > 1 ? 0 : x < -1 ? src_math_pi : Math.acos(x);
}

function asin(x) {
return x > 1 ? src_math_halfPi : x < -1 ? -src_math_halfPi : Math.asin(x);
}

function haversin(x) {
return (x = math_sin(x / 2)) * x;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/noop.js
function noop_noop() {}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
	streamGeometryType[geometry.type](geometry, stream);
}
}

var streamObjectType = {
Feature: function(object, stream) {
	streamGeometry(object.geometry, stream);
},
FeatureCollection: function(object, stream) {
	var features = object.features, i = -1, n = features.length;
	while (++i < n) streamGeometry(features[i].geometry, stream);
}
};

var streamGeometryType = {
Sphere: function(object, stream) {
	stream.sphere();
},
Point: function(object, stream) {
	object = object.coordinates;
	stream.point(object[0], object[1], object[2]);
},
MultiPoint: function(object, stream) {
	var coordinates = object.coordinates, i = -1, n = coordinates.length;
	while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
},
LineString: function(object, stream) {
	streamLine(object.coordinates, stream, 0);
},
MultiLineString: function(object, stream) {
	var coordinates = object.coordinates, i = -1, n = coordinates.length;
	while (++i < n) streamLine(coordinates[i], stream, 0);
},
Polygon: function(object, stream) {
	streamPolygon(object.coordinates, stream);
},
MultiPolygon: function(object, stream) {
	var coordinates = object.coordinates, i = -1, n = coordinates.length;
	while (++i < n) streamPolygon(coordinates[i], stream);
},
GeometryCollection: function(object, stream) {
	var geometries = object.geometries, i = -1, n = geometries.length;
	while (++i < n) streamGeometry(geometries[i], stream);
}
};

function streamLine(coordinates, stream, closed) {
var i = -1, n = coordinates.length - closed, coordinate;
stream.lineStart();
while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
var i = -1, n = coordinates.length;
stream.polygonStart();
while (++i < n) streamLine(coordinates[i], stream, 1);
stream.polygonEnd();
}

/* harmony default export */ var src_stream = (function(object, stream) {
if (object && streamObjectType.hasOwnProperty(object.type)) {
	streamObjectType[object.type](object, stream);
} else {
	streamGeometry(object, stream);
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/area.js

var areaRingSum = adder();

var areaSum = adder(),
	area_lambda00,
	phi00,
	area_lambda0,
	area_cosPhi0,
	area_sinPhi0;

var areaStream = {
point: noop_noop,
lineStart: noop_noop,
lineEnd: noop_noop,
polygonStart: function() {
	areaRingSum.reset();
	areaStream.lineStart = areaRingStart;
	areaStream.lineEnd = areaRingEnd;
},
polygonEnd: function() {
	var areaRing = +areaRingSum;
	areaSum.add(areaRing < 0 ? src_math_tau + areaRing : areaRing);
	this.lineStart = this.lineEnd = this.point = noop_noop;
},
sphere: function() {
	areaSum.add(src_math_tau);
}
};

function areaRingStart() {
areaStream.point = areaPointFirst;
}

function areaRingEnd() {
areaPoint(area_lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
areaStream.point = areaPoint;
area_lambda00 = lambda, phi00 = phi;
lambda *= radians, phi *= radians;
area_lambda0 = lambda, area_cosPhi0 = math_cos(phi = phi / 2 + quarterPi), area_sinPhi0 = math_sin(phi);
}

function areaPoint(lambda, phi) {
lambda *= radians, phi *= radians;
phi = phi / 2 + quarterPi; // half the angular distance from south pole

// Spherical excess E for a spherical triangle with vertices: south pole,
// previous point, current point.  Uses a formula derived from Cagnoli’s
// theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
var dLambda = lambda - area_lambda0,
	  sdLambda = dLambda >= 0 ? 1 : -1,
	  adLambda = sdLambda * dLambda,
	  cosPhi = math_cos(phi),
	  sinPhi = math_sin(phi),
	  k = area_sinPhi0 * sinPhi,
	  u = area_cosPhi0 * cosPhi + k * math_cos(adLambda),
	  v = k * sdLambda * math_sin(adLambda);
areaRingSum.add(atan2(v, u));

// Advance the previous points.
area_lambda0 = lambda, area_cosPhi0 = cosPhi, area_sinPhi0 = sinPhi;
}

/* harmony default export */ var d3_geo_src_area = (function(object) {
areaSum.reset();
src_stream(object, areaStream);
return areaSum * 2;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/cartesian.js

function cartesian_spherical(cartesian) {
return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian_cartesian(spherical) {
var lambda = spherical[0], phi = spherical[1], cosPhi = math_cos(phi);
return [cosPhi * math_cos(lambda), cosPhi * math_sin(lambda), math_sin(phi)];
}

function cartesianDot(a, b) {
return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
d[0] /= l, d[1] /= l, d[2] /= l;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/bounds.js

var bounds_lambda0, bounds_phi0, bounds_lambda1, bounds_phi1, // bounds
	bounds_lambda2, // previous lambda-coordinate
	bounds_lambda00, bounds_phi00, // first point
	bounds_p0, // previous 3D point
	deltaSum = adder(),
	ranges,
	bounds_range;

var boundsStream = {
point: boundsPoint,
lineStart: boundsLineStart,
lineEnd: boundsLineEnd,
polygonStart: function() {
	boundsStream.point = boundsRingPoint;
	boundsStream.lineStart = boundsRingStart;
	boundsStream.lineEnd = boundsRingEnd;
	deltaSum.reset();
	areaStream.polygonStart();
},
polygonEnd: function() {
	areaStream.polygonEnd();
	boundsStream.point = boundsPoint;
	boundsStream.lineStart = boundsLineStart;
	boundsStream.lineEnd = boundsLineEnd;
	if (areaRingSum < 0) bounds_lambda0 = -(bounds_lambda1 = 180), bounds_phi0 = -(bounds_phi1 = 90);
	else if (deltaSum > math_epsilon) bounds_phi1 = 90;
	else if (deltaSum < -math_epsilon) bounds_phi0 = -90;
	bounds_range[0] = bounds_lambda0, bounds_range[1] = bounds_lambda1;
}
};

function boundsPoint(lambda, phi) {
ranges.push(bounds_range = [bounds_lambda0 = lambda, bounds_lambda1 = lambda]);
if (phi < bounds_phi0) bounds_phi0 = phi;
if (phi > bounds_phi1) bounds_phi1 = phi;
}

function bounds_linePoint(lambda, phi) {
var p = cartesian_cartesian([lambda * radians, phi * radians]);
if (bounds_p0) {
	var normal = cartesianCross(bounds_p0, p),
		equatorial = [normal[1], -normal[0], 0],
		inflection = cartesianCross(equatorial, normal);
	cartesianNormalizeInPlace(inflection);
	inflection = cartesian_spherical(inflection);
	var delta = lambda - bounds_lambda2,
		sign = delta > 0 ? 1 : -1,
		lambdai = inflection[0] * math_degrees * sign,
		phii,
		antimeridian = abs(delta) > 180;
	if (antimeridian ^ (sign * bounds_lambda2 < lambdai && lambdai < sign * lambda)) {
	  phii = inflection[1] * math_degrees;
	  if (phii > bounds_phi1) bounds_phi1 = phii;
	} else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * bounds_lambda2 < lambdai && lambdai < sign * lambda)) {
	  phii = -inflection[1] * math_degrees;
	  if (phii < bounds_phi0) bounds_phi0 = phii;
	} else {
	  if (phi < bounds_phi0) bounds_phi0 = phi;
	  if (phi > bounds_phi1) bounds_phi1 = phi;
	}
	if (antimeridian) {
	  if (lambda < bounds_lambda2) {
		if (bounds_angle(bounds_lambda0, lambda) > bounds_angle(bounds_lambda0, bounds_lambda1)) bounds_lambda1 = lambda;
	  } else {
		if (bounds_angle(lambda, bounds_lambda1) > bounds_angle(bounds_lambda0, bounds_lambda1)) bounds_lambda0 = lambda;
	  }
	} else {
	  if (bounds_lambda1 >= bounds_lambda0) {
		if (lambda < bounds_lambda0) bounds_lambda0 = lambda;
		if (lambda > bounds_lambda1) bounds_lambda1 = lambda;
	  } else {
		if (lambda > bounds_lambda2) {
		  if (bounds_angle(bounds_lambda0, lambda) > bounds_angle(bounds_lambda0, bounds_lambda1)) bounds_lambda1 = lambda;
		} else {
		  if (bounds_angle(lambda, bounds_lambda1) > bounds_angle(bounds_lambda0, bounds_lambda1)) bounds_lambda0 = lambda;
		}
	  }
	}
} else {
	ranges.push(bounds_range = [bounds_lambda0 = lambda, bounds_lambda1 = lambda]);
}
if (phi < bounds_phi0) bounds_phi0 = phi;
if (phi > bounds_phi1) bounds_phi1 = phi;
bounds_p0 = p, bounds_lambda2 = lambda;
}

function boundsLineStart() {
boundsStream.point = bounds_linePoint;
}

function boundsLineEnd() {
bounds_range[0] = bounds_lambda0, bounds_range[1] = bounds_lambda1;
boundsStream.point = boundsPoint;
bounds_p0 = null;
}

function boundsRingPoint(lambda, phi) {
if (bounds_p0) {
	var delta = lambda - bounds_lambda2;
	deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
} else {
	bounds_lambda00 = lambda, bounds_phi00 = phi;
}
areaStream.point(lambda, phi);
bounds_linePoint(lambda, phi);
}

function boundsRingStart() {
areaStream.lineStart();
}

function boundsRingEnd() {
boundsRingPoint(bounds_lambda00, bounds_phi00);
areaStream.lineEnd();
if (abs(deltaSum) > math_epsilon) bounds_lambda0 = -(bounds_lambda1 = 180);
bounds_range[0] = bounds_lambda0, bounds_range[1] = bounds_lambda1;
bounds_p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function bounds_angle(lambda0, lambda1) {
return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
return a[0] - b[0];
}

function rangeContains(range, x) {
return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ var bounds = (function(feature) {
var i, n, a, b, merged, deltaMax, delta;

bounds_phi1 = bounds_lambda1 = -(bounds_lambda0 = bounds_phi0 = Infinity);
ranges = [];
src_stream(feature, boundsStream);

// First, sort ranges by their minimum longitudes.
if (n = ranges.length) {
	ranges.sort(rangeCompare);

	// Then, merge any ranges that overlap.
	for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
	  b = ranges[i];
	  if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
		if (bounds_angle(a[0], b[1]) > bounds_angle(a[0], a[1])) a[1] = b[1];
		if (bounds_angle(b[0], a[1]) > bounds_angle(a[0], a[1])) a[0] = b[0];
	  } else {
		merged.push(a = b);
	  }
	}

	// Finally, find the largest gap between the merged ranges.
	// The final bounding box will be the inverse of this gap.
	for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
	  b = merged[i];
	  if ((delta = bounds_angle(a[1], b[0])) > deltaMax) deltaMax = delta, bounds_lambda0 = b[0], bounds_lambda1 = a[1];
	}
}

ranges = bounds_range = null;

return bounds_lambda0 === Infinity || bounds_phi0 === Infinity
	  ? [[NaN, NaN], [NaN, NaN]]
	  : [[bounds_lambda0, bounds_phi0], [bounds_lambda1, bounds_phi1]];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/centroid.js

var W0, W1,
	centroid_X0, centroid_Y0, Z0,
	centroid_X1, centroid_Y1, Z1,
	X2, Y2, Z2,
	centroid_lambda00, centroid_phi00, // first point
	centroid_x0, centroid_y0, z0; // previous point

var centroidStream = {
sphere: noop_noop,
point: centroidPoint,
lineStart: centroidLineStart,
lineEnd: centroidLineEnd,
polygonStart: function() {
	centroidStream.lineStart = centroidRingStart;
	centroidStream.lineEnd = centroidRingEnd;
},
polygonEnd: function() {
	centroidStream.lineStart = centroidLineStart;
	centroidStream.lineEnd = centroidLineEnd;
}
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
lambda *= radians, phi *= radians;
var cosPhi = math_cos(phi);
centroidPointCartesian(cosPhi * math_cos(lambda), cosPhi * math_sin(lambda), math_sin(phi));
}

function centroidPointCartesian(x, y, z) {
++W0;
centroid_X0 += (x - centroid_X0) / W0;
centroid_Y0 += (y - centroid_Y0) / W0;
Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
lambda *= radians, phi *= radians;
var cosPhi = math_cos(phi);
centroid_x0 = cosPhi * math_cos(lambda);
centroid_y0 = cosPhi * math_sin(lambda);
z0 = math_sin(phi);
centroidStream.point = centroidLinePoint;
centroidPointCartesian(centroid_x0, centroid_y0, z0);
}

function centroidLinePoint(lambda, phi) {
lambda *= radians, phi *= radians;
var cosPhi = math_cos(phi),
	  x = cosPhi * math_cos(lambda),
	  y = cosPhi * math_sin(lambda),
	  z = math_sin(phi),
	  w = atan2(sqrt((w = centroid_y0 * z - z0 * y) * w + (w = z0 * x - centroid_x0 * z) * w + (w = centroid_x0 * y - centroid_y0 * x) * w), centroid_x0 * x + centroid_y0 * y + z0 * z);
W1 += w;
centroid_X1 += w * (centroid_x0 + (centroid_x0 = x));
centroid_Y1 += w * (centroid_y0 + (centroid_y0 = y));
Z1 += w * (z0 + (z0 = z));
centroidPointCartesian(centroid_x0, centroid_y0, z0);
}

function centroidLineEnd() {
centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
centroidRingPoint(centroid_lambda00, centroid_phi00);
centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
centroid_lambda00 = lambda, centroid_phi00 = phi;
lambda *= radians, phi *= radians;
centroidStream.point = centroidRingPoint;
var cosPhi = math_cos(phi);
centroid_x0 = cosPhi * math_cos(lambda);
centroid_y0 = cosPhi * math_sin(lambda);
z0 = math_sin(phi);
centroidPointCartesian(centroid_x0, centroid_y0, z0);
}

function centroidRingPoint(lambda, phi) {
lambda *= radians, phi *= radians;
var cosPhi = math_cos(phi),
	  x = cosPhi * math_cos(lambda),
	  y = cosPhi * math_sin(lambda),
	  z = math_sin(phi),
	  cx = centroid_y0 * z - z0 * y,
	  cy = z0 * x - centroid_x0 * z,
	  cz = centroid_x0 * y - centroid_y0 * x,
	  m = sqrt(cx * cx + cy * cy + cz * cz),
	  w = asin(m), // line weight = angle
	  v = m && -w / m; // area weight multiplier
X2 += v * cx;
Y2 += v * cy;
Z2 += v * cz;
W1 += w;
centroid_X1 += w * (centroid_x0 + (centroid_x0 = x));
centroid_Y1 += w * (centroid_y0 + (centroid_y0 = y));
Z1 += w * (z0 + (z0 = z));
centroidPointCartesian(centroid_x0, centroid_y0, z0);
}

/* harmony default export */ var src_centroid = (function(object) {
W0 = W1 =
centroid_X0 = centroid_Y0 = Z0 =
centroid_X1 = centroid_Y1 = Z1 =
X2 = Y2 = Z2 = 0;
src_stream(object, centroidStream);

var x = X2,
	  y = Y2,
	  z = Z2,
	  m = x * x + y * y + z * z;

// If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
if (m < math_epsilon2) {
	x = centroid_X1, y = centroid_Y1, z = Z1;
	// If the feature has zero length, fall back to arithmetic mean of point vectors.
	if (W1 < math_epsilon) x = centroid_X0, y = centroid_Y0, z = Z0;
	m = x * x + y * y + z * z;
	// If the feature still has an undefined ccentroid, then return.
	if (m < math_epsilon2) return [NaN, NaN];
}

return [atan2(y, x) * math_degrees, asin(z / sqrt(m)) * math_degrees];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/constant.js
/* harmony default export */ var d3_geo_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/compose.js
/* harmony default export */ var compose = (function(a, b) {

function compose(x, y) {
	return x = a(x, y), b(x[0], x[1]);
}

if (a.invert && b.invert) compose.invert = function(x, y) {
	return x = b.invert(x, y), x && a.invert(x[0], x[1]);
};

return compose;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/rotation.js

function rotationIdentity(lambda, phi) {
return [lambda > src_math_pi ? lambda - src_math_tau : lambda < -src_math_pi ? lambda + src_math_tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
return (deltaLambda %= src_math_tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
	: rotationLambda(deltaLambda))
	: (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
	: rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
return function(lambda, phi) {
	return lambda += deltaLambda, [lambda > src_math_pi ? lambda - src_math_tau : lambda < -src_math_pi ? lambda + src_math_tau : lambda, phi];
};
}

function rotationLambda(deltaLambda) {
var rotation = forwardRotationLambda(deltaLambda);
rotation.invert = forwardRotationLambda(-deltaLambda);
return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
var cosDeltaPhi = math_cos(deltaPhi),
	  sinDeltaPhi = math_sin(deltaPhi),
	  cosDeltaGamma = math_cos(deltaGamma),
	  sinDeltaGamma = math_sin(deltaGamma);

function rotation(lambda, phi) {
	var cosPhi = math_cos(phi),
		x = math_cos(lambda) * cosPhi,
		y = math_sin(lambda) * cosPhi,
		z = math_sin(phi),
		k = z * cosDeltaPhi + x * sinDeltaPhi;
	return [
	  atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
	  asin(k * cosDeltaGamma + y * sinDeltaGamma)
	];
}

rotation.invert = function(lambda, phi) {
	var cosPhi = math_cos(phi),
		x = math_cos(lambda) * cosPhi,
		y = math_sin(lambda) * cosPhi,
		z = math_sin(phi),
		k = z * cosDeltaGamma - y * sinDeltaGamma;
	return [
	  atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
	  asin(k * cosDeltaPhi - x * sinDeltaPhi)
	];
};

return rotation;
}

/* harmony default export */ var src_rotation = (function(rotate) {
rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

function forward(coordinates) {
	coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
	return coordinates[0] *= math_degrees, coordinates[1] *= math_degrees, coordinates;
}

forward.invert = function(coordinates) {
	coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
	return coordinates[0] *= math_degrees, coordinates[1] *= math_degrees, coordinates;
};

return forward;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/circle.js

// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
if (!delta) return;
var cosRadius = math_cos(radius),
	  sinRadius = math_sin(radius),
	  step = direction * delta;
if (t0 == null) {
	t0 = radius + direction * src_math_tau;
	t1 = radius - step / 2;
} else {
	t0 = circleRadius(cosRadius, t0);
	t1 = circleRadius(cosRadius, t1);
	if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * src_math_tau;
}
for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
	point = cartesian_spherical([cosRadius, -sinRadius * math_cos(t), -sinRadius * math_sin(t)]);
	stream.point(point[0], point[1]);
}
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
point = cartesian_cartesian(point), point[0] -= cosRadius;
cartesianNormalizeInPlace(point);
var radius = acos(-point[1]);
return ((-point[2] < 0 ? -radius : radius) + src_math_tau - math_epsilon) % src_math_tau;
}

/* harmony default export */ var src_circle = (function() {
var center = d3_geo_src_constant([0, 0]),
	  radius = d3_geo_src_constant(90),
	  precision = d3_geo_src_constant(6),
	  ring,
	  rotate,
	  stream = {point: point};

function point(x, y) {
	ring.push(x = rotate(x, y));
	x[0] *= math_degrees, x[1] *= math_degrees;
}

function circle() {
	var c = center.apply(this, arguments),
		r = radius.apply(this, arguments) * radians,
		p = precision.apply(this, arguments) * radians;
	ring = [];
	rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
	circleStream(stream, r, p, 1);
	c = {type: "Polygon", coordinates: [ring]};
	ring = rotate = null;
	return c;
}

circle.center = function(_) {
	return arguments.length ? (center = typeof _ === "function" ? _ : d3_geo_src_constant([+_[0], +_[1]]), circle) : center;
};

circle.radius = function(_) {
	return arguments.length ? (radius = typeof _ === "function" ? _ : d3_geo_src_constant(+_), circle) : radius;
};

circle.precision = function(_) {
	return arguments.length ? (precision = typeof _ === "function" ? _ : d3_geo_src_constant(+_), circle) : precision;
};

return circle;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/buffer.js

/* harmony default export */ var clip_buffer = (function() {
var lines = [],
	  line;
return {
	point: function(x, y) {
	  line.push([x, y]);
	},
	lineStart: function() {
	  lines.push(line = []);
	},
	lineEnd: noop_noop,
	rejoin: function() {
	  if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	},
	result: function() {
	  var result = lines;
	  lines = [];
	  line = null;
	  return result;
	}
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/pointEqual.js

/* harmony default export */ var pointEqual = (function(a, b) {
return abs(a[0] - b[0]) < math_epsilon && abs(a[1] - b[1]) < math_epsilon;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/rejoin.js

function Intersection(point, points, other, entry) {
this.x = point;
this.z = points;
this.o = other; // another intersection
this.e = entry; // is an entry?
this.v = false; // visited
this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ var rejoin = (function(segments, compareIntersection, startInside, interpolate, stream) {
var subject = [],
	  clip = [],
	  i,
	  n;

segments.forEach(function(segment) {
	if ((n = segment.length - 1) <= 0) return;
	var n;
	var p0 = segment[0], p1 = segment[n], x;

	// If the first and last points of a segment are coincident, then treat as a
	// closed ring. TODO if all rings are closed, then the winding order of the
	// exterior ring should be checked.
	if (pointEqual(p0, p1)) {
	  stream.lineStart();
	  for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
	  stream.lineEnd();
	  return;
	}

	subject.push(x = new Intersection(p0, segment, null, true));
	clip.push(x.o = new Intersection(p0, null, x, false));
	subject.push(x = new Intersection(p1, segment, null, false));
	clip.push(x.o = new Intersection(p1, null, x, true));
});

if (!subject.length) return;

clip.sort(compareIntersection);
rejoin_link(subject);
rejoin_link(clip);

for (i = 0, n = clip.length; i < n; ++i) {
	clip[i].e = startInside = !startInside;
}

var start = subject[0],
	  points,
	  point;

while (1) {
	// Find first unvisited intersection.
	var current = start,
		isSubject = true;
	while (current.v) if ((current = current.n) === start) return;
	points = current.z;
	stream.lineStart();
	do {
	  current.v = current.o.v = true;
	  if (current.e) {
		if (isSubject) {
		  for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
		} else {
		  interpolate(current.x, current.n.x, 1, stream);
		}
		current = current.n;
	  } else {
		if (isSubject) {
		  points = current.p.z;
		  for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
		} else {
		  interpolate(current.x, current.p.x, -1, stream);
		}
		current = current.p;
	  }
	  current = current.o;
	  points = current.z;
	  isSubject = !isSubject;
	} while (!current.v);
	stream.lineEnd();
}
});

function rejoin_link(array) {
if (!(n = array.length)) return;
var n,
	  i = 0,
	  a = array[0],
	  b;
while (++i < n) {
	a.n = b = array[i];
	b.p = a;
	a = b;
}
a.n = b = array[0];
b.p = a;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/polygonContains.js

var polygonContains_sum = adder();

/* harmony default export */ var polygonContains = (function(polygon, point) {
var lambda = point[0],
	  phi = point[1],
	  sinPhi = math_sin(phi),
	  normal = [math_sin(lambda), -math_cos(lambda), 0],
	  angle = 0,
	  winding = 0;

polygonContains_sum.reset();

if (sinPhi === 1) phi = src_math_halfPi + math_epsilon;
else if (sinPhi === -1) phi = -src_math_halfPi - math_epsilon;

for (var i = 0, n = polygon.length; i < n; ++i) {
	if (!(m = (ring = polygon[i]).length)) continue;
	var ring,
		m,
		point0 = ring[m - 1],
		lambda0 = point0[0],
		phi0 = point0[1] / 2 + quarterPi,
		sinPhi0 = math_sin(phi0),
		cosPhi0 = math_cos(phi0);

	for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
	  var point1 = ring[j],
		  lambda1 = point1[0],
		  phi1 = point1[1] / 2 + quarterPi,
		  sinPhi1 = math_sin(phi1),
		  cosPhi1 = math_cos(phi1),
		  delta = lambda1 - lambda0,
		  sign = delta >= 0 ? 1 : -1,
		  absDelta = sign * delta,
		  antimeridian = absDelta > src_math_pi,
		  k = sinPhi0 * sinPhi1;

	  polygonContains_sum.add(atan2(k * sign * math_sin(absDelta), cosPhi0 * cosPhi1 + k * math_cos(absDelta)));
	  angle += antimeridian ? delta + sign * src_math_tau : delta;

	  // Are the longitudes either side of the point’s meridian (lambda),
	  // and are the latitudes smaller than the parallel (phi)?
	  if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
		var arc = cartesianCross(cartesian_cartesian(point0), cartesian_cartesian(point1));
		cartesianNormalizeInPlace(arc);
		var intersection = cartesianCross(normal, arc);
		cartesianNormalizeInPlace(intersection);
		var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
		if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
		  winding += antimeridian ^ delta >= 0 ? 1 : -1;
		}
	  }
	}
}

// First, determine whether the South pole is inside or outside:
//
// It is inside if:
// * the polygon winds around it in a clockwise direction.
// * the polygon does not (cumulatively) wind around it, but has a negative
//   (counter-clockwise) area.
//
// Second, count the (signed) number of times a segment crosses a lambda
// from the point to the South pole.  If it is zero, then the point is the
// same side as the South pole.

return (angle < -math_epsilon || angle < math_epsilon && polygonContains_sum < -math_epsilon) ^ (winding & 1);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/index.js

/* harmony default export */ var src_clip = (function(pointVisible, clipLine, interpolate, start) {
return function(sink) {
	var line = clipLine(sink),
		ringBuffer = clip_buffer(),
		ringSink = clipLine(ringBuffer),
		polygonStarted = false,
		polygon,
		segments,
		ring;

	var clip = {
	  point: point,
	  lineStart: lineStart,
	  lineEnd: lineEnd,
	  polygonStart: function() {
		clip.point = pointRing;
		clip.lineStart = ringStart;
		clip.lineEnd = ringEnd;
		segments = [];
		polygon = [];
	  },
	  polygonEnd: function() {
		clip.point = point;
		clip.lineStart = lineStart;
		clip.lineEnd = lineEnd;
		segments = src_merge(segments);
		var startInside = polygonContains(polygon, start);
		if (segments.length) {
		  if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
		  rejoin(segments, clip_compareIntersection, startInside, interpolate, sink);
		} else if (startInside) {
		  if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
		  sink.lineStart();
		  interpolate(null, null, 1, sink);
		  sink.lineEnd();
		}
		if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
		segments = polygon = null;
	  },
	  sphere: function() {
		sink.polygonStart();
		sink.lineStart();
		interpolate(null, null, 1, sink);
		sink.lineEnd();
		sink.polygonEnd();
	  }
	};

	function point(lambda, phi) {
	  if (pointVisible(lambda, phi)) sink.point(lambda, phi);
	}

	function pointLine(lambda, phi) {
	  line.point(lambda, phi);
	}

	function lineStart() {
	  clip.point = pointLine;
	  line.lineStart();
	}

	function lineEnd() {
	  clip.point = point;
	  line.lineEnd();
	}

	function pointRing(lambda, phi) {
	  ring.push([lambda, phi]);
	  ringSink.point(lambda, phi);
	}

	function ringStart() {
	  ringSink.lineStart();
	  ring = [];
	}

	function ringEnd() {
	  pointRing(ring[0][0], ring[0][1]);
	  ringSink.lineEnd();

	  var clean = ringSink.clean(),
		  ringSegments = ringBuffer.result(),
		  i, n = ringSegments.length, m,
		  segment,
		  point;

	  ring.pop();
	  polygon.push(ring);
	  ring = null;

	  if (!n) return;

	  // No intersections.
	  if (clean & 1) {
		segment = ringSegments[0];
		if ((m = segment.length - 1) > 0) {
		  if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
		  sink.lineStart();
		  for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
		  sink.lineEnd();
		}
		return;
	  }

	  // Rejoin connected segments.
	  // TODO reuse ringBuffer.rejoin()?
	  if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

	  segments.push(ringSegments.filter(validSegment));
	}

	return clip;
};
});

function validSegment(segment) {
return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function clip_compareIntersection(a, b) {
return ((a = a.x)[0] < 0 ? a[1] - src_math_halfPi - math_epsilon : src_math_halfPi - a[1])
	   - ((b = b.x)[0] < 0 ? b[1] - src_math_halfPi - math_epsilon : src_math_halfPi - b[1]);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/antimeridian.js

/* harmony default export */ var clip_antimeridian = (src_clip(
function() { return true; },
clipAntimeridianLine,
clipAntimeridianInterpolate,
[-src_math_pi, -src_math_halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
var lambda0 = NaN,
	  phi0 = NaN,
	  sign0 = NaN,
	  clean; // no intersections

return {
	lineStart: function() {
	  stream.lineStart();
	  clean = 1;
	},
	point: function(lambda1, phi1) {
	  var sign1 = lambda1 > 0 ? src_math_pi : -src_math_pi,
		  delta = abs(lambda1 - lambda0);
	  if (abs(delta - src_math_pi) < math_epsilon) { // line crosses a pole
		stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? src_math_halfPi : -src_math_halfPi);
		stream.point(sign0, phi0);
		stream.lineEnd();
		stream.lineStart();
		stream.point(sign1, phi0);
		stream.point(lambda1, phi0);
		clean = 0;
	  } else if (sign0 !== sign1 && delta >= src_math_pi) { // line crosses antimeridian
		if (abs(lambda0 - sign0) < math_epsilon) lambda0 -= sign0 * math_epsilon; // handle degeneracies
		if (abs(lambda1 - sign1) < math_epsilon) lambda1 -= sign1 * math_epsilon;
		phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
		stream.point(sign0, phi0);
		stream.lineEnd();
		stream.lineStart();
		stream.point(sign1, phi0);
		clean = 0;
	  }
	  stream.point(lambda0 = lambda1, phi0 = phi1);
	  sign0 = sign1;
	},
	lineEnd: function() {
	  stream.lineEnd();
	  lambda0 = phi0 = NaN;
	},
	clean: function() {
	  return 2 - clean; // if intersections, rejoin first and last segments
	}
};
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
var cosPhi0,
	  cosPhi1,
	  sinLambda0Lambda1 = math_sin(lambda0 - lambda1);
return abs(sinLambda0Lambda1) > math_epsilon
	  ? atan((math_sin(phi0) * (cosPhi1 = math_cos(phi1)) * math_sin(lambda1)
		  - math_sin(phi1) * (cosPhi0 = math_cos(phi0)) * math_sin(lambda0))
		  / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
	  : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
var phi;
if (from == null) {
	phi = direction * src_math_halfPi;
	stream.point(-src_math_pi, phi);
	stream.point(0, phi);
	stream.point(src_math_pi, phi);
	stream.point(src_math_pi, 0);
	stream.point(src_math_pi, -phi);
	stream.point(0, -phi);
	stream.point(-src_math_pi, -phi);
	stream.point(-src_math_pi, 0);
	stream.point(-src_math_pi, phi);
} else if (abs(from[0] - to[0]) > math_epsilon) {
	var lambda = from[0] < to[0] ? src_math_pi : -src_math_pi;
	phi = direction * lambda / 2;
	stream.point(-lambda, phi);
	stream.point(0, phi);
	stream.point(lambda, phi);
} else {
	stream.point(to[0], to[1]);
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/circle.js

/* harmony default export */ var clip_circle = (function(radius) {
var cr = math_cos(radius),
	  delta = 6 * radians,
	  smallRadius = cr > 0,
	  notHemisphere = abs(cr) > math_epsilon; // TODO optimise for this common case

function interpolate(from, to, direction, stream) {
	circleStream(stream, radius, delta, direction, from, to);
}

function visible(lambda, phi) {
	return math_cos(lambda) * math_cos(phi) > cr;
}

// Takes a line and cuts into visible segments. Return values used for polygon
// clipping: 0 - there were intersections or the line was empty; 1 - no
// intersections 2 - there were intersections, and the first and last segments
// should be rejoined.
function clipLine(stream) {
	var point0;
	var // previous point
		c0, // code for previous point
		v0, // visibility of previous point
		v00, // visibility of first point
		clean; // no intersections
	return {
	  lineStart: function() {
		v00 = v0 = false;
		clean = 1;
	  },
	  point: function(lambda, phi) {
		var point1 = [lambda, phi],
			point2,
			v = visible(lambda, phi),
			c = smallRadius
			  ? v ? 0 : code(lambda, phi)
			  : v ? code(lambda + (lambda < 0 ? src_math_pi : -src_math_pi), phi) : 0;
		if (!point0 && (v00 = v0 = v)) stream.lineStart();
		// Handle degeneracies.
		// TODO ignore if not clipping polygons.
		if (v !== v0) {
		  point2 = intersect(point0, point1);
		  if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
			point1[0] += math_epsilon;
			point1[1] += math_epsilon;
			v = visible(point1[0], point1[1]);
		  }
		}
		if (v !== v0) {
		  clean = 0;
		  if (v) {
			// outside going in
			stream.lineStart();
			point2 = intersect(point1, point0);
			stream.point(point2[0], point2[1]);
		  } else {
			// inside going out
			point2 = intersect(point0, point1);
			stream.point(point2[0], point2[1]);
			stream.lineEnd();
		  }
		  point0 = point2;
		} else if (notHemisphere && point0 && smallRadius ^ v) {
		  var t;
		  // If the codes for two points are different, or are both zero,
		  // and there this segment intersects with the small circle.
		  if (!(c & c0) && (t = intersect(point1, point0, true))) {
			clean = 0;
			if (smallRadius) {
			  stream.lineStart();
			  stream.point(t[0][0], t[0][1]);
			  stream.point(t[1][0], t[1][1]);
			  stream.lineEnd();
			} else {
			  stream.point(t[1][0], t[1][1]);
			  stream.lineEnd();
			  stream.lineStart();
			  stream.point(t[0][0], t[0][1]);
			}
		  }
		}
		if (v && (!point0 || !pointEqual(point0, point1))) {
		  stream.point(point1[0], point1[1]);
		}
		point0 = point1, v0 = v, c0 = c;
	  },
	  lineEnd: function() {
		if (v0) stream.lineEnd();
		point0 = null;
	  },
	  // Rejoin first and last segments if there were intersections and the first
	  // and last points were visible.
	  clean: function() {
		return clean | ((v00 && v0) << 1);
	  }
	};
}

// Intersects the great circle between a and b with the clip circle.
function intersect(a, b, two) {
	var pa = cartesian_cartesian(a),
		pb = cartesian_cartesian(b);

	// We have two planes, n1.p = d1 and n2.p = d2.
	// Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
	var n1 = [1, 0, 0], // normal
		n2 = cartesianCross(pa, pb),
		n2n2 = cartesianDot(n2, n2),
		n1n2 = n2[0], // cartesianDot(n1, n2),
		determinant = n2n2 - n1n2 * n1n2;

	// Two polar points.
	if (!determinant) return !two && a;

	var c1 =  cr * n2n2 / determinant,
		c2 = -cr * n1n2 / determinant,
		n1xn2 = cartesianCross(n1, n2),
		A = cartesianScale(n1, c1),
		B = cartesianScale(n2, c2);
	cartesianAddInPlace(A, B);

	// Solve |p(t)|^2 = 1.
	var u = n1xn2,
		w = cartesianDot(A, u),
		uu = cartesianDot(u, u),
		t2 = w * w - uu * (cartesianDot(A, A) - 1);

	if (t2 < 0) return;

	var t = sqrt(t2),
		q = cartesianScale(u, (-w - t) / uu);
	cartesianAddInPlace(q, A);
	q = cartesian_spherical(q);

	if (!two) return q;

	// Two intersection points.
	var lambda0 = a[0],
		lambda1 = b[0],
		phi0 = a[1],
		phi1 = b[1],
		z;

	if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

	var delta = lambda1 - lambda0,
		polar = abs(delta - src_math_pi) < math_epsilon,
		meridian = polar || delta < math_epsilon;

	if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

	// Check that the first point is between a and b.
	if (meridian
		? polar
		  ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < math_epsilon ? phi0 : phi1)
		  : phi0 <= q[1] && q[1] <= phi1
		: delta > src_math_pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
	  var q1 = cartesianScale(u, (-w + t) / uu);
	  cartesianAddInPlace(q1, A);
	  return [q, cartesian_spherical(q1)];
	}
}

// Generates a 4-bit vector representing the location of a point relative to
// the small circle's bounding box.
function code(lambda, phi) {
	var r = smallRadius ? radius : src_math_pi - radius,
		code = 0;
	if (lambda < -r) code |= 1; // left
	else if (lambda > r) code |= 2; // right
	if (phi < -r) code |= 4; // below
	else if (phi > r) code |= 8; // above
	return code;
}

return src_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-src_math_pi, radius - src_math_pi]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/line.js
/* harmony default export */ var clip_line = (function(a, b, x0, y0, x1, y1) {
var ax = a[0],
	  ay = a[1],
	  bx = b[0],
	  by = b[1],
	  t0 = 0,
	  t1 = 1,
	  dx = bx - ax,
	  dy = by - ay,
	  r;

r = x0 - ax;
if (!dx && r > 0) return;
r /= dx;
if (dx < 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
} else if (dx > 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
}

r = x1 - ax;
if (!dx && r < 0) return;
r /= dx;
if (dx < 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
} else if (dx > 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
}

r = y0 - ay;
if (!dy && r > 0) return;
r /= dy;
if (dy < 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
} else if (dy > 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
}

r = y1 - ay;
if (!dy && r < 0) return;
r /= dy;
if (dy < 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
} else if (dy > 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
}

if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
return true;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/rectangle.js

var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

function visible(x, y) {
	return x0 <= x && x <= x1 && y0 <= y && y <= y1;
}

function interpolate(from, to, direction, stream) {
	var a = 0, a1 = 0;
	if (from == null
		|| (a = corner(from, direction)) !== (a1 = corner(to, direction))
		|| comparePoint(from, to) < 0 ^ direction > 0) {
	  do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	  while ((a = (a + direction + 4) % 4) !== a1);
	} else {
	  stream.point(to[0], to[1]);
	}
}

function corner(p, direction) {
	return abs(p[0] - x0) < math_epsilon ? direction > 0 ? 0 : 3
		: abs(p[0] - x1) < math_epsilon ? direction > 0 ? 2 : 1
		: abs(p[1] - y0) < math_epsilon ? direction > 0 ? 1 : 0
		: direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
}

function compareIntersection(a, b) {
	return comparePoint(a.x, b.x);
}

function comparePoint(a, b) {
	var ca = corner(a, 1),
		cb = corner(b, 1);
	return ca !== cb ? ca - cb
		: ca === 0 ? b[1] - a[1]
		: ca === 1 ? a[0] - b[0]
		: ca === 2 ? a[1] - b[1]
		: b[0] - a[0];
}

return function(stream) {
	var activeStream = stream,
		bufferStream = clip_buffer(),
		segments,
		polygon,
		ring,
		x__, y__, v__, // first point
		x_, y_, v_, // previous point
		first,
		clean;

	var clipStream = {
	  point: point,
	  lineStart: lineStart,
	  lineEnd: lineEnd,
	  polygonStart: polygonStart,
	  polygonEnd: polygonEnd
	};

	function point(x, y) {
	  if (visible(x, y)) activeStream.point(x, y);
	}

	function polygonInside() {
	  var winding = 0;

	  for (var i = 0, n = polygon.length; i < n; ++i) {
		for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
		  a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
		  if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
		  else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
		}
	  }

	  return winding;
	}

	// Buffer geometry within a polygon and then clip it en masse.
	function polygonStart() {
	  activeStream = bufferStream, segments = [], polygon = [], clean = true;
	}

	function polygonEnd() {
	  var startInside = polygonInside(),
		  cleanInside = clean && startInside,
		  visible = (segments = src_merge(segments)).length;
	  if (cleanInside || visible) {
		stream.polygonStart();
		if (cleanInside) {
		  stream.lineStart();
		  interpolate(null, null, 1, stream);
		  stream.lineEnd();
		}
		if (visible) {
		  rejoin(segments, compareIntersection, startInside, interpolate, stream);
		}
		stream.polygonEnd();
	  }
	  activeStream = stream, segments = polygon = ring = null;
	}

	function lineStart() {
	  clipStream.point = linePoint;
	  if (polygon) polygon.push(ring = []);
	  first = true;
	  v_ = false;
	  x_ = y_ = NaN;
	}

	// TODO rather than special-case polygons, simply handle them separately.
	// Ideally, coincident intersection points should be jittered to avoid
	// clipping issues.
	function lineEnd() {
	  if (segments) {
		linePoint(x__, y__);
		if (v__ && v_) bufferStream.rejoin();
		segments.push(bufferStream.result());
	  }
	  clipStream.point = point;
	  if (v_) activeStream.lineEnd();
	}

	function linePoint(x, y) {
	  var v = visible(x, y);
	  if (polygon) ring.push([x, y]);
	  if (first) {
		x__ = x, y__ = y, v__ = v;
		first = false;
		if (v) {
		  activeStream.lineStart();
		  activeStream.point(x, y);
		}
	  } else {
		if (v && v_) activeStream.point(x, y);
		else {
		  var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
			  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
		  if (clip_line(a, b, x0, y0, x1, y1)) {
			if (!v_) {
			  activeStream.lineStart();
			  activeStream.point(a[0], a[1]);
			}
			activeStream.point(b[0], b[1]);
			if (!v) activeStream.lineEnd();
			clean = false;
		  } else if (v) {
			activeStream.lineStart();
			activeStream.point(x, y);
			clean = false;
		  }
		}
	  }
	  x_ = x, y_ = y, v_ = v;
	}

	return clipStream;
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/clip/extent.js

/* harmony default export */ var clip_extent = (function() {
var x0 = 0,
	  y0 = 0,
	  x1 = 960,
	  y1 = 500,
	  cache,
	  cacheStream,
	  clip;

return clip = {
	stream: function(stream) {
	  return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
	},
	extent: function(_) {
	  return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
	}
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/length.js

var lengthSum = adder(),
	length_lambda0,
	length_sinPhi0,
	length_cosPhi0;

var lengthStream = {
sphere: noop_noop,
point: noop_noop,
lineStart: lengthLineStart,
lineEnd: noop_noop,
polygonStart: noop_noop,
polygonEnd: noop_noop
};

function lengthLineStart() {
lengthStream.point = lengthPointFirst;
lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
lengthStream.point = lengthStream.lineEnd = noop_noop;
}

function lengthPointFirst(lambda, phi) {
lambda *= radians, phi *= radians;
length_lambda0 = lambda, length_sinPhi0 = math_sin(phi), length_cosPhi0 = math_cos(phi);
lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
lambda *= radians, phi *= radians;
var sinPhi = math_sin(phi),
	  cosPhi = math_cos(phi),
	  delta = abs(lambda - length_lambda0),
	  cosDelta = math_cos(delta),
	  sinDelta = math_sin(delta),
	  x = cosPhi * sinDelta,
	  y = length_cosPhi0 * sinPhi - length_sinPhi0 * cosPhi * cosDelta,
	  z = length_sinPhi0 * sinPhi + length_cosPhi0 * cosPhi * cosDelta;
lengthSum.add(atan2(sqrt(x * x + y * y), z));
length_lambda0 = lambda, length_sinPhi0 = sinPhi, length_cosPhi0 = cosPhi;
}

/* harmony default export */ var src_length = (function(object) {
lengthSum.reset();
src_stream(object, lengthStream);
return +lengthSum;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/distance.js

var distance_coordinates = [null, null],
	distance_object = {type: "LineString", coordinates: distance_coordinates};

/* harmony default export */ var src_distance = (function(a, b) {
distance_coordinates[0] = a;
distance_coordinates[1] = b;
return src_length(distance_object);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/contains.js

var containsObjectType = {
Feature: function(object, point) {
	return containsGeometry(object.geometry, point);
},
FeatureCollection: function(object, point) {
	var features = object.features, i = -1, n = features.length;
	while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
	return false;
}
};

var containsGeometryType = {
Sphere: function() {
	return true;
},
Point: function(object, point) {
	return containsPoint(object.coordinates, point);
},
MultiPoint: function(object, point) {
	var coordinates = object.coordinates, i = -1, n = coordinates.length;
	while (++i < n) if (containsPoint(coordinates[i], point)) return true;
	return false;
},
LineString: function(object, point) {
	return containsLine(object.coordinates, point);
},
MultiLineString: function(object, point) {
	var coordinates = object.coordinates, i = -1, n = coordinates.length;
	while (++i < n) if (containsLine(coordinates[i], point)) return true;
	return false;
},
Polygon: function(object, point) {
	return containsPolygon(object.coordinates, point);
},
MultiPolygon: function(object, point) {
	var coordinates = object.coordinates, i = -1, n = coordinates.length;
	while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
	return false;
},
GeometryCollection: function(object, point) {
	var geometries = object.geometries, i = -1, n = geometries.length;
	while (++i < n) if (containsGeometry(geometries[i], point)) return true;
	return false;
}
};

function containsGeometry(geometry, point) {
return geometry && containsGeometryType.hasOwnProperty(geometry.type)
	  ? containsGeometryType[geometry.type](geometry, point)
	  : false;
}

function containsPoint(coordinates, point) {
return src_distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
var ab = src_distance(coordinates[0], coordinates[1]),
	  ao = src_distance(coordinates[0], point),
	  ob = src_distance(point, coordinates[1]);
return ao + ob <= ab + math_epsilon;
}

function containsPolygon(coordinates, point) {
return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
return [point[0] * radians, point[1] * radians];
}

/* harmony default export */ var src_contains = (function(object, point) {
return (object && containsObjectType.hasOwnProperty(object.type)
	  ? containsObjectType[object.type]
	  : containsGeometry)(object, point);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/graticule.js

function graticuleX(y0, y1, dy) {
var y = src_range(y0, y1 - math_epsilon, dy).concat(y1);
return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
var x = src_range(x0, x1 - math_epsilon, dx).concat(x1);
return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule_graticule() {
var x1, x0, X1, X0,
	  y1, y0, Y1, Y0,
	  dx = 10, dy = dx, DX = 90, DY = 360,
	  x, y, X, Y,
	  precision = 2.5;

function graticule() {
	return {type: "MultiLineString", coordinates: lines()};
}

function lines() {
	return src_range(ceil(X0 / DX) * DX, X1, DX).map(X)
		.concat(src_range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
		.concat(src_range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > math_epsilon; }).map(x))
		.concat(src_range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > math_epsilon; }).map(y));
}

graticule.lines = function() {
	return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
};

graticule.outline = function() {
	return {
	  type: "Polygon",
	  coordinates: [
		X(X0).concat(
		Y(Y1).slice(1),
		X(X1).reverse().slice(1),
		Y(Y0).reverse().slice(1))
	  ]
	};
};

graticule.extent = function(_) {
	if (!arguments.length) return graticule.extentMinor();
	return graticule.extentMajor(_).extentMinor(_);
};

graticule.extentMajor = function(_) {
	if (!arguments.length) return [[X0, Y0], [X1, Y1]];
	X0 = +_[0][0], X1 = +_[1][0];
	Y0 = +_[0][1], Y1 = +_[1][1];
	if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	return graticule.precision(precision);
};

graticule.extentMinor = function(_) {
	if (!arguments.length) return [[x0, y0], [x1, y1]];
	x0 = +_[0][0], x1 = +_[1][0];
	y0 = +_[0][1], y1 = +_[1][1];
	if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	return graticule.precision(precision);
};

graticule.step = function(_) {
	if (!arguments.length) return graticule.stepMinor();
	return graticule.stepMajor(_).stepMinor(_);
};

graticule.stepMajor = function(_) {
	if (!arguments.length) return [DX, DY];
	DX = +_[0], DY = +_[1];
	return graticule;
};

graticule.stepMinor = function(_) {
	if (!arguments.length) return [dx, dy];
	dx = +_[0], dy = +_[1];
	return graticule;
};

graticule.precision = function(_) {
	if (!arguments.length) return precision;
	precision = +_;
	x = graticuleX(y0, y1, 90);
	y = graticuleY(x0, x1, precision);
	X = graticuleX(Y0, Y1, 90);
	Y = graticuleY(X0, X1, precision);
	return graticule;
};

return graticule
	  .extentMajor([[-180, -90 + math_epsilon], [180, 90 - math_epsilon]])
	  .extentMinor([[-180, -80 - math_epsilon], [180, 80 + math_epsilon]]);
}

function graticule10() {
return graticule_graticule()();
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/interpolate.js

/* harmony default export */ var src_interpolate = (function(a, b) {
var x0 = a[0] * radians,
	  y0 = a[1] * radians,
	  x1 = b[0] * radians,
	  y1 = b[1] * radians,
	  cy0 = math_cos(y0),
	  sy0 = math_sin(y0),
	  cy1 = math_cos(y1),
	  sy1 = math_sin(y1),
	  kx0 = cy0 * math_cos(x0),
	  ky0 = cy0 * math_sin(x0),
	  kx1 = cy1 * math_cos(x1),
	  ky1 = cy1 * math_sin(x1),
	  d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
	  k = math_sin(d);

var interpolate = d ? function(t) {
	var B = math_sin(t *= d) / k,
		A = math_sin(d - t) / k,
		x = A * kx0 + B * kx1,
		y = A * ky0 + B * ky1,
		z = A * sy0 + B * sy1;
	return [
	  atan2(y, x) * math_degrees,
	  atan2(z, sqrt(x * x + y * y)) * math_degrees
	];
} : function() {
	return [x0 * math_degrees, y0 * math_degrees];
};

interpolate.distance = d;

return interpolate;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/identity.js
/* harmony default export */ var d3_geo_src_identity = (function(x) {
return x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/area.js

var area_areaSum = adder(),
	area_areaRingSum = adder(),
	area_x00,
	area_y00,
	area_x0,
	area_y0;

var area_areaStream = {
point: noop_noop,
lineStart: noop_noop,
lineEnd: noop_noop,
polygonStart: function() {
	area_areaStream.lineStart = area_areaRingStart;
	area_areaStream.lineEnd = area_areaRingEnd;
},
polygonEnd: function() {
	area_areaStream.lineStart = area_areaStream.lineEnd = area_areaStream.point = noop_noop;
	area_areaSum.add(abs(area_areaRingSum));
	area_areaRingSum.reset();
},
result: function() {
	var area = area_areaSum / 2;
	area_areaSum.reset();
	return area;
}
};

function area_areaRingStart() {
area_areaStream.point = area_areaPointFirst;
}

function area_areaPointFirst(x, y) {
area_areaStream.point = area_areaPoint;
area_x00 = area_x0 = x, area_y00 = area_y0 = y;
}

function area_areaPoint(x, y) {
area_areaRingSum.add(area_y0 * x - area_x0 * y);
area_x0 = x, area_y0 = y;
}

function area_areaRingEnd() {
area_areaPoint(area_x00, area_y00);
}

/* harmony default export */ var path_area = (area_areaStream);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/bounds.js

var bounds_x0 = Infinity,
	bounds_y0 = bounds_x0,
	bounds_x1 = -bounds_x0,
	bounds_y1 = bounds_x1;

var bounds_boundsStream = {
point: bounds_boundsPoint,
lineStart: noop_noop,
lineEnd: noop_noop,
polygonStart: noop_noop,
polygonEnd: noop_noop,
result: function() {
	var bounds = [[bounds_x0, bounds_y0], [bounds_x1, bounds_y1]];
	bounds_x1 = bounds_y1 = -(bounds_y0 = bounds_x0 = Infinity);
	return bounds;
}
};

function bounds_boundsPoint(x, y) {
if (x < bounds_x0) bounds_x0 = x;
if (x > bounds_x1) bounds_x1 = x;
if (y < bounds_y0) bounds_y0 = y;
if (y > bounds_y1) bounds_y1 = y;
}

/* harmony default export */ var path_bounds = (bounds_boundsStream);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/centroid.js

// TODO Enforce positive area for exterior, negative area for interior?

var path_centroid_X0 = 0,
	path_centroid_Y0 = 0,
	centroid_Z0 = 0,
	path_centroid_X1 = 0,
	path_centroid_Y1 = 0,
	centroid_Z1 = 0,
	centroid_X2 = 0,
	centroid_Y2 = 0,
	centroid_Z2 = 0,
	centroid_x00,
	centroid_y00,
	path_centroid_x0,
	path_centroid_y0;

var centroid_centroidStream = {
point: centroid_centroidPoint,
lineStart: centroid_centroidLineStart,
lineEnd: centroid_centroidLineEnd,
polygonStart: function() {
	centroid_centroidStream.lineStart = centroid_centroidRingStart;
	centroid_centroidStream.lineEnd = centroid_centroidRingEnd;
},
polygonEnd: function() {
	centroid_centroidStream.point = centroid_centroidPoint;
	centroid_centroidStream.lineStart = centroid_centroidLineStart;
	centroid_centroidStream.lineEnd = centroid_centroidLineEnd;
},
result: function() {
	var centroid = centroid_Z2 ? [centroid_X2 / centroid_Z2, centroid_Y2 / centroid_Z2]
		: centroid_Z1 ? [path_centroid_X1 / centroid_Z1, path_centroid_Y1 / centroid_Z1]
		: centroid_Z0 ? [path_centroid_X0 / centroid_Z0, path_centroid_Y0 / centroid_Z0]
		: [NaN, NaN];
	path_centroid_X0 = path_centroid_Y0 = centroid_Z0 =
	path_centroid_X1 = path_centroid_Y1 = centroid_Z1 =
	centroid_X2 = centroid_Y2 = centroid_Z2 = 0;
	return centroid;
}
};

function centroid_centroidPoint(x, y) {
path_centroid_X0 += x;
path_centroid_Y0 += y;
++centroid_Z0;
}

function centroid_centroidLineStart() {
centroid_centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
centroid_centroidStream.point = centroidPointLine;
centroid_centroidPoint(path_centroid_x0 = x, path_centroid_y0 = y);
}

function centroidPointLine(x, y) {
var dx = x - path_centroid_x0, dy = y - path_centroid_y0, z = sqrt(dx * dx + dy * dy);
path_centroid_X1 += z * (path_centroid_x0 + x) / 2;
path_centroid_Y1 += z * (path_centroid_y0 + y) / 2;
centroid_Z1 += z;
centroid_centroidPoint(path_centroid_x0 = x, path_centroid_y0 = y);
}

function centroid_centroidLineEnd() {
centroid_centroidStream.point = centroid_centroidPoint;
}

function centroid_centroidRingStart() {
centroid_centroidStream.point = centroidPointFirstRing;
}

function centroid_centroidRingEnd() {
centroidPointRing(centroid_x00, centroid_y00);
}

function centroidPointFirstRing(x, y) {
centroid_centroidStream.point = centroidPointRing;
centroid_centroidPoint(centroid_x00 = path_centroid_x0 = x, centroid_y00 = path_centroid_y0 = y);
}

function centroidPointRing(x, y) {
var dx = x - path_centroid_x0,
	  dy = y - path_centroid_y0,
	  z = sqrt(dx * dx + dy * dy);

path_centroid_X1 += z * (path_centroid_x0 + x) / 2;
path_centroid_Y1 += z * (path_centroid_y0 + y) / 2;
centroid_Z1 += z;

z = path_centroid_y0 * x - path_centroid_x0 * y;
centroid_X2 += z * (path_centroid_x0 + x);
centroid_Y2 += z * (path_centroid_y0 + y);
centroid_Z2 += z * 3;
centroid_centroidPoint(path_centroid_x0 = x, path_centroid_y0 = y);
}

/* harmony default export */ var path_centroid = (centroid_centroidStream);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/context.js

function PathContext(context) {
this._context = context;
}

PathContext.prototype = {
_radius: 4.5,
pointRadius: function(_) {
	return this._radius = _, this;
},
polygonStart: function() {
	this._line = 0;
},
polygonEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._point = 0;
},
lineEnd: function() {
	if (this._line === 0) this._context.closePath();
	this._point = NaN;
},
point: function(x, y) {
	switch (this._point) {
	  case 0: {
		this._context.moveTo(x, y);
		this._point = 1;
		break;
	  }
	  case 1: {
		this._context.lineTo(x, y);
		break;
	  }
	  default: {
		this._context.moveTo(x + this._radius, y);
		this._context.arc(x, y, this._radius, 0, src_math_tau);
		break;
	  }
	}
},
result: noop_noop
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/measure.js

var measure_lengthSum = adder(),
	lengthRing,
	measure_x00,
	measure_y00,
	measure_x0,
	measure_y0;

var measure_lengthStream = {
point: noop_noop,
lineStart: function() {
	measure_lengthStream.point = measure_lengthPointFirst;
},
lineEnd: function() {
	if (lengthRing) measure_lengthPoint(measure_x00, measure_y00);
	measure_lengthStream.point = noop_noop;
},
polygonStart: function() {
	lengthRing = true;
},
polygonEnd: function() {
	lengthRing = null;
},
result: function() {
	var length = +measure_lengthSum;
	measure_lengthSum.reset();
	return length;
}
};

function measure_lengthPointFirst(x, y) {
measure_lengthStream.point = measure_lengthPoint;
measure_x00 = measure_x0 = x, measure_y00 = measure_y0 = y;
}

function measure_lengthPoint(x, y) {
measure_x0 -= x, measure_y0 -= y;
measure_lengthSum.add(sqrt(measure_x0 * measure_x0 + measure_y0 * measure_y0));
measure_x0 = x, measure_y0 = y;
}

/* harmony default export */ var measure = (measure_lengthStream);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/string.js
function PathString() {
this._string = [];
}

PathString.prototype = {
_radius: 4.5,
_circle: string_circle(4.5),
pointRadius: function(_) {
	if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
	return this;
},
polygonStart: function() {
	this._line = 0;
},
polygonEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._point = 0;
},
lineEnd: function() {
	if (this._line === 0) this._string.push("Z");
	this._point = NaN;
},
point: function(x, y) {
	switch (this._point) {
	  case 0: {
		this._string.push("M", x, ",", y);
		this._point = 1;
		break;
	  }
	  case 1: {
		this._string.push("L", x, ",", y);
		break;
	  }
	  default: {
		if (this._circle == null) this._circle = string_circle(this._radius);
		this._string.push("M", x, ",", y, this._circle);
		break;
	  }
	}
},
result: function() {
	if (this._string.length) {
	  var result = this._string.join("");
	  this._string = [];
	  return result;
	} else {
	  return null;
	}
}
};

function string_circle(radius) {
return "m0," + radius
	  + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
	  + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
	  + "z";
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/path/index.js

/* harmony default export */ var d3_geo_src_path = (function(projection, context) {
var pointRadius = 4.5,
	  projectionStream,
	  contextStream;

function path(object) {
	if (object) {
	  if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	  src_stream(object, projectionStream(contextStream));
	}
	return contextStream.result();
}

path.area = function(object) {
	src_stream(object, projectionStream(path_area));
	return path_area.result();
};

path.measure = function(object) {
	src_stream(object, projectionStream(measure));
	return measure.result();
};

path.bounds = function(object) {
	src_stream(object, projectionStream(path_bounds));
	return path_bounds.result();
};

path.centroid = function(object) {
	src_stream(object, projectionStream(path_centroid));
	return path_centroid.result();
};

path.projection = function(_) {
	return arguments.length ? (projectionStream = _ == null ? (projection = null, d3_geo_src_identity) : (projection = _).stream, path) : projection;
};

path.context = function(_) {
	if (!arguments.length) return context;
	contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
	if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	return path;
};

path.pointRadius = function(_) {
	if (!arguments.length) return pointRadius;
	pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	return path;
};

return path.projection(projection).context(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/transform.js
/* harmony default export */ var src_transform = (function(methods) {
return {
	stream: transformer(methods)
};
});

function transformer(methods) {
return function(stream) {
	var s = new TransformStream;
	for (var key in methods) s[key] = methods[key];
	s.stream = stream;
	return s;
};
}

function TransformStream() {}

TransformStream.prototype = {
constructor: TransformStream,
point: function(x, y) { this.stream.point(x, y); },
sphere: function() { this.stream.sphere(); },
lineStart: function() { this.stream.lineStart(); },
lineEnd: function() { this.stream.lineEnd(); },
polygonStart: function() { this.stream.polygonStart(); },
polygonEnd: function() { this.stream.polygonEnd(); }
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/fit.js

function fit(projection, fitBounds, object) {
var clip = projection.clipExtent && projection.clipExtent();
projection.scale(150).translate([0, 0]);
if (clip != null) projection.clipExtent(null);
src_stream(object, projection.stream(path_bounds));
fitBounds(path_bounds.result());
if (clip != null) projection.clipExtent(clip);
return projection;
}

function fitExtent(projection, extent, object) {
return fit(projection, function(b) {
	var w = extent[1][0] - extent[0][0],
		h = extent[1][1] - extent[0][1],
		k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
		x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
		y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
	projection.scale(150 * k).translate([x, y]);
}, object);
}

function fitSize(projection, size, object) {
return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
return fit(projection, function(b) {
	var w = +width,
		k = w / (b[1][0] - b[0][0]),
		x = (w - k * (b[1][0] + b[0][0])) / 2,
		y = -k * b[0][1];
	projection.scale(150 * k).translate([x, y]);
}, object);
}

function fitHeight(projection, height, object) {
return fit(projection, function(b) {
	var h = +height,
		k = h / (b[1][1] - b[0][1]),
		x = -k * b[0][0],
		y = (h - k * (b[1][1] + b[0][1])) / 2;
	projection.scale(150 * k).translate([x, y]);
}, object);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/resample.js

var maxDepth = 16, // maximum depth of subdivision
	cosMinDistance = math_cos(30 * radians); // cos(minimum angular distance)

/* harmony default export */ var resample = (function(project, delta2) {
return +delta2 ? resample_resample(project, delta2) : resampleNone(project);
});

function resampleNone(project) {
return transformer({
	point: function(x, y) {
	  x = project(x, y);
	  this.stream.point(x[0], x[1]);
	}
});
}

function resample_resample(project, delta2) {

function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
	var dx = x1 - x0,
		dy = y1 - y0,
		d2 = dx * dx + dy * dy;
	if (d2 > 4 * delta2 && depth--) {
	  var a = a0 + a1,
		  b = b0 + b1,
		  c = c0 + c1,
		  m = sqrt(a * a + b * b + c * c),
		  phi2 = asin(c /= m),
		  lambda2 = abs(abs(c) - 1) < math_epsilon || abs(lambda0 - lambda1) < math_epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
		  p = project(lambda2, phi2),
		  x2 = p[0],
		  y2 = p[1],
		  dx2 = x2 - x0,
		  dy2 = y2 - y0,
		  dz = dy * dx2 - dx * dy2;
	  if (dz * dz / d2 > delta2 // perpendicular projected distance
		  || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
		  || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
		resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
		stream.point(x2, y2);
		resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
	  }
	}
}
return function(stream) {
	var lambda00;
	var x00;
	var y00;
	var a00;
	var b00;
	var c00;
	var // first point
		lambda0, x0, y0, a0, b0, c0; // previous point

	var resampleStream = {
	  point: point,
	  lineStart: lineStart,
	  lineEnd: lineEnd,
	  polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
	  polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
	};

	function point(x, y) {
	  x = project(x, y);
	  stream.point(x[0], x[1]);
	}

	function lineStart() {
	  x0 = NaN;
	  resampleStream.point = linePoint;
	  stream.lineStart();
	}

	function linePoint(lambda, phi) {
	  var c = cartesian_cartesian([lambda, phi]), p = project(lambda, phi);
	  resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	  stream.point(x0, y0);
	}

	function lineEnd() {
	  resampleStream.point = point;
	  stream.lineEnd();
	}

	function ringStart() {
	  lineStart();
	  resampleStream.point = ringPoint;
	  resampleStream.lineEnd = ringEnd;
	}

	function ringPoint(lambda, phi) {
	  linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	  resampleStream.point = linePoint;
	}

	function ringEnd() {
	  resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
	  resampleStream.lineEnd = lineEnd;
	  lineEnd();
	}

	return resampleStream;
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/index.js

var transformRadians = transformer({
point: function(x, y) {
	this.stream.point(x * radians, y * radians);
}
});

function transformRotate(rotate) {
return transformer({
	point: function(x, y) {
	  var r = rotate(x, y);
	  return this.stream.point(r[0], r[1]);
	}
});
}

function scaleTranslate(k, dx, dy) {
function transform(x, y) {
	return [dx + k * x, dy - k * y];
}
transform.invert = function(x, y) {
	return [(x - dx) / k, (dy - y) / k];
};
return transform;
}

function scaleTranslateRotate(k, dx, dy, alpha) {
var cosAlpha = math_cos(alpha),
	  sinAlpha = math_sin(alpha),
	  a = cosAlpha * k,
	  b = sinAlpha * k,
	  ai = cosAlpha / k,
	  bi = sinAlpha / k,
	  ci = (sinAlpha * dy - cosAlpha * dx) / k,
	  fi = (sinAlpha * dx + cosAlpha * dy) / k;
function transform(x, y) {
	return [a * x - b * y + dx, dy - b * x - a * y];
}
transform.invert = function(x, y) {
	return [ai * x - bi * y + ci, fi - bi * x - ai * y];
};
return transform;
}

function projection_projection(project) {
return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
var project,
	  k = 150, // scale
	  x = 480, y = 250, // translate
	  lambda = 0, phi = 0, // center
	  deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
	  alpha = 0, // post-rotate
	  theta = null, preclip = clip_antimeridian, // pre-clip angle
	  x0 = null, y0, x1, y1, postclip = d3_geo_src_identity, // post-clip extent
	  delta2 = 0.5, // precision
	  projectResample,
	  projectTransform,
	  projectRotateTransform,
	  cache,
	  cacheStream;

function projection(point) {
	return projectRotateTransform(point[0] * radians, point[1] * radians);
}

function invert(point) {
	point = projectRotateTransform.invert(point[0], point[1]);
	return point && [point[0] * math_degrees, point[1] * math_degrees];
}

projection.stream = function(stream) {
	return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
};

projection.preclip = function(_) {
	return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
};

projection.postclip = function(_) {
	return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
};

projection.clipAngle = function(_) {
	return arguments.length ? (preclip = +_ ? clip_circle(theta = _ * radians) : (theta = null, clip_antimeridian), reset()) : theta * math_degrees;
};

projection.clipExtent = function(_) {
	return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, d3_geo_src_identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
};

projection.scale = function(_) {
	return arguments.length ? (k = +_, recenter()) : k;
};

projection.translate = function(_) {
	return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
};

projection.center = function(_) {
	return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * math_degrees, phi * math_degrees];
};

projection.rotate = function(_) {
	return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * math_degrees, deltaPhi * math_degrees, deltaGamma * math_degrees];
};

projection.angle = function(_) {
	return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * math_degrees;
};

projection.precision = function(_) {
	return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
};

projection.fitExtent = function(extent, object) {
	return fitExtent(projection, extent, object);
};

projection.fitSize = function(size, object) {
	return fitSize(projection, size, object);
};

projection.fitWidth = function(width, object) {
	return fitWidth(projection, width, object);
};

projection.fitHeight = function(height, object) {
	return fitHeight(projection, height, object);
};

function recenter() {
	var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
		transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
	rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
	projectTransform = compose(project, transform);
	projectRotateTransform = compose(rotate, projectTransform);
	projectResample = resample(projectTransform, delta2);
	return reset();
}

function reset() {
	cache = cacheStream = null;
	return projection;
}

return function() {
	project = projectAt.apply(this, arguments);
	projection.invert = project.invert && invert;
	return recenter();
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/conic.js

function conicProjection(projectAt) {
var phi0 = 0,
	  phi1 = src_math_pi / 3,
	  m = projectionMutator(projectAt),
	  p = m(phi0, phi1);

p.parallels = function(_) {
	return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * math_degrees, phi1 * math_degrees];
};

return p;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/cylindricalEqualArea.js

function cylindricalEqualAreaRaw(phi0) {
var cosPhi0 = math_cos(phi0);

function forward(lambda, phi) {
	return [lambda * cosPhi0, math_sin(phi) / cosPhi0];
}

forward.invert = function(x, y) {
	return [x / cosPhi0, asin(y * cosPhi0)];
};

return forward;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/conicEqualArea.js

function conicEqualAreaRaw(y0, y1) {
var sy0 = math_sin(y0), n = (sy0 + math_sin(y1)) / 2;

// Are the parallels symmetrical around the Equator?
if (abs(n) < math_epsilon) return cylindricalEqualAreaRaw(y0);

var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

function project(x, y) {
	var r = sqrt(c - 2 * n * math_sin(y)) / n;
	return [r * math_sin(x *= n), r0 - r * math_cos(x)];
}

project.invert = function(x, y) {
	var r0y = r0 - y;
	return [atan2(x, abs(r0y)) / n * math_sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
};

return project;
}

/* harmony default export */ var conicEqualArea = (function() {
return conicProjection(conicEqualAreaRaw)
	  .scale(155.424)
	  .center([0, 33.6442]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/albers.js

/* harmony default export */ var albers = (function() {
return conicEqualArea()
	  .parallels([29.5, 45.5])
	  .scale(1070)
	  .translate([480, 250])
	  .rotate([96, 0])
	  .center([-0.6, 38.7]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/albersUsa.js

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
var n = streams.length;
return {
	point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
	sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
	lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
	lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
	polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
	polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
};
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ var projection_albersUsa = (function() {
var cache,
	  cacheStream,
	  lower48 = albers(), lower48Point,
	  alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
	  hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
	  point, pointStream = {point: function(x, y) { point = [x, y]; }};

function albersUsa(coordinates) {
	var x = coordinates[0], y = coordinates[1];
	return point = null,
		(lower48Point.point(x, y), point)
		|| (alaskaPoint.point(x, y), point)
		|| (hawaiiPoint.point(x, y), point);
}

albersUsa.invert = function(coordinates) {
	var k = lower48.scale(),
		t = lower48.translate(),
		x = (coordinates[0] - t[0]) / k,
		y = (coordinates[1] - t[1]) / k;
	return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
		: y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
		: lower48).invert(coordinates);
};

albersUsa.stream = function(stream) {
	return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
};

albersUsa.precision = function(_) {
	if (!arguments.length) return lower48.precision();
	lower48.precision(_), alaska.precision(_), hawaii.precision(_);
	return reset();
};

albersUsa.scale = function(_) {
	if (!arguments.length) return lower48.scale();
	lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
	return albersUsa.translate(lower48.translate());
};

albersUsa.translate = function(_) {
	if (!arguments.length) return lower48.translate();
	var k = lower48.scale(), x = +_[0], y = +_[1];

	lower48Point = lower48
		.translate(_)
		.clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
		.stream(pointStream);

	alaskaPoint = alaska
		.translate([x - 0.307 * k, y + 0.201 * k])
		.clipExtent([[x - 0.425 * k + math_epsilon, y + 0.120 * k + math_epsilon], [x - 0.214 * k - math_epsilon, y + 0.234 * k - math_epsilon]])
		.stream(pointStream);

	hawaiiPoint = hawaii
		.translate([x - 0.205 * k, y + 0.212 * k])
		.clipExtent([[x - 0.214 * k + math_epsilon, y + 0.166 * k + math_epsilon], [x - 0.115 * k - math_epsilon, y + 0.234 * k - math_epsilon]])
		.stream(pointStream);

	return reset();
};

albersUsa.fitExtent = function(extent, object) {
	return fitExtent(albersUsa, extent, object);
};

albersUsa.fitSize = function(size, object) {
	return fitSize(albersUsa, size, object);
};

albersUsa.fitWidth = function(width, object) {
	return fitWidth(albersUsa, width, object);
};

albersUsa.fitHeight = function(height, object) {
	return fitHeight(albersUsa, height, object);
};

function reset() {
	cache = cacheStream = null;
	return albersUsa;
}

return albersUsa.scale(1070);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/azimuthal.js

function azimuthalRaw(scale) {
return function(x, y) {
	var cx = math_cos(x),
		cy = math_cos(y),
		k = scale(cx * cy);
	return [
	  k * cy * math_sin(x),
	  k * math_sin(y)
	];
}
}

function azimuthalInvert(angle) {
return function(x, y) {
	var z = sqrt(x * x + y * y),
		c = angle(z),
		sc = math_sin(c),
		cc = math_cos(c);
	return [
	  atan2(x * sc, z * cc),
	  asin(z && y * sc / z)
	];
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/azimuthalEqualArea.js

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
return 2 * asin(z / 2);
});

/* harmony default export */ var azimuthalEqualArea = (function() {
return projection_projection(azimuthalEqualAreaRaw)
	  .scale(124.75)
	  .clipAngle(180 - 1e-3);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/azimuthalEquidistant.js

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
return (c = acos(c)) && c / math_sin(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
return z;
});

/* harmony default export */ var azimuthalEquidistant = (function() {
return projection_projection(azimuthalEquidistantRaw)
	  .scale(79.4188)
	  .clipAngle(180 - 1e-3);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/mercator.js

function mercatorRaw(lambda, phi) {
return [lambda, log(tan((src_math_halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
return [x, 2 * atan(exp(y)) - src_math_halfPi];
};

/* harmony default export */ var mercator = (function() {
return mercatorProjection(mercatorRaw)
	  .scale(961 / src_math_tau);
});

function mercatorProjection(project) {
var m = projection_projection(project),
	  center = m.center,
	  scale = m.scale,
	  translate = m.translate,
	  clipExtent = m.clipExtent,
	  x0 = null, y0, x1, y1; // clip extent

m.scale = function(_) {
	return arguments.length ? (scale(_), reclip()) : scale();
};

m.translate = function(_) {
	return arguments.length ? (translate(_), reclip()) : translate();
};

m.center = function(_) {
	return arguments.length ? (center(_), reclip()) : center();
};

m.clipExtent = function(_) {
	return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
};

function reclip() {
	var k = src_math_pi * scale(),
		t = m(src_rotation(m.rotate()).invert([0, 0]));
	return clipExtent(x0 == null
		? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
		? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
		: [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
}

return reclip();
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/conicConformal.js

function tany(y) {
return tan((src_math_halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
var cy0 = math_cos(y0),
	  n = y0 === y1 ? math_sin(y0) : log(cy0 / math_cos(y1)) / log(tany(y1) / tany(y0)),
	  f = cy0 * pow(tany(y0), n) / n;

if (!n) return mercatorRaw;

function project(x, y) {
	if (f > 0) { if (y < -src_math_halfPi + math_epsilon) y = -src_math_halfPi + math_epsilon; }
	else { if (y > src_math_halfPi - math_epsilon) y = src_math_halfPi - math_epsilon; }
	var r = f / pow(tany(y), n);
	return [r * math_sin(n * x), f - r * math_cos(n * x)];
}

project.invert = function(x, y) {
	var fy = f - y, r = math_sign(n) * sqrt(x * x + fy * fy);
	return [atan2(x, abs(fy)) / n * math_sign(fy), 2 * atan(pow(f / r, 1 / n)) - src_math_halfPi];
};

return project;
}

/* harmony default export */ var conicConformal = (function() {
return conicProjection(conicConformalRaw)
	  .scale(109.5)
	  .parallels([30, 30]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/equirectangular.js

function equirectangularRaw(lambda, phi) {
return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ var equirectangular = (function() {
return projection_projection(equirectangularRaw)
	  .scale(152.63);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/conicEquidistant.js

function conicEquidistantRaw(y0, y1) {
var cy0 = math_cos(y0),
	  n = y0 === y1 ? math_sin(y0) : (cy0 - math_cos(y1)) / (y1 - y0),
	  g = cy0 / n + y0;

if (abs(n) < math_epsilon) return equirectangularRaw;

function project(x, y) {
	var gy = g - y, nx = n * x;
	return [gy * math_sin(nx), g - gy * math_cos(nx)];
}

project.invert = function(x, y) {
	var gy = g - y;
	return [atan2(x, abs(gy)) / n * math_sign(gy), g - math_sign(n) * sqrt(x * x + gy * gy)];
};

return project;
}

/* harmony default export */ var conicEquidistant = (function() {
return conicProjection(conicEquidistantRaw)
	  .scale(131.154)
	  .center([0, 13.9389]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/gnomonic.js

function gnomonicRaw(x, y) {
var cy = math_cos(y), k = math_cos(x) * cy;
return [cy * math_sin(x) / k, math_sin(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

/* harmony default export */ var gnomonic = (function() {
return projection_projection(gnomonicRaw)
	  .scale(144.049)
	  .clipAngle(60);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/identity.js

function identity_scaleTranslate(kx, ky, tx, ty) {
return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? d3_geo_src_identity : transformer({
	point: function(x, y) {
	  this.stream.point(x * kx + tx, y * ky + ty);
	}
});
}

/* harmony default export */ var projection_identity = (function() {
var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = d3_geo_src_identity, // scale, translate and reflect
	  x0 = null, y0, x1, y1, // clip extent
	  postclip = d3_geo_src_identity,
	  cache,
	  cacheStream,
	  projection;

function reset() {
	cache = cacheStream = null;
	return projection;
}

return projection = {
	stream: function(stream) {
	  return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
	},
	postclip: function(_) {
	  return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	},
	clipExtent: function(_) {
	  return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, d3_geo_src_identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	},
	scale: function(_) {
	  return arguments.length ? (transform = identity_scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
	},
	translate: function(_) {
	  return arguments.length ? (transform = identity_scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
	},
	reflectX: function(_) {
	  return arguments.length ? (transform = identity_scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
	},
	reflectY: function(_) {
	  return arguments.length ? (transform = identity_scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
	},
	fitExtent: function(extent, object) {
	  return fitExtent(projection, extent, object);
	},
	fitSize: function(size, object) {
	  return fitSize(projection, size, object);
	},
	fitWidth: function(width, object) {
	  return fitWidth(projection, width, object);
	},
	fitHeight: function(height, object) {
	  return fitHeight(projection, height, object);
	}
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/naturalEarth1.js

function naturalEarth1Raw(lambda, phi) {
var phi2 = phi * phi, phi4 = phi2 * phi2;
return [
	lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
	phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
];
}

naturalEarth1Raw.invert = function(x, y) {
var phi = y, i = 25, delta;
do {
	var phi2 = phi * phi, phi4 = phi2 * phi2;
	phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
		(1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
} while (abs(delta) > math_epsilon && --i > 0);
return [
	x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
	phi
];
};

/* harmony default export */ var naturalEarth1 = (function() {
return projection_projection(naturalEarth1Raw)
	  .scale(175.295);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/orthographic.js

function orthographicRaw(x, y) {
return [math_cos(y) * math_sin(x), math_sin(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

/* harmony default export */ var orthographic = (function() {
return projection_projection(orthographicRaw)
	  .scale(249.5)
	  .clipAngle(90 + math_epsilon);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/stereographic.js

function stereographicRaw(x, y) {
var cy = math_cos(y), k = 1 + math_cos(x) * cy;
return [cy * math_sin(x) / k, math_sin(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
return 2 * atan(z);
});

/* harmony default export */ var stereographic = (function() {
return projection_projection(stereographicRaw)
	  .scale(250)
	  .clipAngle(142);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/src/projection/transverseMercator.js

function transverseMercatorRaw(lambda, phi) {
return [log(tan((src_math_halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
return [-y, 2 * atan(exp(x)) - src_math_halfPi];
};

/* harmony default export */ var transverseMercator = (function() {
var m = mercatorProjection(transverseMercatorRaw),
	  center = m.center,
	  rotate = m.rotate;

m.center = function(_) {
	return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
};

m.rotate = function(_) {
	return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
};

return rotate([0, 0, 90])
	  .scale(159.155);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-geo/index.js

// DEPRECATED! Use d3.geoIdentity().clipExtent(…).

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a, b) {
return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
return x + c.x;
}

function maxY(children) {
return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
return Math.max(y, c.y);
}

function leafLeft(node) {
var children;
while (children = node.children) node = children[0];
return node;
}

function leafRight(node) {
var children;
while (children = node.children) node = children[children.length - 1];
return node;
}

/* harmony default export */ var cluster = (function() {
var separation = defaultSeparation,
	  dx = 1,
	  dy = 1,
	  nodeSize = false;

function cluster(root) {
	var previousNode,
		x = 0;

	// First walk, computing the initial x & y values.
	root.eachAfter(function(node) {
	  var children = node.children;
	  if (children) {
		node.x = meanX(children);
		node.y = maxY(children);
	  } else {
		node.x = previousNode ? x += separation(node, previousNode) : 0;
		node.y = 0;
		previousNode = node;
	  }
	});

	var left = leafLeft(root),
		right = leafRight(root),
		x0 = left.x - separation(left, right) / 2,
		x1 = right.x + separation(right, left) / 2;

	// Second walk, normalizing x & y to the desired size.
	return root.eachAfter(nodeSize ? function(node) {
	  node.x = (node.x - root.x) * dx;
	  node.y = (root.y - node.y) * dy;
	} : function(node) {
	  node.x = (node.x - x0) / (x1 - x0) * dx;
	  node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
	});
}

cluster.separation = function(x) {
	return arguments.length ? (separation = x, cluster) : separation;
};

cluster.size = function(x) {
	return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
};

cluster.nodeSize = function(x) {
	return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
};

return cluster;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/count.js
function count_count(node) {
var sum = 0,
	  children = node.children,
	  i = children && children.length;
if (!i) sum = 1;
else while (--i >= 0) sum += children[i].value;
node.value = sum;
}

/* harmony default export */ var hierarchy_count = (function() {
return this.eachAfter(count_count);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/each.js
/* harmony default export */ var hierarchy_each = (function(callback) {
var node = this, current, next = [node], children, i, n;
do {
	current = next.reverse(), next = [];
	while (node = current.pop()) {
	  callback(node), children = node.children;
	  if (children) for (i = 0, n = children.length; i < n; ++i) {
		next.push(children[i]);
	  }
	}
} while (next.length);
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
/* harmony default export */ var eachBefore = (function(callback) {
var node = this, nodes = [node], children, i;
while (node = nodes.pop()) {
	callback(node), children = node.children;
	if (children) for (i = children.length - 1; i >= 0; --i) {
	  nodes.push(children[i]);
	}
}
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
/* harmony default export */ var eachAfter = (function(callback) {
var node = this, nodes = [node], next = [], children, i, n;
while (node = nodes.pop()) {
	next.push(node), children = node.children;
	if (children) for (i = 0, n = children.length; i < n; ++i) {
	  nodes.push(children[i]);
	}
}
while (node = next.pop()) {
	callback(node);
}
return this;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/sum.js
/* harmony default export */ var hierarchy_sum = (function(value) {
return this.eachAfter(function(node) {
	var sum = +value(node.data) || 0,
		children = node.children,
		i = children && children.length;
	while (--i >= 0) sum += children[i].value;
	node.value = sum;
});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/sort.js
/* harmony default export */ var hierarchy_sort = (function(compare) {
return this.eachBefore(function(node) {
	if (node.children) {
	  node.children.sort(compare);
	}
});
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/path.js
/* harmony default export */ var hierarchy_path = (function(end) {
var start = this,
	  ancestor = leastCommonAncestor(start, end),
	  nodes = [start];
while (start !== ancestor) {
	start = start.parent;
	nodes.push(start);
}
var k = nodes.length;
while (end !== ancestor) {
	nodes.splice(k, 0, end);
	end = end.parent;
}
return nodes;
});

function leastCommonAncestor(a, b) {
if (a === b) return a;
var aNodes = a.ancestors(),
	  bNodes = b.ancestors(),
	  c = null;
a = aNodes.pop();
b = bNodes.pop();
while (a === b) {
	c = a;
	a = aNodes.pop();
	b = bNodes.pop();
}
return c;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
/* harmony default export */ var ancestors = (function() {
var node = this, nodes = [node];
while (node = node.parent) {
	nodes.push(node);
}
return nodes;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/descendants.js
/* harmony default export */ var descendants = (function() {
var nodes = [];
this.each(function(node) {
	nodes.push(node);
});
return nodes;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/leaves.js
/* harmony default export */ var leaves = (function() {
var leaves = [];
this.eachBefore(function(node) {
	if (!node.children) {
	  leaves.push(node);
	}
});
return leaves;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/links.js
/* harmony default export */ var hierarchy_links = (function() {
var root = this, links = [];
root.each(function(node) {
	if (node !== root) { // Don’t include the root’s parent, if any.
	  links.push({source: node.parent, target: node});
	}
});
return links;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/hierarchy/index.js

function hierarchy(data, children) {
var root = new Node(data),
	  valued = +data.value && (root.value = data.value),
	  node,
	  nodes = [root],
	  child,
	  childs,
	  i,
	  n;

if (children == null) children = defaultChildren;

while (node = nodes.pop()) {
	if (valued) node.value = +node.data.value;
	if ((childs = children(node.data)) && (n = childs.length)) {
	  node.children = new Array(n);
	  for (i = n - 1; i >= 0; --i) {
		nodes.push(child = node.children[i] = new Node(childs[i]));
		child.parent = node;
		child.depth = node.depth + 1;
	  }
	}
}

return root.eachBefore(computeHeight);
}

function node_copy() {
return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
return d.children;
}

function copyData(node) {
node.data = node.data.data;
}

function computeHeight(node) {
var height = 0;
do node.height = height;
while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
this.data = data;
this.depth =
this.height = 0;
this.parent = null;
}

Node.prototype = hierarchy.prototype = {
constructor: Node,
count: hierarchy_count,
each: hierarchy_each,
eachAfter: eachAfter,
eachBefore: eachBefore,
sum: hierarchy_sum,
sort: hierarchy_sort,
path: hierarchy_path,
ancestors: ancestors,
descendants: descendants,
leaves: leaves,
links: hierarchy_links,
copy: node_copy
};

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/array.js
var d3_hierarchy_src_array_slice = Array.prototype.slice;

function array_shuffle(array) {
var m = array.length,
	  t,
	  i;

while (m) {
	i = Math.random() * m-- | 0;
	t = array[m];
	array[m] = array[i];
	array[i] = t;
}

return array;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/pack/enclose.js

/* harmony default export */ var enclose = (function(circles) {
var i = 0, n = (circles = array_shuffle(d3_hierarchy_src_array_slice.call(circles))).length, B = [], p, e;

while (i < n) {
	p = circles[i];
	if (e && enclosesWeak(e, p)) ++i;
	else e = encloseBasis(B = extendBasis(B, p)), i = 0;
}

return e;
});

function extendBasis(B, p) {
var i, j;

if (enclosesWeakAll(p, B)) return [p];

// If we get here then B must have at least one element.
for (i = 0; i < B.length; ++i) {
	if (enclosesNot(p, B[i])
		&& enclosesWeakAll(encloseBasis2(B[i], p), B)) {
	  return [B[i], p];
	}
}

// If we get here then B must have at least two elements.
for (i = 0; i < B.length - 1; ++i) {
	for (j = i + 1; j < B.length; ++j) {
	  if (enclosesNot(encloseBasis2(B[i], B[j]), p)
		  && enclosesNot(encloseBasis2(B[i], p), B[j])
		  && enclosesNot(encloseBasis2(B[j], p), B[i])
		  && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
		return [B[i], B[j], p];
	  }
	}
}

// If we get here then something is very wrong.
throw new Error;
}

function enclosesNot(a, b) {
var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
for (var i = 0; i < B.length; ++i) {
	if (!enclosesWeak(a, B[i])) {
	  return false;
	}
}
return true;
}

function encloseBasis(B) {
switch (B.length) {
	case 1: return encloseBasis1(B[0]);
	case 2: return encloseBasis2(B[0], B[1]);
	case 3: return encloseBasis3(B[0], B[1], B[2]);
}
}

function encloseBasis1(a) {
return {
	x: a.x,
	y: a.y,
	r: a.r
};
}

function encloseBasis2(a, b) {
var x1 = a.x, y1 = a.y, r1 = a.r,
	  x2 = b.x, y2 = b.y, r2 = b.r,
	  x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
	  l = Math.sqrt(x21 * x21 + y21 * y21);
return {
	x: (x1 + x2 + x21 / l * r21) / 2,
	y: (y1 + y2 + y21 / l * r21) / 2,
	r: (l + r1 + r2) / 2
};
}

function encloseBasis3(a, b, c) {
var x1 = a.x, y1 = a.y, r1 = a.r,
	  x2 = b.x, y2 = b.y, r2 = b.r,
	  x3 = c.x, y3 = c.y, r3 = c.r,
	  a2 = x1 - x2,
	  a3 = x1 - x3,
	  b2 = y1 - y2,
	  b3 = y1 - y3,
	  c2 = r2 - r1,
	  c3 = r3 - r1,
	  d1 = x1 * x1 + y1 * y1 - r1 * r1,
	  d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
	  d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
	  ab = a3 * b2 - a2 * b3,
	  xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
	  xb = (b3 * c2 - b2 * c3) / ab,
	  ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
	  yb = (a2 * c3 - a3 * c2) / ab,
	  A = xb * xb + yb * yb - 1,
	  B = 2 * (r1 + xa * xb + ya * yb),
	  C = xa * xa + ya * ya - r1 * r1,
	  r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
return {
	x: x1 + xa + xb * r,
	y: y1 + ya + yb * r,
	r: r
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/pack/siblings.js

function place(a, b, c) {
var ax = a.x,
	  ay = a.y,
	  da = b.r + c.r,
	  db = a.r + c.r,
	  dx = b.x - ax,
	  dy = b.y - ay,
	  dc = dx * dx + dy * dy;
if (dc) {
	var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
		y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	c.x = ax + x * dx + y * dy;
	c.y = ay + x * dy - y * dx;
} else {
	c.x = ax + db;
	c.y = ay;
}
}

function intersects(a, b) {
var dx = b.x - a.x,
	  dy = b.y - a.y,
	  dr = a.r + b.r;
return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
var a = node._,
	  b = node.next._,
	  ab = a.r + b.r,
	  dx = (a.x * b.r + b.x * a.r) / ab,
	  dy = (a.y * b.r + b.y * a.r) / ab;
return dx * dx + dy * dy;
}

function siblings_Node(circle) {
this._ = circle;
this.next = null;
this.previous = null;
}

function packEnclose(circles) {
if (!(n = circles.length)) return 0;

var a, b, c, n, aa, ca, i, j, k, sj, sk;

// Place the first circle.
a = circles[0], a.x = 0, a.y = 0;
if (!(n > 1)) return a.r;

// Place the second circle.
b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
if (!(n > 2)) return a.r + b.r;

// Place the third circle.
place(b, a, c = circles[2]);

// Initialize the front-chain using the first three circles a, b and c.
a = new siblings_Node(a), b = new siblings_Node(b), c = new siblings_Node(c);
a.next = c.previous = b;
b.next = a.previous = c;
c.next = b.previous = a;

// Attempt to place each remaining circle…
pack: for (i = 3; i < n; ++i) {
	place(a._, b._, c = circles[i]), c = new siblings_Node(c);

	// Find the closest intersecting circle on the front-chain, if any.
	// “Closeness” is determined by linear distance along the front-chain.
	// “Ahead” or “behind” is likewise determined by linear distance.
	j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
	do {
	  if (sj <= sk) {
		if (intersects(j._, c._)) {
		  b = j, a.next = b, b.previous = a, --i;
		  continue pack;
		}
		sj += j._.r, j = j.next;
	  } else {
		if (intersects(k._, c._)) {
		  a = k, a.next = b, b.previous = a, --i;
		  continue pack;
		}
		sk += k._.r, k = k.previous;
	  }
	} while (j !== k.next);

	// Success! Insert the new circle c between a and b.
	c.previous = a, c.next = b, a.next = b.previous = b = c;

	// Compute the new closest circle pair to the centroid.
	aa = score(a);
	while ((c = c.next) !== b) {
	  if ((ca = score(c)) < aa) {
		a = c, aa = ca;
	  }
	}
	b = a.next;
}

// Compute the enclosing circle of the front chain.
a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

// Translate the circles to put the enclosing circle around the origin.
for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

return c.r;
}

/* harmony default export */ var siblings = (function(circles) {
packEnclose(circles);
return circles;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
return f == null ? null : required(f);
}

function required(f) {
if (typeof f !== "function") throw new Error;
return f;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/constant.js
function constantZero() {
return 0;
}

/* harmony default export */ var d3_hierarchy_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/pack/index.js

function pack_defaultRadius(d) {
return Math.sqrt(d.value);
}

/* harmony default export */ var src_pack = (function() {
var radius = null,
	  dx = 1,
	  dy = 1,
	  padding = constantZero;

function pack(root) {
	root.x = dx / 2, root.y = dy / 2;
	if (radius) {
	  root.eachBefore(radiusLeaf(radius))
		  .eachAfter(packChildren(padding, 0.5))
		  .eachBefore(translateChild(1));
	} else {
	  root.eachBefore(radiusLeaf(pack_defaultRadius))
		  .eachAfter(packChildren(constantZero, 1))
		  .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
		  .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
	}
	return root;
}

pack.radius = function(x) {
	return arguments.length ? (radius = optional(x), pack) : radius;
};

pack.size = function(x) {
	return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
};

pack.padding = function(x) {
	return arguments.length ? (padding = typeof x === "function" ? x : d3_hierarchy_src_constant(+x), pack) : padding;
};

return pack;
});

function radiusLeaf(radius) {
return function(node) {
	if (!node.children) {
	  node.r = Math.max(0, +radius(node) || 0);
	}
};
}

function packChildren(padding, k) {
return function(node) {
	if (children = node.children) {
	  var children,
		  i,
		  n = children.length,
		  r = padding(node) * k || 0,
		  e;

	  if (r) for (i = 0; i < n; ++i) children[i].r += r;
	  e = packEnclose(children);
	  if (r) for (i = 0; i < n; ++i) children[i].r -= r;
	  node.r = e + r;
	}
};
}

function translateChild(k) {
return function(node) {
	var parent = node.parent;
	node.r *= k;
	if (parent) {
	  node.x = parent.x + k * node.x;
	  node.y = parent.y + k * node.y;
	}
};
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/round.js
/* harmony default export */ var treemap_round = (function(node) {
node.x0 = Math.round(node.x0);
node.y0 = Math.round(node.y0);
node.x1 = Math.round(node.x1);
node.y1 = Math.round(node.y1);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/dice.js
/* harmony default export */ var dice = (function(parent, x0, y0, x1, y1) {
var nodes = parent.children,
	  node,
	  i = -1,
	  n = nodes.length,
	  k = parent.value && (x1 - x0) / parent.value;

while (++i < n) {
	node = nodes[i], node.y0 = y0, node.y1 = y1;
	node.x0 = x0, node.x1 = x0 += node.value * k;
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/partition.js

/* harmony default export */ var src_partition = (function() {
var dx = 1,
	  dy = 1,
	  padding = 0,
	  round = false;

function partition(root) {
	var n = root.height + 1;
	root.x0 =
	root.y0 = padding;
	root.x1 = dx;
	root.y1 = dy / n;
	root.eachBefore(positionNode(dy, n));
	if (round) root.eachBefore(treemap_round);
	return root;
}

function positionNode(dy, n) {
	return function(node) {
	  if (node.children) {
		dice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
	  }
	  var x0 = node.x0,
		  y0 = node.y0,
		  x1 = node.x1 - padding,
		  y1 = node.y1 - padding;
	  if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	  if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	  node.x0 = x0;
	  node.y0 = y0;
	  node.x1 = x1;
	  node.y1 = y1;
	};
}

partition.round = function(x) {
	return arguments.length ? (round = !!x, partition) : round;
};

partition.size = function(x) {
	return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
};

partition.padding = function(x) {
	return arguments.length ? (padding = +x, partition) : padding;
};

return partition;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/stratify.js

var stratify_keyPrefix = "$", // Protect against keys like “__proto__”.
	preroot = {depth: -1},
	ambiguous = {};

function defaultId(d) {
return d.id;
}

function defaultParentId(d) {
return d.parentId;
}

/* harmony default export */ var src_stratify = (function() {
var id = defaultId,
	  parentId = defaultParentId;

function stratify(data) {
	var d,
		i,
		n = data.length,
		root,
		parent,
		node,
		nodes = new Array(n),
		nodeId,
		nodeKey,
		nodeByKey = {};

	for (i = 0; i < n; ++i) {
	  d = data[i], node = nodes[i] = new Node(d);
	  if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
		nodeKey = stratify_keyPrefix + (node.id = nodeId);
		nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
	  }
	}

	for (i = 0; i < n; ++i) {
	  node = nodes[i], nodeId = parentId(data[i], i, data);
	  if (nodeId == null || !(nodeId += "")) {
		if (root) throw new Error("multiple roots");
		root = node;
	  } else {
		parent = nodeByKey[stratify_keyPrefix + nodeId];
		if (!parent) throw new Error("missing: " + nodeId);
		if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
		if (parent.children) parent.children.push(node);
		else parent.children = [node];
		node.parent = parent;
	  }
	}

	if (!root) throw new Error("no root");
	root.parent = preroot;
	root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
	root.parent = null;
	if (n > 0) throw new Error("cycle");

	return root;
}

stratify.id = function(x) {
	return arguments.length ? (id = required(x), stratify) : id;
};

stratify.parentId = function(x) {
	return arguments.length ? (parentId = required(x), stratify) : parentId;
};

return stratify;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/tree.js

function tree_defaultSeparation(a, b) {
return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
var children = v.children;
return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
var children = v.children;
return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
var change = shift / (wp.i - wm.i);
wp.c -= change;
wp.s += shift;
wm.c += change;
wp.z += shift;
wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
var shift = 0,
	  change = 0,
	  children = v.children,
	  i = children.length,
	  w;
while (--i >= 0) {
	w = children[i];
	w.z += shift;
	w.m += shift;
	shift += w.s + (change += w.c);
}
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
this._ = node;
this.parent = null;
this.children = null;
this.A = null; // default ancestor
this.a = this; // ancestor
this.z = 0; // prelim
this.m = 0; // mod
this.c = 0; // change
this.s = 0; // shift
this.t = null; // thread
this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
var tree = new TreeNode(root, 0),
	  node,
	  nodes = [tree],
	  child,
	  children,
	  i,
	  n;

while (node = nodes.pop()) {
	if (children = node._.children) {
	  node.children = new Array(n = children.length);
	  for (i = n - 1; i >= 0; --i) {
		nodes.push(child = node.children[i] = new TreeNode(children[i], i));
		child.parent = node;
	  }
	}
}

(tree.parent = new TreeNode(null, 0)).children = [tree];
return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ var src_tree = (function() {
var separation = tree_defaultSeparation,
	  dx = 1,
	  dy = 1,
	  nodeSize = null;

function tree(root) {
	var t = treeRoot(root);

	// Compute the layout using Buchheim et al.’s algorithm.
	t.eachAfter(firstWalk), t.parent.m = -t.z;
	t.eachBefore(secondWalk);

	// If a fixed node size is specified, scale x and y.
	if (nodeSize) root.eachBefore(sizeNode);

	// If a fixed tree size is specified, scale x and y based on the extent.
	// Compute the left-most, right-most, and depth-most nodes for extents.
	else {
	  var left = root,
		  right = root,
		  bottom = root;
	  root.eachBefore(function(node) {
		if (node.x < left.x) left = node;
		if (node.x > right.x) right = node;
		if (node.depth > bottom.depth) bottom = node;
	  });
	  var s = left === right ? 1 : separation(left, right) / 2,
		  tx = s - left.x,
		  kx = dx / (right.x + s + tx),
		  ky = dy / (bottom.depth || 1);
	  root.eachBefore(function(node) {
		node.x = (node.x + tx) * kx;
		node.y = node.depth * ky;
	  });
	}

	return root;
}

// Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
// applied recursively to the children of v, as well as the function
// APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
// node v is placed to the midpoint of its outermost children.
function firstWalk(v) {
	var children = v.children,
		siblings = v.parent.children,
		w = v.i ? siblings[v.i - 1] : null;
	if (children) {
	  executeShifts(v);
	  var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	  if (w) {
		v.z = w.z + separation(v._, w._);
		v.m = v.z - midpoint;
	  } else {
		v.z = midpoint;
	  }
	} else if (w) {
	  v.z = w.z + separation(v._, w._);
	}
	v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
}

// Computes all real x-coordinates by summing up the modifiers recursively.
function secondWalk(v) {
	v._.x = v.z + v.parent.m;
	v.m += v.parent.m;
}

// The core of the algorithm. Here, a new subtree is combined with the
// previous subtrees. Threads are used to traverse the inside and outside
// contours of the left and right subtree up to the highest common level. The
// vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
// superscript o means outside and i means inside, the subscript - means left
// subtree and + means right subtree. For summing up the modifiers along the
// contour, we use respective variables si+, si-, so-, and so+. Whenever two
// nodes of the inside contours conflict, we compute the left one of the
// greatest uncommon ancestors using the function ANCESTOR and call MOVE
// SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
// Finally, we add a new thread (if necessary).
function apportion(v, w, ancestor) {
	if (w) {
	  var vip = v,
		  vop = v,
		  vim = w,
		  vom = vip.parent.children[0],
		  sip = vip.m,
		  sop = vop.m,
		  sim = vim.m,
		  som = vom.m,
		  shift;
	  while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
		vom = nextLeft(vom);
		vop = nextRight(vop);
		vop.a = v;
		shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
		if (shift > 0) {
		  moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
		  sip += shift;
		  sop += shift;
		}
		sim += vim.m;
		sip += vip.m;
		som += vom.m;
		sop += vop.m;
	  }
	  if (vim && !nextRight(vop)) {
		vop.t = vim;
		vop.m += sim - sop;
	  }
	  if (vip && !nextLeft(vom)) {
		vom.t = vip;
		vom.m += sip - som;
		ancestor = v;
	  }
	}
	return ancestor;
}

function sizeNode(node) {
	node.x *= dx;
	node.y = node.depth * dy;
}

tree.separation = function(x) {
	return arguments.length ? (separation = x, tree) : separation;
};

tree.size = function(x) {
	return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
};

tree.nodeSize = function(x) {
	return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
};

return tree;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/slice.js
/* harmony default export */ var treemap_slice = (function(parent, x0, y0, x1, y1) {
var nodes = parent.children,
	  node,
	  i = -1,
	  n = nodes.length,
	  k = parent.value && (y1 - y0) / parent.value;

while (++i < n) {
	node = nodes[i], node.x0 = x0, node.x1 = x1;
	node.y0 = y0, node.y1 = y0 += node.value * k;
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/squarify.js

var squarify_phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
var rows = [],
	  nodes = parent.children,
	  row,
	  nodeValue,
	  i0 = 0,
	  i1 = 0,
	  n = nodes.length,
	  dx, dy,
	  value = parent.value,
	  sumValue,
	  minValue,
	  maxValue,
	  newRatio,
	  minRatio,
	  alpha,
	  beta;

while (i0 < n) {
	dx = x1 - x0, dy = y1 - y0;

	// Find the next non-empty node.
	do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
	minValue = maxValue = sumValue;
	alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
	beta = sumValue * sumValue * alpha;
	minRatio = Math.max(maxValue / beta, beta / minValue);

	// Keep adding nodes while the aspect ratio maintains or improves.
	for (; i1 < n; ++i1) {
	  sumValue += nodeValue = nodes[i1].value;
	  if (nodeValue < minValue) minValue = nodeValue;
	  if (nodeValue > maxValue) maxValue = nodeValue;
	  beta = sumValue * sumValue * alpha;
	  newRatio = Math.max(maxValue / beta, beta / minValue);
	  if (newRatio > minRatio) { sumValue -= nodeValue; break; }
	  minRatio = newRatio;
	}

	// Position and record the row orientation.
	rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
	if (row.dice) dice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
	else treemap_slice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
	value -= sumValue, i0 = i1;
}

return rows;
}

/* harmony default export */ var squarify = ((function custom(ratio) {

function squarify(parent, x0, y0, x1, y1) {
	squarifyRatio(ratio, parent, x0, y0, x1, y1);
}

squarify.ratio = function(x) {
	return custom((x = +x) > 1 ? x : 1);
};

return squarify;
})(squarify_phi));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/index.js

/* harmony default export */ var src_treemap = (function() {
var tile = squarify,
	  round = false,
	  dx = 1,
	  dy = 1,
	  paddingStack = [0],
	  paddingInner = constantZero,
	  paddingTop = constantZero,
	  paddingRight = constantZero,
	  paddingBottom = constantZero,
	  paddingLeft = constantZero;

function treemap(root) {
	root.x0 =
	root.y0 = 0;
	root.x1 = dx;
	root.y1 = dy;
	root.eachBefore(positionNode);
	paddingStack = [0];
	if (round) root.eachBefore(treemap_round);
	return root;
}

function positionNode(node) {
	var p = paddingStack[node.depth],
		x0 = node.x0 + p,
		y0 = node.y0 + p,
		x1 = node.x1 - p,
		y1 = node.y1 - p;
	if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	node.x0 = x0;
	node.y0 = y0;
	node.x1 = x1;
	node.y1 = y1;
	if (node.children) {
	  p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
	  x0 += paddingLeft(node) - p;
	  y0 += paddingTop(node) - p;
	  x1 -= paddingRight(node) - p;
	  y1 -= paddingBottom(node) - p;
	  if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	  if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	  tile(node, x0, y0, x1, y1);
	}
}

treemap.round = function(x) {
	return arguments.length ? (round = !!x, treemap) : round;
};

treemap.size = function(x) {
	return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
};

treemap.tile = function(x) {
	return arguments.length ? (tile = required(x), treemap) : tile;
};

treemap.padding = function(x) {
	return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
};

treemap.paddingInner = function(x) {
	return arguments.length ? (paddingInner = typeof x === "function" ? x : d3_hierarchy_src_constant(+x), treemap) : paddingInner;
};

treemap.paddingOuter = function(x) {
	return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
};

treemap.paddingTop = function(x) {
	return arguments.length ? (paddingTop = typeof x === "function" ? x : d3_hierarchy_src_constant(+x), treemap) : paddingTop;
};

treemap.paddingRight = function(x) {
	return arguments.length ? (paddingRight = typeof x === "function" ? x : d3_hierarchy_src_constant(+x), treemap) : paddingRight;
};

treemap.paddingBottom = function(x) {
	return arguments.length ? (paddingBottom = typeof x === "function" ? x : d3_hierarchy_src_constant(+x), treemap) : paddingBottom;
};

treemap.paddingLeft = function(x) {
	return arguments.length ? (paddingLeft = typeof x === "function" ? x : d3_hierarchy_src_constant(+x), treemap) : paddingLeft;
};

return treemap;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/binary.js
/* harmony default export */ var binary = (function(parent, x0, y0, x1, y1) {
var nodes = parent.children,
	  i, n = nodes.length,
	  sum, sums = new Array(n + 1);

for (sums[0] = sum = i = 0; i < n; ++i) {
	sums[i + 1] = sum += nodes[i].value;
}

partition(0, n, parent.value, x0, y0, x1, y1);

function partition(i, j, value, x0, y0, x1, y1) {
	if (i >= j - 1) {
	  var node = nodes[i];
	  node.x0 = x0, node.y0 = y0;
	  node.x1 = x1, node.y1 = y1;
	  return;
	}

	var valueOffset = sums[i],
		valueTarget = (value / 2) + valueOffset,
		k = i + 1,
		hi = j - 1;

	while (k < hi) {
	  var mid = k + hi >>> 1;
	  if (sums[mid] < valueTarget) k = mid + 1;
	  else hi = mid;
	}

	if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

	var valueLeft = sums[k] - valueOffset,
		valueRight = value - valueLeft;

	if ((x1 - x0) > (y1 - y0)) {
	  var xk = (x0 * valueRight + x1 * valueLeft) / value;
	  partition(i, k, valueLeft, x0, y0, xk, y1);
	  partition(k, j, valueRight, xk, y0, x1, y1);
	} else {
	  var yk = (y0 * valueRight + y1 * valueLeft) / value;
	  partition(i, k, valueLeft, x0, y0, x1, yk);
	  partition(k, j, valueRight, x0, yk, x1, y1);
	}
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/sliceDice.js

/* harmony default export */ var sliceDice = (function(parent, x0, y0, x1, y1) {
(parent.depth & 1 ? treemap_slice : dice)(parent, x0, y0, x1, y1);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/src/treemap/resquarify.js

/* harmony default export */ var treemap_resquarify = ((function custom(ratio) {

function resquarify(parent, x0, y0, x1, y1) {
	if ((rows = parent._squarify) && (rows.ratio === ratio)) {
	  var rows,
		  row,
		  nodes,
		  i,
		  j = -1,
		  n,
		  m = rows.length,
		  value = parent.value;

	  while (++j < m) {
		row = rows[j], nodes = row.children;
		for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
		if (row.dice) dice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
		else treemap_slice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
		value -= row.value;
	  }
	} else {
	  parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
	  rows.ratio = ratio;
	}
}

resquarify.ratio = function(x) {
	return custom((x = +x) > 1 ? x : 1);
};

return resquarify;
})(squarify_phi));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-hierarchy/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/src/area.js
/* harmony default export */ var d3_polygon_src_area = (function(polygon) {
var i = -1,
	  n = polygon.length,
	  a,
	  b = polygon[n - 1],
	  area = 0;

while (++i < n) {
	a = b;
	b = polygon[i];
	area += a[1] * b[0] - a[0] * b[1];
}

return area / 2;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/src/centroid.js
/* harmony default export */ var d3_polygon_src_centroid = (function(polygon) {
var i = -1,
	  n = polygon.length,
	  x = 0,
	  y = 0,
	  a,
	  b = polygon[n - 1],
	  c,
	  k = 0;

while (++i < n) {
	a = b;
	b = polygon[i];
	k += c = a[0] * b[1] - b[0] * a[1];
	x += (a[0] + b[0]) * c;
	y += (a[1] + b[1]) * c;
}

return k *= 3, [x / k, y / k];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/src/cross.js
// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
/* harmony default export */ var src_cross = (function(a, b, c) {
return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/src/hull.js

function lexicographicOrder(a, b) {
return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
var n = points.length,
	  indexes = [0, 1],
	  size = 2;

for (var i = 2; i < n; ++i) {
	while (size > 1 && src_cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
	indexes[size++] = i;
}

return indexes.slice(0, size); // remove popped points
}

/* harmony default export */ var hull = (function(points) {
if ((n = points.length) < 3) return null;

var i,
	  n,
	  sortedPoints = new Array(n),
	  flippedPoints = new Array(n);

for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
sortedPoints.sort(lexicographicOrder);
for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

var upperIndexes = computeUpperHullIndexes(sortedPoints),
	  lowerIndexes = computeUpperHullIndexes(flippedPoints);

// Construct the hull polygon, removing possible duplicate endpoints.
var skipLeft = lowerIndexes[0] === upperIndexes[0],
	  skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
	  hull = [];

// Add upper hull in right-to-l order.
// Then add lower hull in left-to-right order.
for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

return hull;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/src/contains.js
/* harmony default export */ var d3_polygon_src_contains = (function(polygon, point) {
var n = polygon.length,
	  p = polygon[n - 1],
	  x = point[0], y = point[1],
	  x0 = p[0], y0 = p[1],
	  x1, y1,
	  inside = false;

for (var i = 0; i < n; ++i) {
	p = polygon[i], x1 = p[0], y1 = p[1];
	if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
	x0 = x1, y0 = y1;
}

return inside;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/src/length.js
/* harmony default export */ var d3_polygon_src_length = (function(polygon) {
var i = -1,
	  n = polygon.length,
	  b = polygon[n - 1],
	  xa,
	  ya,
	  xb = b[0],
	  yb = b[1],
	  perimeter = 0;

while (++i < n) {
	xa = xb;
	ya = yb;
	b = polygon[i];
	xb = b[0];
	yb = b[1];
	xa -= xb;
	ya -= yb;
	perimeter += Math.sqrt(xa * xa + ya * ya);
}

return perimeter;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-polygon/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/defaultSource.js
/* harmony default export */ var src_defaultSource = (function() {
return Math.random();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/uniform.js

/* harmony default export */ var uniform = ((function sourceRandomUniform(source) {
function randomUniform(min, max) {
	min = min == null ? 0 : +min;
	max = max == null ? 1 : +max;
	if (arguments.length === 1) max = min, min = 0;
	else max -= min;
	return function() {
	  return source() * max + min;
	};
}

randomUniform.source = sourceRandomUniform;

return randomUniform;
})(src_defaultSource));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/normal.js

/* harmony default export */ var src_normal = ((function sourceRandomNormal(source) {
function randomNormal(mu, sigma) {
	var x;
	var r;
	mu = mu == null ? 0 : +mu;
	sigma = sigma == null ? 1 : +sigma;
	return function() {
	  var y;

	  // If available, use the second previously-generated uniform random.
	  if (x != null) y = x, x = null;

	  // Otherwise, generate a new x and y.
	  else do {
		x = source() * 2 - 1;
		y = source() * 2 - 1;
		r = x * x + y * y;
	  } while (!r || r > 1);

	  return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
	};
}

randomNormal.source = sourceRandomNormal;

return randomNormal;
})(src_defaultSource));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/logNormal.js

/* harmony default export */ var logNormal = ((function sourceRandomLogNormal(source) {
function randomLogNormal() {
	var randomNormal = src_normal.source(source).apply(this, arguments);
	return function() {
	  return Math.exp(randomNormal());
	};
}

randomLogNormal.source = sourceRandomLogNormal;

return randomLogNormal;
})(src_defaultSource));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/irwinHall.js

/* harmony default export */ var irwinHall = ((function sourceRandomIrwinHall(source) {
function randomIrwinHall(n) {
	return function() {
	  for (var sum = 0, i = 0; i < n; ++i) sum += source();
	  return sum;
	};
}

randomIrwinHall.source = sourceRandomIrwinHall;

return randomIrwinHall;
})(src_defaultSource));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/bates.js

/* harmony default export */ var bates = ((function sourceRandomBates(source) {
function randomBates(n) {
	var randomIrwinHall = irwinHall.source(source)(n);
	return function() {
	  return randomIrwinHall() / n;
	};
}

randomBates.source = sourceRandomBates;

return randomBates;
})(src_defaultSource));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/src/exponential.js

/* harmony default export */ var src_exponential = ((function sourceRandomExponential(source) {
function randomExponential(lambda) {
	return function() {
	  return -Math.log(1 - source()) / lambda;
	};
}

randomExponential.source = sourceRandomExponential;

return randomExponential;
})(src_defaultSource));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-random/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/array.js
var d3_scale_src_array_array = Array.prototype;

var array_map = d3_scale_src_array_array.map;
var d3_scale_src_array_slice = d3_scale_src_array_array.slice;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/ordinal.js

var implicit = {name: "implicit"};

function ordinal(range) {
var index = src_map(),
	  domain = [],
	  unknown = implicit;

range = range == null ? [] : d3_scale_src_array_slice.call(range);

function scale(d) {
	var key = d + "", i = index.get(key);
	if (!i) {
	  if (unknown !== implicit) return unknown;
	  index.set(key, i = domain.push(d));
	}
	return range[(i - 1) % range.length];
}

scale.domain = function(_) {
	if (!arguments.length) return domain.slice();
	domain = [], index = src_map();
	var i = -1, n = _.length, d, key;
	while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
	return scale;
};

scale.range = function(_) {
	return arguments.length ? (range = d3_scale_src_array_slice.call(_), scale) : range.slice();
};

scale.unknown = function(_) {
	return arguments.length ? (unknown = _, scale) : unknown;
};

scale.copy = function() {
	return ordinal()
		.domain(domain)
		.range(range)
		.unknown(unknown);
};

return scale;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/band.js

function band() {
var scale = ordinal().unknown(undefined),
	  domain = scale.domain,
	  ordinalRange = scale.range,
	  range = [0, 1],
	  step,
	  bandwidth,
	  round = false,
	  paddingInner = 0,
	  paddingOuter = 0,
	  align = 0.5;

delete scale.unknown;

function rescale() {
	var n = domain().length,
		reverse = range[1] < range[0],
		start = range[reverse - 0],
		stop = range[1 - reverse];
	step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	if (round) step = Math.floor(step);
	start += (stop - start - step * (n - paddingInner)) * align;
	bandwidth = step * (1 - paddingInner);
	if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	var values = src_range(n).map(function(i) { return start + step * i; });
	return ordinalRange(reverse ? values.reverse() : values);
}

scale.domain = function(_) {
	return arguments.length ? (domain(_), rescale()) : domain();
};

scale.range = function(_) {
	return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
};

scale.rangeRound = function(_) {
	return range = [+_[0], +_[1]], round = true, rescale();
};

scale.bandwidth = function() {
	return bandwidth;
};

scale.step = function() {
	return step;
};

scale.round = function(_) {
	return arguments.length ? (round = !!_, rescale()) : round;
};

scale.padding = function(_) {
	return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
};

scale.paddingInner = function(_) {
	return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
};

scale.paddingOuter = function(_) {
	return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
};

scale.align = function(_) {
	return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
};

scale.copy = function() {
	return band()
		.domain(domain())
		.range(range)
		.round(round)
		.paddingInner(paddingInner)
		.paddingOuter(paddingOuter)
		.align(align);
};

return rescale();
}

function pointish(scale) {
var copy = scale.copy;

scale.padding = scale.paddingOuter;
delete scale.paddingInner;
delete scale.paddingOuter;

scale.copy = function() {
	return pointish(copy());
};

return scale;
}

function band_point() {
return pointish(band().paddingInner(1));
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/constant.js
/* harmony default export */ var d3_scale_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/number.js
/* harmony default export */ var d3_scale_src_number = (function(x) {
return +x;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/continuous.js

var unit = [0, 1];

function deinterpolateLinear(a, b) {
return (b -= (a = +a))
	  ? function(x) { return (x - a) / b; }
	  : d3_scale_src_constant(b);
}

function deinterpolateClamp(deinterpolate) {
return function(a, b) {
	var d = deinterpolate(a = +a, b = +b);
	return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
};
}

function reinterpolateClamp(reinterpolate) {
return function(a, b) {
	var r = reinterpolate(a = +a, b = +b);
	return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
};
}

function bimap(domain, range, deinterpolate, reinterpolate) {
var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
var j = Math.min(domain.length, range.length) - 1,
	  d = new Array(j),
	  r = new Array(j),
	  i = -1;

// Reverse descending domains.
if (domain[j] < domain[0]) {
	domain = domain.slice().reverse();
	range = range.slice().reverse();
}

while (++i < j) {
	d[i] = deinterpolate(domain[i], domain[i + 1]);
	r[i] = reinterpolate(range[i], range[i + 1]);
}

return function(x) {
	var i = bisect(domain, x, 1, j) - 1;
	return r[i](d[i](x));
};
}

function copy(source, target) {
return target
	  .domain(source.domain())
	  .range(source.range())
	  .interpolate(source.interpolate())
	  .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
var domain = unit,
	  range = unit,
	  interpolate = src_value,
	  clamp = false,
	  piecewise,
	  output,
	  input;

function rescale() {
	piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
	output = input = null;
	return scale;
}

function scale(x) {
	return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
}

scale.invert = function(y) {
	return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
};

scale.domain = function(_) {
	return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), rescale()) : domain.slice();
};

scale.range = function(_) {
	return arguments.length ? (range = d3_scale_src_array_slice.call(_), rescale()) : range.slice();
};

scale.rangeRound = function(_) {
	return range = d3_scale_src_array_slice.call(_), interpolate = src_round, rescale();
};

scale.clamp = function(_) {
	return arguments.length ? (clamp = !!_, rescale()) : clamp;
};

scale.interpolate = function(_) {
	return arguments.length ? (interpolate = _, rescale()) : interpolate;
};

return rescale();
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/tickFormat.js

/* harmony default export */ var src_tickFormat = (function(domain, count, specifier) {
var start = domain[0],
	  stop = domain[domain.length - 1],
	  step = tickStep(start, stop, count == null ? 10 : count),
	  precision;
specifier = formatSpecifier(specifier == null ? ",f" : specifier);
switch (specifier.type) {
	case "s": {
	  var value = Math.max(Math.abs(start), Math.abs(stop));
	  if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
	  return defaultLocale_formatPrefix(specifier, value);
	}
	case "":
	case "e":
	case "g":
	case "p":
	case "r": {
	  if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	  break;
	}
	case "f":
	case "%": {
	  if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	  break;
	}
}
return defaultLocale_format(specifier);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/linear.js

function linearish(scale) {
var domain = scale.domain;

scale.ticks = function(count) {
	var d = domain();
	return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
};

scale.tickFormat = function(count, specifier) {
	return src_tickFormat(domain(), count, specifier);
};

scale.nice = function(count) {
	if (count == null) count = 10;

	var d = domain(),
		i0 = 0,
		i1 = d.length - 1,
		start = d[i0],
		stop = d[i1],
		step;

	if (stop < start) {
	  step = start, start = stop, stop = step;
	  step = i0, i0 = i1, i1 = step;
	}

	step = tickIncrement(start, stop, count);

	if (step > 0) {
	  start = Math.floor(start / step) * step;
	  stop = Math.ceil(stop / step) * step;
	  step = tickIncrement(start, stop, count);
	} else if (step < 0) {
	  start = Math.ceil(start * step) / step;
	  stop = Math.floor(stop * step) / step;
	  step = tickIncrement(start, stop, count);
	}

	if (step > 0) {
	  d[i0] = Math.floor(start / step) * step;
	  d[i1] = Math.ceil(stop / step) * step;
	  domain(d);
	} else if (step < 0) {
	  d[i0] = Math.ceil(start * step) / step;
	  d[i1] = Math.floor(stop * step) / step;
	  domain(d);
	}

	return scale;
};

return scale;
}

function src_linear_linear() {
var scale = continuous(deinterpolateLinear, src_number);

scale.copy = function() {
	return copy(scale, src_linear_linear());
};

return linearish(scale);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/identity.js

function identity_identity() {
var domain = [0, 1];

function scale(x) {
	return +x;
}

scale.invert = scale;

scale.domain = scale.range = function(_) {
	return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), scale) : domain.slice();
};

scale.copy = function() {
	return identity_identity().domain(domain);
};

return linearish(scale);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/nice.js
/* harmony default export */ var nice = (function(domain, interval) {
domain = domain.slice();

var i0 = 0,
	  i1 = domain.length - 1,
	  x0 = domain[i0],
	  x1 = domain[i1],
	  t;

if (x1 < x0) {
	t = i0, i0 = i1, i1 = t;
	t = x0, x0 = x1, x1 = t;
}

domain[i0] = interval.floor(x0);
domain[i1] = interval.ceil(x1);
return domain;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/log.js

function log_deinterpolate(a, b) {
return (b = Math.log(b / a))
	  ? function(x) { return Math.log(x / a) / b; }
	  : d3_scale_src_constant(b);
}

function log_reinterpolate(a, b) {
return a < 0
	  ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
	  : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
return base === 10 ? pow10
	  : base === Math.E ? Math.exp
	  : function(x) { return Math.pow(base, x); };
}

function logp(base) {
return base === Math.E ? Math.log
	  : base === 10 && Math.log10
	  || base === 2 && Math.log2
	  || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
return function(x) {
	return -f(-x);
};
}

function log_log() {
var scale = continuous(log_deinterpolate, log_reinterpolate).domain([1, 10]),
	  domain = scale.domain,
	  base = 10,
	  logs = logp(10),
	  pows = powp(10);

function rescale() {
	logs = logp(base), pows = powp(base);
	if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
	return scale;
}

scale.base = function(_) {
	return arguments.length ? (base = +_, rescale()) : base;
};

scale.domain = function(_) {
	return arguments.length ? (domain(_), rescale()) : domain();
};

scale.ticks = function(count) {
	var d = domain(),
		u = d[0],
		v = d[d.length - 1],
		r;

	if (r = v < u) i = u, u = v, v = i;

	var i = logs(u),
		j = logs(v),
		p,
		k,
		t,
		n = count == null ? 10 : +count,
		z = [];

	if (!(base % 1) && j - i < n) {
	  i = Math.round(i) - 1, j = Math.round(j) + 1;
	  if (u > 0) for (; i < j; ++i) {
		for (k = 1, p = pows(i); k < base; ++k) {
		  t = p * k;
		  if (t < u) continue;
		  if (t > v) break;
		  z.push(t);
		}
	  } else for (; i < j; ++i) {
		for (k = base - 1, p = pows(i); k >= 1; --k) {
		  t = p * k;
		  if (t < u) continue;
		  if (t > v) break;
		  z.push(t);
		}
	  }
	} else {
	  z = ticks(i, j, Math.min(j - i, n)).map(pows);
	}

	return r ? z.reverse() : z;
};

scale.tickFormat = function(count, specifier) {
	if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	if (typeof specifier !== "function") specifier = defaultLocale_format(specifier);
	if (count === Infinity) return specifier;
	if (count == null) count = 10;
	var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	return function(d) {
	  var i = d / pows(Math.round(logs(d)));
	  if (i * base < base - 0.5) i *= base;
	  return i <= k ? specifier(d) : "";
	};
};

scale.nice = function() {
	return domain(nice(domain(), {
	  floor: function(x) { return pows(Math.floor(logs(x))); },
	  ceil: function(x) { return pows(Math.ceil(logs(x))); }
	}));
};

scale.copy = function() {
	return copy(scale, log_log().base(base));
};

return scale;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/pow.js

function pow_raise(x, exponent) {
return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow_pow() {
var exponent = 1,
	  scale = continuous(deinterpolate, reinterpolate),
	  domain = scale.domain;

function deinterpolate(a, b) {
	return (b = pow_raise(b, exponent) - (a = pow_raise(a, exponent)))
		? function(x) { return (pow_raise(x, exponent) - a) / b; }
		: d3_scale_src_constant(b);
}

function reinterpolate(a, b) {
	b = pow_raise(b, exponent) - (a = pow_raise(a, exponent));
	return function(t) { return pow_raise(a + b * t, 1 / exponent); };
}

scale.exponent = function(_) {
	return arguments.length ? (exponent = +_, domain(domain())) : exponent;
};

scale.copy = function() {
	return copy(scale, pow_pow().exponent(exponent));
};

return linearish(scale);
}

function pow_sqrt() {
return pow_pow().exponent(0.5);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/quantile.js

function quantile_quantile() {
var domain = [],
	  range = [],
	  thresholds = [];

function rescale() {
	var i = 0, n = Math.max(1, range.length);
	thresholds = new Array(n - 1);
	while (++i < n) thresholds[i - 1] = quantile(domain, i / n);
	return scale;
}

function scale(x) {
	if (!isNaN(x = +x)) return range[bisect(thresholds, x)];
}

scale.invertExtent = function(y) {
	var i = range.indexOf(y);
	return i < 0 ? [NaN, NaN] : [
	  i > 0 ? thresholds[i - 1] : domain[0],
	  i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
	];
};

scale.domain = function(_) {
	if (!arguments.length) return domain.slice();
	domain = [];
	for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	domain.sort(ascending);
	return rescale();
};

scale.range = function(_) {
	return arguments.length ? (range = d3_scale_src_array_slice.call(_), rescale()) : range.slice();
};

scale.quantiles = function() {
	return thresholds.slice();
};

scale.copy = function() {
	return quantile_quantile()
		.domain(domain)
		.range(range);
};

return scale;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/quantize.js

function quantize_quantize() {
var x0 = 0,
	  x1 = 1,
	  n = 1,
	  domain = [0.5],
	  range = [0, 1];

function scale(x) {
	if (x <= x) return range[bisect(domain, x, 0, n)];
}

function rescale() {
	var i = -1;
	domain = new Array(n);
	while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
	return scale;
}

scale.domain = function(_) {
	return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
};

scale.range = function(_) {
	return arguments.length ? (n = (range = d3_scale_src_array_slice.call(_)).length - 1, rescale()) : range.slice();
};

scale.invertExtent = function(y) {
	var i = range.indexOf(y);
	return i < 0 ? [NaN, NaN]
		: i < 1 ? [x0, domain[0]]
		: i >= n ? [domain[n - 1], x1]
		: [domain[i - 1], domain[i]];
};

scale.copy = function() {
	return quantize_quantize()
		.domain([x0, x1])
		.range(range);
};

return linearish(scale);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/threshold.js

function threshold_threshold() {
var domain = [0.5],
	  range = [0, 1],
	  n = 1;

function scale(x) {
	if (x <= x) return range[bisect(domain, x, 0, n)];
}

scale.domain = function(_) {
	return arguments.length ? (domain = d3_scale_src_array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
};

scale.range = function(_) {
	return arguments.length ? (range = d3_scale_src_array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
};

scale.invertExtent = function(y) {
	var i = range.indexOf(y);
	return [domain[i - 1], domain[i]];
};

scale.copy = function() {
	return threshold_threshold()
		.domain(domain)
		.range(range);
};

return scale;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/interval.js
var interval_t0 = new Date,
	interval_t1 = new Date;

function newInterval(floori, offseti, count, field) {

function interval(date) {
	return floori(date = new Date(+date)), date;
}

interval.floor = interval;

interval.ceil = function(date) {
	return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
};

interval.round = function(date) {
	var d0 = interval(date),
		d1 = interval.ceil(date);
	return date - d0 < d1 - date ? d0 : d1;
};

interval.offset = function(date, step) {
	return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
};

interval.range = function(start, stop, step) {
	var range = [], previous;
	start = interval.ceil(start);
	step = step == null ? 1 : Math.floor(step);
	if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	while (previous < start && start < stop);
	return range;
};

interval.filter = function(test) {
	return newInterval(function(date) {
	  if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	}, function(date, step) {
	  if (date >= date) {
		if (step < 0) while (++step <= 0) {
		  while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
		} else while (--step >= 0) {
		  while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
		}
	  }
	});
};

if (count) {
	interval.count = function(start, end) {
	  interval_t0.setTime(+start), interval_t1.setTime(+end);
	  floori(interval_t0), floori(interval_t1);
	  return Math.floor(count(interval_t0, interval_t1));
	};

	interval.every = function(step) {
	  step = Math.floor(step);
	  return !isFinite(step) || !(step > 0) ? null
		  : !(step > 1) ? interval
		  : interval.filter(field
			  ? function(d) { return field(d) % step === 0; }
			  : function(d) { return interval.count(0, d) % step === 0; });
	};
}

return interval;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/millisecond.js

var millisecond_millisecond = newInterval(function() {
// noop
}, function(date, step) {
date.setTime(+date + step);
}, function(start, end) {
return end - start;
});

// An optimized implementation for this simple case.
millisecond_millisecond.every = function(k) {
k = Math.floor(k);
if (!isFinite(k) || !(k > 0)) return null;
if (!(k > 1)) return millisecond_millisecond;
return newInterval(function(date) {
	date.setTime(Math.floor(date / k) * k);
}, function(date, step) {
	date.setTime(+date + step * k);
}, function(start, end) {
	return (end - start) / k;
});
};

/* harmony default export */ var src_millisecond = (millisecond_millisecond);
var milliseconds = millisecond_millisecond.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/second.js

var second_second = newInterval(function(date) {
date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
date.setTime(+date + step * durationSecond);
}, function(start, end) {
return (end - start) / durationSecond;
}, function(date) {
return date.getUTCSeconds();
});

/* harmony default export */ var src_second = (second_second);
var seconds = second_second.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/minute.js

var minute_minute = newInterval(function(date) {
date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
date.setTime(+date + step * durationMinute);
}, function(start, end) {
return (end - start) / durationMinute;
}, function(date) {
return date.getMinutes();
});

/* harmony default export */ var src_minute = (minute_minute);
var minutes = minute_minute.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/hour.js

var hour_hour = newInterval(function(date) {
var offset = date.getTimezoneOffset() * durationMinute % durationHour;
if (offset < 0) offset += durationHour;
date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
date.setTime(+date + step * durationHour);
}, function(start, end) {
return (end - start) / durationHour;
}, function(date) {
return date.getHours();
});

/* harmony default export */ var src_hour = (hour_hour);
var hours = hour_hour.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/day.js

var day_day = newInterval(function(date) {
date.setHours(0, 0, 0, 0);
}, function(date, step) {
date.setDate(date.getDate() + step);
}, function(start, end) {
return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
return date.getDate() - 1;
});

/* harmony default export */ var src_day = (day_day);
var days = day_day.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/week.js

function weekday(i) {
return newInterval(function(date) {
	date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	date.setHours(0, 0, 0, 0);
}, function(date, step) {
	date.setDate(date.getDate() + step * 7);
}, function(start, end) {
	return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
});
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/month.js

var month_month = newInterval(function(date) {
date.setDate(1);
date.setHours(0, 0, 0, 0);
}, function(date, step) {
date.setMonth(date.getMonth() + step);
}, function(start, end) {
return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
return date.getMonth();
});

/* harmony default export */ var src_month = (month_month);
var months = month_month.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/year.js

var year_year = newInterval(function(date) {
date.setMonth(0, 1);
date.setHours(0, 0, 0, 0);
}, function(date, step) {
date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
return end.getFullYear() - start.getFullYear();
}, function(date) {
return date.getFullYear();
});

// An optimized implementation for this simple case.
year_year.every = function(k) {
return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	date.setMonth(0, 1);
	date.setHours(0, 0, 0, 0);
}, function(date, step) {
	date.setFullYear(date.getFullYear() + step * k);
});
};

/* harmony default export */ var src_year = (year_year);
var years = year_year.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/utcMinute.js

var utcMinute = newInterval(function(date) {
date.setUTCSeconds(0, 0);
}, function(date, step) {
date.setTime(+date + step * durationMinute);
}, function(start, end) {
return (end - start) / durationMinute;
}, function(date) {
return date.getUTCMinutes();
});

/* harmony default export */ var src_utcMinute = (utcMinute);
var utcMinutes = utcMinute.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/utcHour.js

var utcHour = newInterval(function(date) {
date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
date.setTime(+date + step * durationHour);
}, function(start, end) {
return (end - start) / durationHour;
}, function(date) {
return date.getUTCHours();
});

/* harmony default export */ var src_utcHour = (utcHour);
var utcHours = utcHour.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/utcDay.js

var utcDay = newInterval(function(date) {
date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
return (end - start) / durationDay;
}, function(date) {
return date.getUTCDate() - 1;
});

/* harmony default export */ var src_utcDay = (utcDay);
var utcDays = utcDay.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/utcWeek.js

function utcWeekday(i) {
return newInterval(function(date) {
	date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
	date.setUTCDate(date.getUTCDate() + step * 7);
}, function(start, end) {
	return (end - start) / durationWeek;
});
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/utcMonth.js

var utcMonth = newInterval(function(date) {
date.setUTCDate(1);
date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
return date.getUTCMonth();
});

/* harmony default export */ var src_utcMonth = (utcMonth);
var utcMonths = utcMonth.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/src/utcYear.js

var utcYear = newInterval(function(date) {
date.setUTCMonth(0, 1);
date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	date.setUTCMonth(0, 1);
	date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
	date.setUTCFullYear(date.getUTCFullYear() + step * k);
});
};

/* harmony default export */ var src_utcYear = (utcYear);
var utcYears = utcYear.range;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time-format/src/locale.js

function localDate(d) {
if (0 <= d.y && d.y < 100) {
	var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	date.setFullYear(d.y);
	return date;
}
return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
if (0 <= d.y && d.y < 100) {
	var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	date.setUTCFullYear(d.y);
	return date;
}
return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
var locale_dateTime = locale.dateTime,
	  locale_date = locale.date,
	  locale_time = locale.time,
	  locale_periods = locale.periods,
	  locale_weekdays = locale.days,
	  locale_shortWeekdays = locale.shortDays,
	  locale_months = locale.months,
	  locale_shortMonths = locale.shortMonths;

var periodRe = formatRe(locale_periods),
	  periodLookup = formatLookup(locale_periods),
	  weekdayRe = formatRe(locale_weekdays),
	  weekdayLookup = formatLookup(locale_weekdays),
	  shortWeekdayRe = formatRe(locale_shortWeekdays),
	  shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	  monthRe = formatRe(locale_months),
	  monthLookup = formatLookup(locale_months),
	  shortMonthRe = formatRe(locale_shortMonths),
	  shortMonthLookup = formatLookup(locale_shortMonths);

var formats = {
	"a": formatShortWeekday,
	"A": formatWeekday,
	"b": formatShortMonth,
	"B": formatMonth,
	"c": null,
	"d": formatDayOfMonth,
	"e": formatDayOfMonth,
	"f": formatMicroseconds,
	"H": formatHour24,
	"I": formatHour12,
	"j": formatDayOfYear,
	"L": formatMilliseconds,
	"m": formatMonthNumber,
	"M": formatMinutes,
	"p": formatPeriod,
	"Q": formatUnixTimestamp,
	"s": formatUnixTimestampSeconds,
	"S": formatSeconds,
	"u": formatWeekdayNumberMonday,
	"U": formatWeekNumberSunday,
	"V": formatWeekNumberISO,
	"w": formatWeekdayNumberSunday,
	"W": formatWeekNumberMonday,
	"x": null,
	"X": null,
	"y": locale_formatYear,
	"Y": formatFullYear,
	"Z": formatZone,
	"%": formatLiteralPercent
};

var utcFormats = {
	"a": formatUTCShortWeekday,
	"A": formatUTCWeekday,
	"b": formatUTCShortMonth,
	"B": formatUTCMonth,
	"c": null,
	"d": formatUTCDayOfMonth,
	"e": formatUTCDayOfMonth,
	"f": formatUTCMicroseconds,
	"H": formatUTCHour24,
	"I": formatUTCHour12,
	"j": formatUTCDayOfYear,
	"L": formatUTCMilliseconds,
	"m": formatUTCMonthNumber,
	"M": formatUTCMinutes,
	"p": formatUTCPeriod,
	"Q": formatUnixTimestamp,
	"s": formatUnixTimestampSeconds,
	"S": formatUTCSeconds,
	"u": formatUTCWeekdayNumberMonday,
	"U": formatUTCWeekNumberSunday,
	"V": formatUTCWeekNumberISO,
	"w": formatUTCWeekdayNumberSunday,
	"W": formatUTCWeekNumberMonday,
	"x": null,
	"X": null,
	"y": formatUTCYear,
	"Y": formatUTCFullYear,
	"Z": formatUTCZone,
	"%": formatLiteralPercent
};

var parses = {
	"a": parseShortWeekday,
	"A": parseWeekday,
	"b": parseShortMonth,
	"B": parseMonth,
	"c": parseLocaleDateTime,
	"d": parseDayOfMonth,
	"e": parseDayOfMonth,
	"f": parseMicroseconds,
	"H": parseHour24,
	"I": parseHour24,
	"j": parseDayOfYear,
	"L": parseMilliseconds,
	"m": parseMonthNumber,
	"M": parseMinutes,
	"p": parsePeriod,
	"Q": parseUnixTimestamp,
	"s": parseUnixTimestampSeconds,
	"S": parseSeconds,
	"u": parseWeekdayNumberMonday,
	"U": parseWeekNumberSunday,
	"V": parseWeekNumberISO,
	"w": parseWeekdayNumberSunday,
	"W": parseWeekNumberMonday,
	"x": parseLocaleDate,
	"X": parseLocaleTime,
	"y": parseYear,
	"Y": parseFullYear,
	"Z": parseZone,
	"%": parseLiteralPercent
};

// These recursive directive definitions must be deferred.
formats.x = newFormat(locale_date, formats);
formats.X = newFormat(locale_time, formats);
formats.c = newFormat(locale_dateTime, formats);
utcFormats.x = newFormat(locale_date, utcFormats);
utcFormats.X = newFormat(locale_time, utcFormats);
utcFormats.c = newFormat(locale_dateTime, utcFormats);

function newFormat(specifier, formats) {
	return function(date) {
	  var string = [],
		  i = -1,
		  j = 0,
		  n = specifier.length,
		  c,
		  pad,
		  format;

	  if (!(date instanceof Date)) date = new Date(+date);

	  while (++i < n) {
		if (specifier.charCodeAt(i) === 37) {
		  string.push(specifier.slice(j, i));
		  if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
		  else pad = c === "e" ? " " : "0";
		  if (format = formats[c]) c = format(date, pad);
		  string.push(c);
		  j = i + 1;
		}
	  }

	  string.push(specifier.slice(j, i));
	  return string.join("");
	};
}

function newParse(specifier, newDate) {
	return function(string) {
	  var d = newYear(1900),
		  i = parseSpecifier(d, specifier, string += "", 0),
		  week, day;
	  if (i != string.length) return null;

	  // If a UNIX timestamp is specified, return it.
	  if ("Q" in d) return new Date(d.Q);

	  // The am-pm flag is 0 for AM, and 1 for PM.
	  if ("p" in d) d.H = d.H % 12 + d.p * 12;

	  // Convert day-of-week and week-of-year to day-of-year.
	  if ("V" in d) {
		if (d.V < 1 || d.V > 53) return null;
		if (!("w" in d)) d.w = 1;
		if ("Z" in d) {
		  week = utcDate(newYear(d.y)), day = week.getUTCDay();
		  week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
		  week = src_utcDay.offset(week, (d.V - 1) * 7);
		  d.y = week.getUTCFullYear();
		  d.m = week.getUTCMonth();
		  d.d = week.getUTCDate() + (d.w + 6) % 7;
		} else {
		  week = newDate(newYear(d.y)), day = week.getDay();
		  week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
		  week = src_day.offset(week, (d.V - 1) * 7);
		  d.y = week.getFullYear();
		  d.m = week.getMonth();
		  d.d = week.getDate() + (d.w + 6) % 7;
		}
	  } else if ("W" in d || "U" in d) {
		if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
		day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
		d.m = 0;
		d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	  }

	  // If a time zone is specified, all fields are interpreted as UTC and then
	  // offset according to the specified time zone.
	  if ("Z" in d) {
		d.H += d.Z / 100 | 0;
		d.M += d.Z % 100;
		return utcDate(d);
	  }

	  // Otherwise, all fields are in local time.
	  return newDate(d);
	};
}

function parseSpecifier(d, specifier, string, j) {
	var i = 0,
		n = specifier.length,
		m = string.length,
		c,
		parse;

	while (i < n) {
	  if (j >= m) return -1;
	  c = specifier.charCodeAt(i++);
	  if (c === 37) {
		c = specifier.charAt(i++);
		parse = parses[c in pads ? specifier.charAt(i++) : c];
		if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	  } else if (c != string.charCodeAt(j++)) {
		return -1;
	  }
	}

	return j;
}

function parsePeriod(d, string, i) {
	var n = periodRe.exec(string.slice(i));
	return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
}

function parseShortWeekday(d, string, i) {
	var n = shortWeekdayRe.exec(string.slice(i));
	return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
}

function parseWeekday(d, string, i) {
	var n = weekdayRe.exec(string.slice(i));
	return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
}

function parseShortMonth(d, string, i) {
	var n = shortMonthRe.exec(string.slice(i));
	return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
}

function parseMonth(d, string, i) {
	var n = monthRe.exec(string.slice(i));
	return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
}

function parseLocaleDateTime(d, string, i) {
	return parseSpecifier(d, locale_dateTime, string, i);
}

function parseLocaleDate(d, string, i) {
	return parseSpecifier(d, locale_date, string, i);
}

function parseLocaleTime(d, string, i) {
	return parseSpecifier(d, locale_time, string, i);
}

function formatShortWeekday(d) {
	return locale_shortWeekdays[d.getDay()];
}

function formatWeekday(d) {
	return locale_weekdays[d.getDay()];
}

function formatShortMonth(d) {
	return locale_shortMonths[d.getMonth()];
}

function formatMonth(d) {
	return locale_months[d.getMonth()];
}

function formatPeriod(d) {
	return locale_periods[+(d.getHours() >= 12)];
}

function formatUTCShortWeekday(d) {
	return locale_shortWeekdays[d.getUTCDay()];
}

function formatUTCWeekday(d) {
	return locale_weekdays[d.getUTCDay()];
}

function formatUTCShortMonth(d) {
	return locale_shortMonths[d.getUTCMonth()];
}

function formatUTCMonth(d) {
	return locale_months[d.getUTCMonth()];
}

function formatUTCPeriod(d) {
	return locale_periods[+(d.getUTCHours() >= 12)];
}

return {
	format: function(specifier) {
	  var f = newFormat(specifier += "", formats);
	  f.toString = function() { return specifier; };
	  return f;
	},
	parse: function(specifier) {
	  var p = newParse(specifier += "", localDate);
	  p.toString = function() { return specifier; };
	  return p;
	},
	utcFormat: function(specifier) {
	  var f = newFormat(specifier += "", utcFormats);
	  f.toString = function() { return specifier; };
	  return f;
	},
	utcParse: function(specifier) {
	  var p = newParse(specifier, utcDate);
	  p.toString = function() { return specifier; };
	  return p;
	}
};
}

var pads = {"-": "", "_": " ", "0": "0"},
	numberRe = /^\s*\d+/, // note: ignores next directive
	percentRe = /^%/,
	requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
var sign = value < 0 ? "-" : "",
	  string = (sign ? -value : value) + "",
	  length = string.length;
return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
var map = {}, i = -1, n = names.length;
while (++i < n) map[names[i].toLowerCase()] = i;
return map;
}

function parseWeekdayNumberSunday(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 1));
return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 1));
return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 4));
return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 3));
return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 2));
return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 3));
return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
var n = numberRe.exec(string.slice(i, i + 6));
return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
var n = percentRe.exec(string.slice(i, i + 1));
return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
var n = numberRe.exec(string.slice(i));
return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
var n = numberRe.exec(string.slice(i));
return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
return pad(1 + src_day.count(src_year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
var day = d.getDay();
return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
return pad(sunday.count(src_year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
var day = d.getDay();
d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
return pad(thursday.count(src_year(d), d) + (src_year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
return d.getDay();
}

function formatWeekNumberMonday(d, p) {
return pad(monday.count(src_year(d), d), p, 2);
}

function locale_formatYear(d, p) {
return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
var z = d.getTimezoneOffset();
return (z > 0 ? "-" : (z *= -1, "+"))
	  + pad(z / 60 | 0, "0", 2)
	  + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
return pad(1 + src_utcDay.count(src_utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
var dow = d.getUTCDay();
return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
return pad(utcSunday.count(src_utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
var day = d.getUTCDay();
d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
return pad(utcThursday.count(src_utcYear(d), d) + (src_utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
return pad(utcMonday.count(src_utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
return "+0000";
}

function formatLiteralPercent() {
return "%";
}

function formatUnixTimestamp(d) {
return +d;
}

function formatUnixTimestampSeconds(d) {
return Math.floor(+d / 1000);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time-format/src/defaultLocale.js

var src_defaultLocale_locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale_defaultLocale({
dateTime: "%x, %X",
date: "%-m/%-d/%Y",
time: "%-I:%M:%S %p",
periods: ["AM", "PM"],
days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale_defaultLocale(definition) {
src_defaultLocale_locale = formatLocale(definition);
timeFormat = src_defaultLocale_locale.format;
timeParse = src_defaultLocale_locale.parse;
utcFormat = src_defaultLocale_locale.utcFormat;
utcParse = src_defaultLocale_locale.utcParse;
return src_defaultLocale_locale;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time-format/src/isoFormat.js

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
return date.toISOString();
}

var formatIso = Date.prototype.toISOString
	? formatIsoNative
	: utcFormat(isoSpecifier);

/* harmony default export */ var isoFormat = (formatIso);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time-format/src/isoParse.js

function parseIsoNative(string) {
var date = new Date(string);
return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
	? parseIsoNative
	: utcParse(isoSpecifier);

/* harmony default export */ var isoParse = (parseIso);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-time-format/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/time.js

var time_durationSecond = 1000,
	time_durationMinute = time_durationSecond * 60,
	time_durationHour = time_durationMinute * 60,
	time_durationDay = time_durationHour * 24,
	time_durationWeek = time_durationDay * 7,
	durationMonth = time_durationDay * 30,
	durationYear = time_durationDay * 365;

function time_date(t) {
return new Date(t);
}

function time_number(t) {
return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
var scale = continuous(deinterpolateLinear, src_number),
	  invert = scale.invert,
	  domain = scale.domain;

var formatMillisecond = format(".%L"),
	  formatSecond = format(":%S"),
	  formatMinute = format("%I:%M"),
	  formatHour = format("%I %p"),
	  formatDay = format("%a %d"),
	  formatWeek = format("%b %d"),
	  formatMonth = format("%B"),
	  formatYear = format("%Y");

var tickIntervals = [
	[second,  1,      time_durationSecond],
	[second,  5,  5 * time_durationSecond],
	[second, 15, 15 * time_durationSecond],
	[second, 30, 30 * time_durationSecond],
	[minute,  1,      time_durationMinute],
	[minute,  5,  5 * time_durationMinute],
	[minute, 15, 15 * time_durationMinute],
	[minute, 30, 30 * time_durationMinute],
	[  hour,  1,      time_durationHour  ],
	[  hour,  3,  3 * time_durationHour  ],
	[  hour,  6,  6 * time_durationHour  ],
	[  hour, 12, 12 * time_durationHour  ],
	[   day,  1,      time_durationDay   ],
	[   day,  2,  2 * time_durationDay   ],
	[  week,  1,      time_durationWeek  ],
	[ month,  1,      durationMonth ],
	[ month,  3,  3 * durationMonth ],
	[  year,  1,      durationYear  ]
];

function tickFormat(date) {
	return (second(date) < date ? formatMillisecond
		: minute(date) < date ? formatSecond
		: hour(date) < date ? formatMinute
		: day(date) < date ? formatHour
		: month(date) < date ? (week(date) < date ? formatDay : formatWeek)
		: year(date) < date ? formatMonth
		: formatYear)(date);
}

function tickInterval(interval, start, stop, step) {
	if (interval == null) interval = 10;

	// If a desired tick count is specified, pick a reasonable tick interval
	// based on the extent of the domain and a rough estimate of tick size.
	// Otherwise, assume interval is already a time interval and use it.
	if (typeof interval === "number") {
	  var target = Math.abs(stop - start) / interval,
		  i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
	  if (i === tickIntervals.length) {
		step = tickStep(start / durationYear, stop / durationYear, interval);
		interval = year;
	  } else if (i) {
		i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
		step = i[1];
		interval = i[0];
	  } else {
		step = Math.max(tickStep(start, stop, interval), 1);
		interval = millisecond;
	  }
	}

	return step == null ? interval : interval.every(step);
}

scale.invert = function(y) {
	return new Date(invert(y));
};

scale.domain = function(_) {
	return arguments.length ? domain(array_map.call(_, time_number)) : domain().map(time_date);
};

scale.ticks = function(interval, step) {
	var d = domain(),
		t0 = d[0],
		t1 = d[d.length - 1],
		r = t1 < t0,
		t;
	if (r) t = t0, t0 = t1, t1 = t;
	t = tickInterval(interval, t0, t1, step);
	t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	return r ? t.reverse() : t;
};

scale.tickFormat = function(count, specifier) {
	return specifier == null ? tickFormat : format(specifier);
};

scale.nice = function(interval, step) {
	var d = domain();
	return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
		? domain(nice(d, interval))
		: scale;
};

scale.copy = function() {
	return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
};

return scale;
}

/* harmony default export */ var src_time = (function() {
return calendar(src_year, src_month, sunday, src_day, src_hour, src_minute, src_second, src_millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/utcTime.js

/* harmony default export */ var utcTime = (function() {
return calendar(src_utcYear, src_utcMonth, utcSunday, src_utcDay, src_utcHour, src_utcMinute, src_second, src_millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/src/sequential.js

function sequential(interpolator) {
var x0 = 0,
	  x1 = 1,
	  clamp = false;

function scale(x) {
	var t = (x - x0) / (x1 - x0);
	return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
}

scale.domain = function(_) {
	return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
};

scale.clamp = function(_) {
	return arguments.length ? (clamp = !!_, scale) : clamp;
};

scale.interpolator = function(_) {
	return arguments.length ? (interpolator = _, scale) : interpolator;
};

scale.copy = function() {
	return sequential(interpolator).domain([x0, x1]).clamp(clamp);
};

return linearish(scale);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/colors.js
/* harmony default export */ var src_colors = (function(specifier) {
var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
return colors;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/category10.js

/* harmony default export */ var category10 = (src_colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Accent.js

/* harmony default export */ var Accent = (src_colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Dark2.js

/* harmony default export */ var Dark2 = (src_colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Paired.js

/* harmony default export */ var Paired = (src_colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js

/* harmony default export */ var Pastel1 = (src_colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js

/* harmony default export */ var Pastel2 = (src_colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Set1.js

/* harmony default export */ var Set1 = (src_colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Set2.js

/* harmony default export */ var Set2 = (src_colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/categorical/Set3.js

/* harmony default export */ var Set3 = (src_colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/ramp.js

/* harmony default export */ var ramp = (function(scheme) {
return rgbBasis(scheme[scheme.length - 1]);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/BrBG.js

var BrBG_scheme = new Array(3).concat(
"d8b365f5f5f55ab4ac",
"a6611adfc27d80cdc1018571",
"a6611adfc27df5f5f580cdc1018571",
"8c510ad8b365f6e8c3c7eae55ab4ac01665e",
"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(src_colors);

/* harmony default export */ var BrBG = (ramp(BrBG_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/PRGn.js

var PRGn_scheme = new Array(3).concat(
"af8dc3f7f7f77fbf7b",
"7b3294c2a5cfa6dba0008837",
"7b3294c2a5cff7f7f7a6dba0008837",
"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(src_colors);

/* harmony default export */ var PRGn = (ramp(PRGn_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/PiYG.js

var PiYG_scheme = new Array(3).concat(
"e9a3c9f7f7f7a1d76a",
"d01c8bf1b6dab8e1864dac26",
"d01c8bf1b6daf7f7f7b8e1864dac26",
"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(src_colors);

/* harmony default export */ var PiYG = (ramp(PiYG_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/PuOr.js

var PuOr_scheme = new Array(3).concat(
"998ec3f7f7f7f1a340",
"5e3c99b2abd2fdb863e66101",
"5e3c99b2abd2f7f7f7fdb863e66101",
"542788998ec3d8daebfee0b6f1a340b35806",
"542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(src_colors);

/* harmony default export */ var PuOr = (ramp(PuOr_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/RdBu.js

var RdBu_scheme = new Array(3).concat(
"ef8a62f7f7f767a9cf",
"ca0020f4a58292c5de0571b0",
"ca0020f4a582f7f7f792c5de0571b0",
"b2182bef8a62fddbc7d1e5f067a9cf2166ac",
"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(src_colors);

/* harmony default export */ var RdBu = (ramp(RdBu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/RdGy.js

var RdGy_scheme = new Array(3).concat(
"ef8a62ffffff999999",
"ca0020f4a582bababa404040",
"ca0020f4a582ffffffbababa404040",
"b2182bef8a62fddbc7e0e0e09999994d4d4d",
"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(src_colors);

/* harmony default export */ var RdGy = (ramp(RdGy_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js

var RdYlBu_scheme = new Array(3).concat(
"fc8d59ffffbf91bfdb",
"d7191cfdae61abd9e92c7bb6",
"d7191cfdae61ffffbfabd9e92c7bb6",
"d73027fc8d59fee090e0f3f891bfdb4575b4",
"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(src_colors);

/* harmony default export */ var RdYlBu = (ramp(RdYlBu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js

var RdYlGn_scheme = new Array(3).concat(
"fc8d59ffffbf91cf60",
"d7191cfdae61a6d96a1a9641",
"d7191cfdae61ffffbfa6d96a1a9641",
"d73027fc8d59fee08bd9ef8b91cf601a9850",
"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(src_colors);

/* harmony default export */ var RdYlGn = (ramp(RdYlGn_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/diverging/Spectral.js

var Spectral_scheme = new Array(3).concat(
"fc8d59ffffbf99d594",
"d7191cfdae61abdda42b83ba",
"d7191cfdae61ffffbfabdda42b83ba",
"d53e4ffc8d59fee08be6f59899d5943288bd",
"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(src_colors);

/* harmony default export */ var Spectral = (ramp(Spectral_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js

var BuGn_scheme = new Array(3).concat(
"e5f5f999d8c92ca25f",
"edf8fbb2e2e266c2a4238b45",
"edf8fbb2e2e266c2a42ca25f006d2c",
"edf8fbccece699d8c966c2a42ca25f006d2c",
"edf8fbccece699d8c966c2a441ae76238b45005824",
"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(src_colors);

/* harmony default export */ var BuGn = (ramp(BuGn_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js

var BuPu_scheme = new Array(3).concat(
"e0ecf49ebcda8856a7",
"edf8fbb3cde38c96c688419d",
"edf8fbb3cde38c96c68856a7810f7c",
"edf8fbbfd3e69ebcda8c96c68856a7810f7c",
"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(src_colors);

/* harmony default export */ var BuPu = (ramp(BuPu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js

var GnBu_scheme = new Array(3).concat(
"e0f3dba8ddb543a2ca",
"f0f9e8bae4bc7bccc42b8cbe",
"f0f9e8bae4bc7bccc443a2ca0868ac",
"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(src_colors);

/* harmony default export */ var GnBu = (ramp(GnBu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js

var OrRd_scheme = new Array(3).concat(
"fee8c8fdbb84e34a33",
"fef0d9fdcc8afc8d59d7301f",
"fef0d9fdcc8afc8d59e34a33b30000",
"fef0d9fdd49efdbb84fc8d59e34a33b30000",
"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(src_colors);

/* harmony default export */ var OrRd = (ramp(OrRd_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js

var PuBuGn_scheme = new Array(3).concat(
"ece2f0a6bddb1c9099",
"f6eff7bdc9e167a9cf02818a",
"f6eff7bdc9e167a9cf1c9099016c59",
"f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(src_colors);

/* harmony default export */ var PuBuGn = (ramp(PuBuGn_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js

var PuBu_scheme = new Array(3).concat(
"ece7f2a6bddb2b8cbe",
"f1eef6bdc9e174a9cf0570b0",
"f1eef6bdc9e174a9cf2b8cbe045a8d",
"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(src_colors);

/* harmony default export */ var PuBu = (ramp(PuBu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js

var PuRd_scheme = new Array(3).concat(
"e7e1efc994c7dd1c77",
"f1eef6d7b5d8df65b0ce1256",
"f1eef6d7b5d8df65b0dd1c77980043",
"f1eef6d4b9dac994c7df65b0dd1c77980043",
"f1eef6d4b9dac994c7df65b0e7298ace125691003f",
"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(src_colors);

/* harmony default export */ var PuRd = (ramp(PuRd_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js

var RdPu_scheme = new Array(3).concat(
"fde0ddfa9fb5c51b8a",
"feebe2fbb4b9f768a1ae017e",
"feebe2fbb4b9f768a1c51b8a7a0177",
"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(src_colors);

/* harmony default export */ var RdPu = (ramp(RdPu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js

var YlGnBu_scheme = new Array(3).concat(
"edf8b17fcdbb2c7fb8",
"ffffcca1dab441b6c4225ea8",
"ffffcca1dab441b6c42c7fb8253494",
"ffffccc7e9b47fcdbb41b6c42c7fb8253494",
"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(src_colors);

/* harmony default export */ var YlGnBu = (ramp(YlGnBu_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js

var YlGn_scheme = new Array(3).concat(
"f7fcb9addd8e31a354",
"ffffccc2e69978c679238443",
"ffffccc2e69978c67931a354006837",
"ffffccd9f0a3addd8e78c67931a354006837",
"ffffccd9f0a3addd8e78c67941ab5d238443005a32",
"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(src_colors);

/* harmony default export */ var YlGn = (ramp(YlGn_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js

var YlOrBr_scheme = new Array(3).concat(
"fff7bcfec44fd95f0e",
"ffffd4fed98efe9929cc4c02",
"ffffd4fed98efe9929d95f0e993404",
"ffffd4fee391fec44ffe9929d95f0e993404",
"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(src_colors);

/* harmony default export */ var YlOrBr = (ramp(YlOrBr_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js

var YlOrRd_scheme = new Array(3).concat(
"ffeda0feb24cf03b20",
"ffffb2fecc5cfd8d3ce31a1c",
"ffffb2fecc5cfd8d3cf03b20bd0026",
"ffffb2fed976feb24cfd8d3cf03b20bd0026",
"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(src_colors);

/* harmony default export */ var YlOrRd = (ramp(YlOrRd_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js

var Blues_scheme = new Array(3).concat(
"deebf79ecae13182bd",
"eff3ffbdd7e76baed62171b5",
"eff3ffbdd7e76baed63182bd08519c",
"eff3ffc6dbef9ecae16baed63182bd08519c",
"eff3ffc6dbef9ecae16baed64292c62171b5084594",
"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(src_colors);

/* harmony default export */ var Blues = (ramp(Blues_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js

var Greens_scheme = new Array(3).concat(
"e5f5e0a1d99b31a354",
"edf8e9bae4b374c476238b45",
"edf8e9bae4b374c47631a354006d2c",
"edf8e9c7e9c0a1d99b74c47631a354006d2c",
"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(src_colors);

/* harmony default export */ var Greens = (ramp(Greens_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js

var Greys_scheme = new Array(3).concat(
"f0f0f0bdbdbd636363",
"f7f7f7cccccc969696525252",
"f7f7f7cccccc969696636363252525",
"f7f7f7d9d9d9bdbdbd969696636363252525",
"f7f7f7d9d9d9bdbdbd969696737373525252252525",
"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(src_colors);

/* harmony default export */ var Greys = (ramp(Greys_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js

var Purples_scheme = new Array(3).concat(
"efedf5bcbddc756bb1",
"f2f0f7cbc9e29e9ac86a51a3",
"f2f0f7cbc9e29e9ac8756bb154278f",
"f2f0f7dadaebbcbddc9e9ac8756bb154278f",
"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(src_colors);

/* harmony default export */ var Purples = (ramp(Purples_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js

var Reds_scheme = new Array(3).concat(
"fee0d2fc9272de2d26",
"fee5d9fcae91fb6a4acb181d",
"fee5d9fcae91fb6a4ade2d26a50f15",
"fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(src_colors);

/* harmony default export */ var Reds = (ramp(Reds_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js

var Oranges_scheme = new Array(3).concat(
"fee6cefdae6be6550d",
"feeddefdbe85fd8d3cd94701",
"feeddefdbe85fd8d3ce6550da63603",
"feeddefdd0a2fdae6bfd8d3ce6550da63603",
"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(src_colors);

/* harmony default export */ var Oranges = (ramp(Oranges_scheme));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js

/* harmony default export */ var sequential_multi_cubehelix = (cubehelixLong(cubehelix_cubehelix(300, 0.5, 0.0), cubehelix_cubehelix(-240, 0.5, 1.0)));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js

var warm = cubehelixLong(cubehelix_cubehelix(-100, 0.75, 0.35), cubehelix_cubehelix(80, 1.50, 0.8));

var cool = cubehelixLong(cubehelix_cubehelix(260, 0.75, 0.35), cubehelix_cubehelix(80, 1.50, 0.8));

var rainbow = cubehelix_cubehelix();

/* harmony default export */ var sequential_multi_rainbow = (function(t) {
if (t < 0 || t > 1) t -= Math.floor(t);
var ts = Math.abs(t - 0.5);
rainbow.h = 360 * t - 100;
rainbow.s = 1.5 - 1.5 * ts;
rainbow.l = 0.8 - 0.9 * ts;
return rainbow + "";
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js

function viridis_ramp(range) {
var n = range.length;
return function(t) {
	return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
};
}

/* harmony default export */ var viridis = (viridis_ramp(src_colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = viridis_ramp(src_colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = viridis_ramp(src_colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = viridis_ramp(src_colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-scale-chromatic/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/constant.js
/* harmony default export */ var d3_shape_src_constant = (function(x) {
return function constant() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/math.js
var math_abs = Math.abs;
var math_atan2 = Math.atan2;
var src_math_cos = Math.cos;
var src_math_max = Math.max;
var math_min = Math.min;
var src_math_sin = Math.sin;
var math_sqrt = Math.sqrt;

var src_math_epsilon = 1e-12;
var d3_shape_src_math_pi = Math.PI;
var d3_shape_src_math_halfPi = d3_shape_src_math_pi / 2;
var d3_shape_src_math_tau = 2 * d3_shape_src_math_pi;

function math_acos(x) {
return x > 1 ? 0 : x < -1 ? d3_shape_src_math_pi : Math.acos(x);
}

function math_asin(x) {
return x >= 1 ? d3_shape_src_math_halfPi : x <= -1 ? -d3_shape_src_math_halfPi : Math.asin(x);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/arc.js

function arcInnerRadius(d) {
return d.innerRadius;
}

function arcOuterRadius(d) {
return d.outerRadius;
}

function arcStartAngle(d) {
return d.startAngle;
}

function arcEndAngle(d) {
return d.endAngle;
}

function arcPadAngle(d) {
return d && d.padAngle; // Note: optional!
}

function arc_intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
var x10 = x1 - x0, y10 = y1 - y0,
	  x32 = x3 - x2, y32 = y3 - y2,
	  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
var x01 = x0 - x1,
	  y01 = y0 - y1,
	  lo = (cw ? rc : -rc) / math_sqrt(x01 * x01 + y01 * y01),
	  ox = lo * y01,
	  oy = -lo * x01,
	  x11 = x0 + ox,
	  y11 = y0 + oy,
	  x10 = x1 + ox,
	  y10 = y1 + oy,
	  x00 = (x11 + x10) / 2,
	  y00 = (y11 + y10) / 2,
	  dx = x10 - x11,
	  dy = y10 - y11,
	  d2 = dx * dx + dy * dy,
	  r = r1 - rc,
	  D = x11 * y10 - x10 * y11,
	  d = (dy < 0 ? -1 : 1) * math_sqrt(src_math_max(0, r * r * d2 - D * D)),
	  cx0 = (D * dy - dx * d) / d2,
	  cy0 = (-D * dx - dy * d) / d2,
	  cx1 = (D * dy + dx * d) / d2,
	  cy1 = (-D * dx + dy * d) / d2,
	  dx0 = cx0 - x00,
	  dy0 = cy0 - y00,
	  dx1 = cx1 - x00,
	  dy1 = cy1 - y00;

// Pick the closer of the two intersection points.
// TODO Is there a faster way to determine which intersection to use?
if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

return {
	cx: cx0,
	cy: cy0,
	x01: -ox,
	y01: -oy,
	x11: cx0 * (r1 / r - 1),
	y11: cy0 * (r1 / r - 1)
};
}

/* harmony default export */ var src_arc = (function() {
var innerRadius = arcInnerRadius,
	  outerRadius = arcOuterRadius,
	  cornerRadius = d3_shape_src_constant(0),
	  padRadius = null,
	  startAngle = arcStartAngle,
	  endAngle = arcEndAngle,
	  padAngle = arcPadAngle,
	  context = null;

function arc() {
	var buffer,
		r,
		r0 = +innerRadius.apply(this, arguments),
		r1 = +outerRadius.apply(this, arguments),
		a0 = startAngle.apply(this, arguments) - d3_shape_src_math_halfPi,
		a1 = endAngle.apply(this, arguments) - d3_shape_src_math_halfPi,
		da = math_abs(a1 - a0),
		cw = a1 > a0;

	if (!context) context = buffer = src_path();

	// Ensure that the outer radius is always larger than the inner radius.
	if (r1 < r0) r = r1, r1 = r0, r0 = r;

	// Is it a point?
	if (!(r1 > src_math_epsilon)) context.moveTo(0, 0);

	// Or is it a circle or annulus?
	else if (da > d3_shape_src_math_tau - src_math_epsilon) {
	  context.moveTo(r1 * src_math_cos(a0), r1 * src_math_sin(a0));
	  context.arc(0, 0, r1, a0, a1, !cw);
	  if (r0 > src_math_epsilon) {
		context.moveTo(r0 * src_math_cos(a1), r0 * src_math_sin(a1));
		context.arc(0, 0, r0, a1, a0, cw);
	  }
	}

	// Or is it a circular or annular sector?
	else {
	  var a01 = a0,
		  a11 = a1,
		  a00 = a0,
		  a10 = a1,
		  da0 = da,
		  da1 = da,
		  ap = padAngle.apply(this, arguments) / 2,
		  rp = (ap > src_math_epsilon) && (padRadius ? +padRadius.apply(this, arguments) : math_sqrt(r0 * r0 + r1 * r1)),
		  rc = math_min(math_abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
		  rc0 = rc,
		  rc1 = rc,
		  t0,
		  t1;

	  // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
	  if (rp > src_math_epsilon) {
		var p0 = math_asin(rp / r0 * src_math_sin(ap)),
			p1 = math_asin(rp / r1 * src_math_sin(ap));
		if ((da0 -= p0 * 2) > src_math_epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
		else da0 = 0, a00 = a10 = (a0 + a1) / 2;
		if ((da1 -= p1 * 2) > src_math_epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
		else da1 = 0, a01 = a11 = (a0 + a1) / 2;
	  }

	  var x01 = r1 * src_math_cos(a01),
		  y01 = r1 * src_math_sin(a01),
		  x10 = r0 * src_math_cos(a10),
		  y10 = r0 * src_math_sin(a10);

	  // Apply rounded corners?
	  if (rc > src_math_epsilon) {
		var x11 = r1 * src_math_cos(a11),
			y11 = r1 * src_math_sin(a11),
			x00 = r0 * src_math_cos(a00),
			y00 = r0 * src_math_sin(a00);

		// Restrict the corner radius according to the sector angle.
		if (da < d3_shape_src_math_pi) {
		  var oc = da0 > src_math_epsilon ? arc_intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
			  ax = x01 - oc[0],
			  ay = y01 - oc[1],
			  bx = x11 - oc[0],
			  by = y11 - oc[1],
			  kc = 1 / src_math_sin(math_acos((ax * bx + ay * by) / (math_sqrt(ax * ax + ay * ay) * math_sqrt(bx * bx + by * by))) / 2),
			  lc = math_sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
		  rc0 = math_min(rc, (r0 - lc) / (kc - 1));
		  rc1 = math_min(rc, (r1 - lc) / (kc + 1));
		}
	  }

	  // Is the sector collapsed to a line?
	  if (!(da1 > src_math_epsilon)) context.moveTo(x01, y01);

	  // Does the sector’s outer ring have rounded corners?
	  else if (rc1 > src_math_epsilon) {
		t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
		t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

		context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

		// Have the corners merged?
		if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, math_atan2(t0.y01, t0.x01), math_atan2(t1.y01, t1.x01), !cw);

		// Otherwise, draw the two corners and the ring.
		else {
		  context.arc(t0.cx, t0.cy, rc1, math_atan2(t0.y01, t0.x01), math_atan2(t0.y11, t0.x11), !cw);
		  context.arc(0, 0, r1, math_atan2(t0.cy + t0.y11, t0.cx + t0.x11), math_atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
		  context.arc(t1.cx, t1.cy, rc1, math_atan2(t1.y11, t1.x11), math_atan2(t1.y01, t1.x01), !cw);
		}
	  }

	  // Or is the outer ring just a circular arc?
	  else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

	  // Is there no inner ring, and it’s a circular sector?
	  // Or perhaps it’s an annular sector collapsed due to padding?
	  if (!(r0 > src_math_epsilon) || !(da0 > src_math_epsilon)) context.lineTo(x10, y10);

	  // Does the sector’s inner ring (or point) have rounded corners?
	  else if (rc0 > src_math_epsilon) {
		t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
		t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

		context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

		// Have the corners merged?
		if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, math_atan2(t0.y01, t0.x01), math_atan2(t1.y01, t1.x01), !cw);

		// Otherwise, draw the two corners and the ring.
		else {
		  context.arc(t0.cx, t0.cy, rc0, math_atan2(t0.y01, t0.x01), math_atan2(t0.y11, t0.x11), !cw);
		  context.arc(0, 0, r0, math_atan2(t0.cy + t0.y11, t0.cx + t0.x11), math_atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
		  context.arc(t1.cx, t1.cy, rc0, math_atan2(t1.y11, t1.x11), math_atan2(t1.y01, t1.x01), !cw);
		}
	  }

	  // Or is the inner ring just a circular arc?
	  else context.arc(0, 0, r0, a10, a00, cw);
	}

	context.closePath();

	if (buffer) return context = null, buffer + "" || null;
}

arc.centroid = function() {
	var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
		a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - d3_shape_src_math_pi / 2;
	return [src_math_cos(a) * r, src_math_sin(a) * r];
};

arc.innerRadius = function(_) {
	return arguments.length ? (innerRadius = typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : innerRadius;
};

arc.outerRadius = function(_) {
	return arguments.length ? (outerRadius = typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : outerRadius;
};

arc.cornerRadius = function(_) {
	return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : cornerRadius;
};

arc.padRadius = function(_) {
	return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : padRadius;
};

arc.startAngle = function(_) {
	return arguments.length ? (startAngle = typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : startAngle;
};

arc.endAngle = function(_) {
	return arguments.length ? (endAngle = typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : endAngle;
};

arc.padAngle = function(_) {
	return arguments.length ? (padAngle = typeof _ === "function" ? _ : d3_shape_src_constant(+_), arc) : padAngle;
};

arc.context = function(_) {
	return arguments.length ? ((context = _ == null ? null : _), arc) : context;
};

return arc;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
this._context = context;
}

Linear.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._point = 0;
},
lineEnd: function() {
	if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	  case 1: this._point = 2; // proceed
	  default: this._context.lineTo(x, y); break;
	}
}
};

/* harmony default export */ var curve_linear = (function(context) {
return new Linear(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/point.js
function point_x(p) {
return p[0];
}

function point_y(p) {
return p[1];
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/line.js

/* harmony default export */ var src_line = (function() {
var x = point_x,
	  y = point_y,
	  defined = d3_shape_src_constant(true),
	  context = null,
	  curve = curve_linear,
	  output = null;

function line(data) {
	var i,
		n = data.length,
		d,
		defined0 = false,
		buffer;

	if (context == null) output = curve(buffer = src_path());

	for (i = 0; i <= n; ++i) {
	  if (!(i < n && defined(d = data[i], i, data)) === defined0) {
		if (defined0 = !defined0) output.lineStart();
		else output.lineEnd();
	  }
	  if (defined0) output.point(+x(d, i, data), +y(d, i, data));
	}

	if (buffer) return output = null, buffer + "" || null;
}

line.x = function(_) {
	return arguments.length ? (x = typeof _ === "function" ? _ : d3_shape_src_constant(+_), line) : x;
};

line.y = function(_) {
	return arguments.length ? (y = typeof _ === "function" ? _ : d3_shape_src_constant(+_), line) : y;
};

line.defined = function(_) {
	return arguments.length ? (defined = typeof _ === "function" ? _ : d3_shape_src_constant(!!_), line) : defined;
};

line.curve = function(_) {
	return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
};

line.context = function(_) {
	return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
};

return line;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/area.js

/* harmony default export */ var d3_shape_src_area = (function() {
var x0 = point_x,
	  x1 = null,
	  y0 = d3_shape_src_constant(0),
	  y1 = point_y,
	  defined = d3_shape_src_constant(true),
	  context = null,
	  curve = curve_linear,
	  output = null;

function area(data) {
	var i,
		j,
		k,
		n = data.length,
		d,
		defined0 = false,
		buffer,
		x0z = new Array(n),
		y0z = new Array(n);

	if (context == null) output = curve(buffer = src_path());

	for (i = 0; i <= n; ++i) {
	  if (!(i < n && defined(d = data[i], i, data)) === defined0) {
		if (defined0 = !defined0) {
		  j = i;
		  output.areaStart();
		  output.lineStart();
		} else {
		  output.lineEnd();
		  output.lineStart();
		  for (k = i - 1; k >= j; --k) {
			output.point(x0z[k], y0z[k]);
		  }
		  output.lineEnd();
		  output.areaEnd();
		}
	  }
	  if (defined0) {
		x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
		output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
	  }
	}

	if (buffer) return output = null, buffer + "" || null;
}

function arealine() {
	return src_line().defined(defined).curve(curve).context(context);
}

area.x = function(_) {
	return arguments.length ? (x0 = typeof _ === "function" ? _ : d3_shape_src_constant(+_), x1 = null, area) : x0;
};

area.x0 = function(_) {
	return arguments.length ? (x0 = typeof _ === "function" ? _ : d3_shape_src_constant(+_), area) : x0;
};

area.x1 = function(_) {
	return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : d3_shape_src_constant(+_), area) : x1;
};

area.y = function(_) {
	return arguments.length ? (y0 = typeof _ === "function" ? _ : d3_shape_src_constant(+_), y1 = null, area) : y0;
};

area.y0 = function(_) {
	return arguments.length ? (y0 = typeof _ === "function" ? _ : d3_shape_src_constant(+_), area) : y0;
};

area.y1 = function(_) {
	return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : d3_shape_src_constant(+_), area) : y1;
};

area.lineX0 =
area.lineY0 = function() {
	return arealine().x(x0).y(y0);
};

area.lineY1 = function() {
	return arealine().x(x0).y(y1);
};

area.lineX1 = function() {
	return arealine().x(x1).y(y0);
};

area.defined = function(_) {
	return arguments.length ? (defined = typeof _ === "function" ? _ : d3_shape_src_constant(!!_), area) : defined;
};

area.curve = function(_) {
	return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
};

area.context = function(_) {
	return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
};

return area;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/descending.js
/* harmony default export */ var src_descending = (function(a, b) {
return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/identity.js
/* harmony default export */ var d3_shape_src_identity = (function(d) {
return d;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/pie.js

/* harmony default export */ var src_pie = (function() {
var value = d3_shape_src_identity,
	  sortValues = src_descending,
	  sort = null,
	  startAngle = d3_shape_src_constant(0),
	  endAngle = d3_shape_src_constant(d3_shape_src_math_tau),
	  padAngle = d3_shape_src_constant(0);

function pie(data) {
	var i,
		n = data.length,
		j,
		k,
		sum = 0,
		index = new Array(n),
		arcs = new Array(n),
		a0 = +startAngle.apply(this, arguments),
		da = Math.min(d3_shape_src_math_tau, Math.max(-d3_shape_src_math_tau, endAngle.apply(this, arguments) - a0)),
		a1,
		p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
		pa = p * (da < 0 ? -1 : 1),
		v;

	for (i = 0; i < n; ++i) {
	  if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
		sum += v;
	  }
	}

	// Optionally sort the arcs by previously-computed values or by data.
	if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
	else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

	// Compute the arcs! They are stored in the original data's order.
	for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
	  j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
		data: data[j],
		index: i,
		value: v,
		startAngle: a0,
		endAngle: a1,
		padAngle: p
	  };
	}

	return arcs;
}

pie.value = function(_) {
	return arguments.length ? (value = typeof _ === "function" ? _ : d3_shape_src_constant(+_), pie) : value;
};

pie.sortValues = function(_) {
	return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
};

pie.sort = function(_) {
	return arguments.length ? (sort = _, sortValues = null, pie) : sort;
};

pie.startAngle = function(_) {
	return arguments.length ? (startAngle = typeof _ === "function" ? _ : d3_shape_src_constant(+_), pie) : startAngle;
};

pie.endAngle = function(_) {
	return arguments.length ? (endAngle = typeof _ === "function" ? _ : d3_shape_src_constant(+_), pie) : endAngle;
};

pie.padAngle = function(_) {
	return arguments.length ? (padAngle = typeof _ === "function" ? _ : d3_shape_src_constant(+_), pie) : padAngle;
};

return pie;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/radial.js

var curveRadialLinear = curveRadial(curve_linear);

function Radial(curve) {
this._curve = curve;
}

Radial.prototype = {
areaStart: function() {
	this._curve.areaStart();
},
areaEnd: function() {
	this._curve.areaEnd();
},
lineStart: function() {
	this._curve.lineStart();
},
lineEnd: function() {
	this._curve.lineEnd();
},
point: function(a, r) {
	this._curve.point(r * Math.sin(a), r * -Math.cos(a));
}
};

function curveRadial(curve) {

function radial(context) {
	return new Radial(curve(context));
}

radial._curve = curve;

return radial;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/lineRadial.js

function lineRadial(l) {
var c = l.curve;

l.angle = l.x, delete l.x;
l.radius = l.y, delete l.y;

l.curve = function(_) {
	return arguments.length ? c(curveRadial(_)) : c()._curve;
};

return l;
}

/* harmony default export */ var src_lineRadial = (function() {
return lineRadial(src_line().curve(curveRadialLinear));
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/areaRadial.js

/* harmony default export */ var areaRadial = (function() {
var a = d3_shape_src_area().curve(curveRadialLinear),
	  c = a.curve,
	  x0 = a.lineX0,
	  x1 = a.lineX1,
	  y0 = a.lineY0,
	  y1 = a.lineY1;

a.angle = a.x, delete a.x;
a.startAngle = a.x0, delete a.x0;
a.endAngle = a.x1, delete a.x1;
a.radius = a.y, delete a.y;
a.innerRadius = a.y0, delete a.y0;
a.outerRadius = a.y1, delete a.y1;
a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

a.curve = function(_) {
	return arguments.length ? c(curveRadial(_)) : c()._curve;
};

return a;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/pointRadial.js
/* harmony default export */ var pointRadial = (function(x, y) {
return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/array.js
var d3_shape_src_array_slice = Array.prototype.slice;

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/link/index.js

function linkSource(d) {
return d.source;
}

function linkTarget(d) {
return d.target;
}

function link_link(curve) {
var source = linkSource,
	  target = linkTarget,
	  x = point_x,
	  y = point_y,
	  context = null;

function link() {
	var buffer;
	var argv = d3_shape_src_array_slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
	if (!context) context = buffer = src_path();
	curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
	if (buffer) return context = null, buffer + "" || null;
}

link.source = function(_) {
	return arguments.length ? (source = _, link) : source;
};

link.target = function(_) {
	return arguments.length ? (target = _, link) : target;
};

link.x = function(_) {
	return arguments.length ? (x = typeof _ === "function" ? _ : d3_shape_src_constant(+_), link) : x;
};

link.y = function(_) {
	return arguments.length ? (y = typeof _ === "function" ? _ : d3_shape_src_constant(+_), link) : y;
};

link.context = function(_) {
	return arguments.length ? ((context = _ == null ? null : _), link) : context;
};

return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
context.moveTo(x0, y0);
context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
context.moveTo(x0, y0);
context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function link_curveRadial(context, x0, y0, x1, y1) {
var p0 = pointRadial(x0, y0),
	  p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
	  p2 = pointRadial(x1, y0),
	  p3 = pointRadial(x1, y1);
context.moveTo(p0[0], p0[1]);
context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
return link_link(curveHorizontal);
}

function linkVertical() {
return link_link(curveVertical);
}

function linkRadial() {
var l = link_link(link_curveRadial);
l.angle = l.x, delete l.x;
l.radius = l.y, delete l.y;
return l;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/circle.js

/* harmony default export */ var symbol_circle = ({
draw: function(context, size) {
	var r = Math.sqrt(size / d3_shape_src_math_pi);
	context.moveTo(r, 0);
	context.arc(0, 0, r, 0, d3_shape_src_math_tau);
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/cross.js
/* harmony default export */ var symbol_cross = ({
draw: function(context, size) {
	var r = Math.sqrt(size / 5) / 2;
	context.moveTo(-3 * r, -r);
	context.lineTo(-r, -r);
	context.lineTo(-r, -3 * r);
	context.lineTo(r, -3 * r);
	context.lineTo(r, -r);
	context.lineTo(3 * r, -r);
	context.lineTo(3 * r, r);
	context.lineTo(r, r);
	context.lineTo(r, 3 * r);
	context.lineTo(-r, 3 * r);
	context.lineTo(-r, r);
	context.lineTo(-3 * r, r);
	context.closePath();
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3),
	tan30_2 = tan30 * 2;

/* harmony default export */ var diamond = ({
draw: function(context, size) {
	var y = Math.sqrt(size / tan30_2),
		x = y * tan30;
	context.moveTo(0, -y);
	context.lineTo(x, 0);
	context.lineTo(0, y);
	context.lineTo(-x, 0);
	context.closePath();
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/star.js

var ka = 0.89081309152928522810,
	kr = Math.sin(d3_shape_src_math_pi / 10) / Math.sin(7 * d3_shape_src_math_pi / 10),
	star_kx = Math.sin(d3_shape_src_math_tau / 10) * kr,
	star_ky = -Math.cos(d3_shape_src_math_tau / 10) * kr;

/* harmony default export */ var star = ({
draw: function(context, size) {
	var r = Math.sqrt(size * ka),
		x = star_kx * r,
		y = star_ky * r;
	context.moveTo(0, -r);
	context.lineTo(x, y);
	for (var i = 1; i < 5; ++i) {
	  var a = d3_shape_src_math_tau * i / 5,
		  c = Math.cos(a),
		  s = Math.sin(a);
	  context.lineTo(s * r, -c * r);
	  context.lineTo(c * x - s * y, s * x + c * y);
	}
	context.closePath();
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/square.js
/* harmony default export */ var square = ({
draw: function(context, size) {
	var w = Math.sqrt(size),
		x = -w / 2;
	context.rect(x, x, w, w);
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

/* harmony default export */ var triangle = ({
draw: function(context, size) {
	var y = -Math.sqrt(size / (sqrt3 * 3));
	context.moveTo(0, y * 2);
	context.lineTo(-sqrt3 * y, -y);
	context.lineTo(sqrt3 * y, -y);
	context.closePath();
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol/wye.js
var wye_c = -0.5,
	wye_s = Math.sqrt(3) / 2,
	wye_k = 1 / Math.sqrt(12),
	wye_a = (wye_k / 2 + 1) * 3;

/* harmony default export */ var wye = ({
draw: function(context, size) {
	var r = Math.sqrt(size / wye_a),
		x0 = r / 2,
		y0 = r * wye_k,
		x1 = x0,
		y1 = r * wye_k + r,
		x2 = -x1,
		y2 = y1;
	context.moveTo(x0, y0);
	context.lineTo(x1, y1);
	context.lineTo(x2, y2);
	context.lineTo(wye_c * x0 - wye_s * y0, wye_s * x0 + wye_c * y0);
	context.lineTo(wye_c * x1 - wye_s * y1, wye_s * x1 + wye_c * y1);
	context.lineTo(wye_c * x2 - wye_s * y2, wye_s * x2 + wye_c * y2);
	context.lineTo(wye_c * x0 + wye_s * y0, wye_c * y0 - wye_s * x0);
	context.lineTo(wye_c * x1 + wye_s * y1, wye_c * y1 - wye_s * x1);
	context.lineTo(wye_c * x2 + wye_s * y2, wye_c * y2 - wye_s * x2);
	context.closePath();
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/symbol.js

var symbols = [
symbol_circle,
symbol_cross,
diamond,
square,
star,
triangle,
wye
];

/* harmony default export */ var src_symbol = (function() {
var type = d3_shape_src_constant(symbol_circle),
	  size = d3_shape_src_constant(64),
	  context = null;

function symbol() {
	var buffer;
	if (!context) context = buffer = src_path();
	type.apply(this, arguments).draw(context, +size.apply(this, arguments));
	if (buffer) return context = null, buffer + "" || null;
}

symbol.type = function(_) {
	return arguments.length ? (type = typeof _ === "function" ? _ : d3_shape_src_constant(_), symbol) : type;
};

symbol.size = function(_) {
	return arguments.length ? (size = typeof _ === "function" ? _ : d3_shape_src_constant(+_), symbol) : size;
};

symbol.context = function(_) {
	return arguments.length ? (context = _ == null ? null : _, symbol) : context;
};

return symbol;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/noop.js
/* harmony default export */ var d3_shape_src_noop = (function() {});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/basis.js
function basis_point(that, x, y) {
that._context.bezierCurveTo(
	(2 * that._x0 + that._x1) / 3,
	(2 * that._y0 + that._y1) / 3,
	(that._x0 + 2 * that._x1) / 3,
	(that._y0 + 2 * that._y1) / 3,
	(that._x0 + 4 * that._x1 + x) / 6,
	(that._y0 + 4 * that._y1 + y) / 6
);
}

function Basis(context) {
this._context = context;
}

Basis.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 =
	this._y0 = this._y1 = NaN;
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 3: basis_point(this, this._x1, this._y1); // proceed
	  case 2: this._context.lineTo(this._x1, this._y1); break;
	}
	if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	  case 1: this._point = 2; break;
	  case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
	  default: basis_point(this, x, y); break;
	}
	this._x0 = this._x1, this._x1 = x;
	this._y0 = this._y1, this._y1 = y;
}
};

/* harmony default export */ var curve_basis = (function(context) {
return new Basis(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/basisClosed.js

function BasisClosed(context) {
this._context = context;
}

BasisClosed.prototype = {
areaStart: d3_shape_src_noop,
areaEnd: d3_shape_src_noop,
lineStart: function() {
	this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
	this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 1: {
		this._context.moveTo(this._x2, this._y2);
		this._context.closePath();
		break;
	  }
	  case 2: {
		this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
		this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
		this._context.closePath();
		break;
	  }
	  case 3: {
		this.point(this._x2, this._y2);
		this.point(this._x3, this._y3);
		this.point(this._x4, this._y4);
		break;
	  }
	}
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
	  case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
	  case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
	  default: basis_point(this, x, y); break;
	}
	this._x0 = this._x1, this._x1 = x;
	this._y0 = this._y1, this._y1 = y;
}
};

/* harmony default export */ var curve_basisClosed = (function(context) {
return new BasisClosed(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/basisOpen.js

function BasisOpen(context) {
this._context = context;
}

BasisOpen.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 =
	this._y0 = this._y1 = NaN;
	this._point = 0;
},
lineEnd: function() {
	if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; break;
	  case 1: this._point = 2; break;
	  case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
	  case 3: this._point = 4; // proceed
	  default: basis_point(this, x, y); break;
	}
	this._x0 = this._x1, this._x1 = x;
	this._y0 = this._y1, this._y1 = y;
}
};

/* harmony default export */ var basisOpen = (function(context) {
return new BasisOpen(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/bundle.js

function Bundle(context, beta) {
this._basis = new Basis(context);
this._beta = beta;
}

Bundle.prototype = {
lineStart: function() {
	this._x = [];
	this._y = [];
	this._basis.lineStart();
},
lineEnd: function() {
	var x = this._x,
		y = this._y,
		j = x.length - 1;

	if (j > 0) {
	  var x0 = x[0],
		  y0 = y[0],
		  dx = x[j] - x0,
		  dy = y[j] - y0,
		  i = -1,
		  t;

	  while (++i <= j) {
		t = i / j;
		this._basis.point(
		  this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
		  this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
		);
	  }
	}

	this._x = this._y = null;
	this._basis.lineEnd();
},
point: function(x, y) {
	this._x.push(+x);
	this._y.push(+y);
}
};

/* harmony default export */ var curve_bundle = ((function custom(beta) {

function bundle(context) {
	return beta === 1 ? new Basis(context) : new Bundle(context, beta);
}

bundle.beta = function(beta) {
	return custom(+beta);
};

return bundle;
})(0.85));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/cardinal.js
function cardinal_point(that, x, y) {
that._context.bezierCurveTo(
	that._x1 + that._k * (that._x2 - that._x0),
	that._y1 + that._k * (that._y2 - that._y0),
	that._x2 + that._k * (that._x1 - x),
	that._y2 + that._k * (that._y1 - y),
	that._x2,
	that._y2
);
}

function Cardinal(context, tension) {
this._context = context;
this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 = this._x2 =
	this._y0 = this._y1 = this._y2 = NaN;
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 2: this._context.lineTo(this._x2, this._y2); break;
	  case 3: cardinal_point(this, this._x1, this._y1); break;
	}
	if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	  case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
	  case 2: this._point = 3; // proceed
	  default: cardinal_point(this, x, y); break;
	}
	this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
}
};

/* harmony default export */ var cardinal = ((function custom(tension) {

function cardinal(context) {
	return new Cardinal(context, tension);
}

cardinal.tension = function(tension) {
	return custom(+tension);
};

return cardinal;
})(0));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/cardinalClosed.js

function CardinalClosed(context, tension) {
this._context = context;
this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
areaStart: d3_shape_src_noop,
areaEnd: d3_shape_src_noop,
lineStart: function() {
	this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 1: {
		this._context.moveTo(this._x3, this._y3);
		this._context.closePath();
		break;
	  }
	  case 2: {
		this._context.lineTo(this._x3, this._y3);
		this._context.closePath();
		break;
	  }
	  case 3: {
		this.point(this._x3, this._y3);
		this.point(this._x4, this._y4);
		this.point(this._x5, this._y5);
		break;
	  }
	}
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	  case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	  case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	  default: cardinal_point(this, x, y); break;
	}
	this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
}
};

/* harmony default export */ var cardinalClosed = ((function custom(tension) {

function cardinal(context) {
	return new CardinalClosed(context, tension);
}

cardinal.tension = function(tension) {
	return custom(+tension);
};

return cardinal;
})(0));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/cardinalOpen.js

function CardinalOpen(context, tension) {
this._context = context;
this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 = this._x2 =
	this._y0 = this._y1 = this._y2 = NaN;
	this._point = 0;
},
lineEnd: function() {
	if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; break;
	  case 1: this._point = 2; break;
	  case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	  case 3: this._point = 4; // proceed
	  default: cardinal_point(this, x, y); break;
	}
	this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
}
};

/* harmony default export */ var cardinalOpen = ((function custom(tension) {

function cardinal(context) {
	return new CardinalOpen(context, tension);
}

cardinal.tension = function(tension) {
	return custom(+tension);
};

return cardinal;
})(0));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/catmullRom.js

function catmullRom_point(that, x, y) {
var x1 = that._x1,
	  y1 = that._y1,
	  x2 = that._x2,
	  y2 = that._y2;

if (that._l01_a > src_math_epsilon) {
	var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
		n = 3 * that._l01_a * (that._l01_a + that._l12_a);
	x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
	y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
}

if (that._l23_a > src_math_epsilon) {
	var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
		m = 3 * that._l23_a * (that._l23_a + that._l12_a);
	x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
	y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
}

that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
this._context = context;
this._alpha = alpha;
}

CatmullRom.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 = this._x2 =
	this._y0 = this._y1 = this._y2 = NaN;
	this._l01_a = this._l12_a = this._l23_a =
	this._l01_2a = this._l12_2a = this._l23_2a =
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 2: this._context.lineTo(this._x2, this._y2); break;
	  case 3: this.point(this._x2, this._y2); break;
	}
	if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;

	if (this._point) {
	  var x23 = this._x2 - x,
		  y23 = this._y2 - y;
	  this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	}

	switch (this._point) {
	  case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	  case 1: this._point = 2; break;
	  case 2: this._point = 3; // proceed
	  default: catmullRom_point(this, x, y); break;
	}

	this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
}
};

/* harmony default export */ var curve_catmullRom = ((function custom(alpha) {

function catmullRom(context) {
	return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
}

catmullRom.alpha = function(alpha) {
	return custom(+alpha);
};

return catmullRom;
})(0.5));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/catmullRomClosed.js

function CatmullRomClosed(context, alpha) {
this._context = context;
this._alpha = alpha;
}

CatmullRomClosed.prototype = {
areaStart: d3_shape_src_noop,
areaEnd: d3_shape_src_noop,
lineStart: function() {
	this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	this._l01_a = this._l12_a = this._l23_a =
	this._l01_2a = this._l12_2a = this._l23_2a =
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 1: {
		this._context.moveTo(this._x3, this._y3);
		this._context.closePath();
		break;
	  }
	  case 2: {
		this._context.lineTo(this._x3, this._y3);
		this._context.closePath();
		break;
	  }
	  case 3: {
		this.point(this._x3, this._y3);
		this.point(this._x4, this._y4);
		this.point(this._x5, this._y5);
		break;
	  }
	}
},
point: function(x, y) {
	x = +x, y = +y;

	if (this._point) {
	  var x23 = this._x2 - x,
		  y23 = this._y2 - y;
	  this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	}

	switch (this._point) {
	  case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	  case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	  case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	  default: catmullRom_point(this, x, y); break;
	}

	this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
}
};

/* harmony default export */ var catmullRomClosed = ((function custom(alpha) {

function catmullRom(context) {
	return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
}

catmullRom.alpha = function(alpha) {
	return custom(+alpha);
};

return catmullRom;
})(0.5));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/catmullRomOpen.js

function CatmullRomOpen(context, alpha) {
this._context = context;
this._alpha = alpha;
}

CatmullRomOpen.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 = this._x2 =
	this._y0 = this._y1 = this._y2 = NaN;
	this._l01_a = this._l12_a = this._l23_a =
	this._l01_2a = this._l12_2a = this._l23_2a =
	this._point = 0;
},
lineEnd: function() {
	if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;

	if (this._point) {
	  var x23 = this._x2 - x,
		  y23 = this._y2 - y;
	  this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	}

	switch (this._point) {
	  case 0: this._point = 1; break;
	  case 1: this._point = 2; break;
	  case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	  case 3: this._point = 4; // proceed
	  default: catmullRom_point(this, x, y); break;
	}

	this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
}
};

/* harmony default export */ var catmullRomOpen = ((function custom(alpha) {

function catmullRom(context) {
	return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
}

catmullRom.alpha = function(alpha) {
	return custom(+alpha);
};

return catmullRom;
})(0.5));

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/linearClosed.js

function LinearClosed(context) {
this._context = context;
}

LinearClosed.prototype = {
areaStart: d3_shape_src_noop,
areaEnd: d3_shape_src_noop,
lineStart: function() {
	this._point = 0;
},
lineEnd: function() {
	if (this._point) this._context.closePath();
},
point: function(x, y) {
	x = +x, y = +y;
	if (this._point) this._context.lineTo(x, y);
	else this._point = 1, this._context.moveTo(x, y);
}
};

/* harmony default export */ var linearClosed = (function(context) {
return new LinearClosed(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/monotone.js
function monotone_sign(x) {
return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
var h0 = that._x1 - that._x0,
	  h1 = x2 - that._x1,
	  s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
	  s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
	  p = (s0 * h1 + s1 * h0) / (h0 + h1);
return (monotone_sign(s0) + monotone_sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
var h = that._x1 - that._x0;
return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function monotone_point(that, t0, t1) {
var x0 = that._x0,
	  y0 = that._y0,
	  x1 = that._x1,
	  y1 = that._y1,
	  dx = (x1 - x0) / 3;
that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
this._context = context;
}

MonotoneX.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x0 = this._x1 =
	this._y0 = this._y1 =
	this._t0 = NaN;
	this._point = 0;
},
lineEnd: function() {
	switch (this._point) {
	  case 2: this._context.lineTo(this._x1, this._y1); break;
	  case 3: monotone_point(this, this._t0, slope2(this, this._t0)); break;
	}
	if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	this._line = 1 - this._line;
},
point: function(x, y) {
	var t1 = NaN;

	x = +x, y = +y;
	if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
	switch (this._point) {
	  case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	  case 1: this._point = 2; break;
	  case 2: this._point = 3; monotone_point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
	  default: monotone_point(this, this._t0, t1 = slope3(this, x, y)); break;
	}

	this._x0 = this._x1, this._x1 = x;
	this._y0 = this._y1, this._y1 = y;
	this._t0 = t1;
}
}

function MonotoneY(context) {
this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
this._context = context;
}

ReflectContext.prototype = {
moveTo: function(x, y) { this._context.moveTo(y, x); },
closePath: function() { this._context.closePath(); },
lineTo: function(x, y) { this._context.lineTo(y, x); },
bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
return new MonotoneX(context);
}

function monotoneY(context) {
return new MonotoneY(context);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
this._context = context;
}

Natural.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x = [];
	this._y = [];
},
lineEnd: function() {
	var x = this._x,
		y = this._y,
		n = x.length;

	if (n) {
	  this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
	  if (n === 2) {
		this._context.lineTo(x[1], y[1]);
	  } else {
		var px = controlPoints(x),
			py = controlPoints(y);
		for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
		  this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
		}
	  }
	}

	if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
	this._line = 1 - this._line;
	this._x = this._y = null;
},
point: function(x, y) {
	this._x.push(+x);
	this._y.push(+y);
}
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
var i,
	  n = x.length - 1,
	  m,
	  a = new Array(n),
	  b = new Array(n),
	  r = new Array(n);
a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
a[n - 1] = r[n - 1] / b[n - 1];
for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
b[n - 1] = (x[n] + a[n - 1]) / 2;
for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
return [a, b];
}

/* harmony default export */ var natural = (function(context) {
return new Natural(context);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
this._context = context;
this._t = t;
}

Step.prototype = {
areaStart: function() {
	this._line = 0;
},
areaEnd: function() {
	this._line = NaN;
},
lineStart: function() {
	this._x = this._y = NaN;
	this._point = 0;
},
lineEnd: function() {
	if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
	if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
},
point: function(x, y) {
	x = +x, y = +y;
	switch (this._point) {
	  case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	  case 1: this._point = 2; // proceed
	  default: {
		if (this._t <= 0) {
		  this._context.lineTo(this._x, y);
		  this._context.lineTo(x, y);
		} else {
		  var x1 = this._x * (1 - this._t) + x * this._t;
		  this._context.lineTo(x1, this._y);
		  this._context.lineTo(x1, y);
		}
		break;
	  }
	}
	this._x = x, this._y = y;
}
};

/* harmony default export */ var curve_step = (function(context) {
return new Step(context, 0.5);
});

function stepBefore(context) {
return new Step(context, 0);
}

function stepAfter(context) {
return new Step(context, 1);
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/offset/none.js
/* harmony default export */ var offset_none = (function(series, order) {
if (!((n = series.length) > 1)) return;
for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
	s0 = s1, s1 = series[order[i]];
	for (j = 0; j < m; ++j) {
	  s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	}
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/order/none.js
/* harmony default export */ var order_none = (function(series) {
var n = series.length, o = new Array(n);
while (--n >= 0) o[n] = n;
return o;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/stack.js

function stackValue(d, key) {
return d[key];
}

/* harmony default export */ var src_stack = (function() {
var keys = d3_shape_src_constant([]),
	  order = order_none,
	  offset = offset_none,
	  value = stackValue;

function stack(data) {
	var kz = keys.apply(this, arguments),
		i,
		m = data.length,
		n = kz.length,
		sz = new Array(n),
		oz;

	for (i = 0; i < n; ++i) {
	  for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
		si[j] = sij = [0, +value(data[j], ki, j, data)];
		sij.data = data[j];
	  }
	  si.key = ki;
	}

	for (i = 0, oz = order(sz); i < n; ++i) {
	  sz[oz[i]].index = i;
	}

	offset(sz, oz);
	return sz;
}

stack.keys = function(_) {
	return arguments.length ? (keys = typeof _ === "function" ? _ : d3_shape_src_constant(d3_shape_src_array_slice.call(_)), stack) : keys;
};

stack.value = function(_) {
	return arguments.length ? (value = typeof _ === "function" ? _ : d3_shape_src_constant(+_), stack) : value;
};

stack.order = function(_) {
	return arguments.length ? (order = _ == null ? order_none : typeof _ === "function" ? _ : d3_shape_src_constant(d3_shape_src_array_slice.call(_)), stack) : order;
};

stack.offset = function(_) {
	return arguments.length ? (offset = _ == null ? offset_none : _, stack) : offset;
};

return stack;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/offset/expand.js

/* harmony default export */ var expand = (function(series, order) {
if (!((n = series.length) > 0)) return;
for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
	for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
	if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
}
offset_none(series, order);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/offset/diverging.js
/* harmony default export */ var diverging = (function(series, order) {
if (!((n = series.length) > 1)) return;
for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
	for (yp = yn = 0, i = 0; i < n; ++i) {
	  if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
		d[0] = yp, d[1] = yp += dy;
	  } else if (dy < 0) {
		d[1] = yn, d[0] = yn += dy;
	  } else {
		d[0] = yp;
	  }
	}
}
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/offset/silhouette.js

/* harmony default export */ var silhouette = (function(series, order) {
if (!((n = series.length) > 0)) return;
for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
	for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
	s0[j][1] += s0[j][0] = -y / 2;
}
offset_none(series, order);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/offset/wiggle.js

/* harmony default export */ var wiggle = (function(series, order) {
if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
	for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
	  var si = series[order[i]],
		  sij0 = si[j][1] || 0,
		  sij1 = si[j - 1][1] || 0,
		  s3 = (sij0 - sij1) / 2;
	  for (var k = 0; k < i; ++k) {
		var sk = series[order[k]],
			skj0 = sk[j][1] || 0,
			skj1 = sk[j - 1][1] || 0;
		s3 += skj0 - skj1;
	  }
	  s1 += sij0, s2 += s3 * sij0;
	}
	s0[j - 1][1] += s0[j - 1][0] = y;
	if (s1) y -= s2 / s1;
}
s0[j - 1][1] += s0[j - 1][0] = y;
offset_none(series, order);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/order/ascending.js

/* harmony default export */ var order_ascending = (function(series) {
var sums = series.map(ascending_sum);
return order_none(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function ascending_sum(series) {
var s = 0, i = -1, n = series.length, v;
while (++i < n) if (v = +series[i][1]) s += v;
return s;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/order/descending.js

/* harmony default export */ var order_descending = (function(series) {
return order_ascending(series).reverse();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/order/insideOut.js

/* harmony default export */ var insideOut = (function(series) {
var n = series.length,
	  i,
	  j,
	  sums = series.map(ascending_sum),
	  order = order_none(series).sort(function(a, b) { return sums[b] - sums[a]; }),
	  top = 0,
	  bottom = 0,
	  tops = [],
	  bottoms = [];

for (i = 0; i < n; ++i) {
	j = order[i];
	if (top < bottom) {
	  top += sums[j];
	  tops.push(j);
	} else {
	  bottom += sums[j];
	  bottoms.push(j);
	}
}

return bottoms.reverse().concat(tops);
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/src/order/reverse.js

/* harmony default export */ var order_reverse = (function(series) {
return order_none(series).reverse();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-shape/index.js

// Note: radialArea is deprecated!
// Note: radialLine is deprecated!

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/constant.js
/* harmony default export */ var d3_voronoi_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/point.js
function src_point_x(d) {
return d[0];
}

function src_point_y(d) {
return d[1];
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/RedBlackTree.js
function RedBlackTree() {
this._ = null; // root node
}

function RedBlackNode(node) {
node.U = // parent node
node.C = // color - true for red, false for black
node.L = // left node
node.R = // right node
node.P = // previous node
node.N = null; // next node
}

RedBlackTree.prototype = {
constructor: RedBlackTree,

insert: function(after, node) {
	var parent;
	var grandpa;
	var uncle;

	if (after) {
	  node.P = after;
	  node.N = after.N;
	  if (after.N) after.N.P = node;
	  after.N = node;
	  if (after.R) {
		after = after.R;
		while (after.L) after = after.L;
		after.L = node;
	  } else {
		after.R = node;
	  }
	  parent = after;
	} else if (this._) {
	  after = RedBlackFirst(this._);
	  node.P = null;
	  node.N = after;
	  after.P = after.L = node;
	  parent = after;
	} else {
	  node.P = node.N = null;
	  this._ = node;
	  parent = null;
	}
	node.L = node.R = null;
	node.U = parent;
	node.C = true;

	after = node;
	while (parent && parent.C) {
	  grandpa = parent.U;
	  if (parent === grandpa.L) {
		uncle = grandpa.R;
		if (uncle && uncle.C) {
		  parent.C = uncle.C = false;
		  grandpa.C = true;
		  after = grandpa;
		} else {
		  if (after === parent.R) {
			RedBlackRotateLeft(this, parent);
			after = parent;
			parent = after.U;
		  }
		  parent.C = false;
		  grandpa.C = true;
		  RedBlackRotateRight(this, grandpa);
		}
	  } else {
		uncle = grandpa.L;
		if (uncle && uncle.C) {
		  parent.C = uncle.C = false;
		  grandpa.C = true;
		  after = grandpa;
		} else {
		  if (after === parent.L) {
			RedBlackRotateRight(this, parent);
			after = parent;
			parent = after.U;
		  }
		  parent.C = false;
		  grandpa.C = true;
		  RedBlackRotateLeft(this, grandpa);
		}
	  }
	  parent = after.U;
	}
	this._.C = false;
},

remove: function(node) {
	if (node.N) node.N.P = node.P;
	if (node.P) node.P.N = node.N;
	node.N = node.P = null;

	var parent = node.U,
		sibling,
		left = node.L,
		right = node.R,
		next,
		red;

	if (!left) next = right;
	else if (!right) next = left;
	else next = RedBlackFirst(right);

	if (parent) {
	  if (parent.L === node) parent.L = next;
	  else parent.R = next;
	} else {
	  this._ = next;
	}

	if (left && right) {
	  red = next.C;
	  next.C = node.C;
	  next.L = left;
	  left.U = next;
	  if (next !== right) {
		parent = next.U;
		next.U = node.U;
		node = next.R;
		parent.L = node;
		next.R = right;
		right.U = next;
	  } else {
		next.U = parent;
		parent = next;
		node = next.R;
	  }
	} else {
	  red = node.C;
	  node = next;
	}

	if (node) node.U = parent;
	if (red) return;
	if (node && node.C) { node.C = false; return; }

	do {
	  if (node === this._) break;
	  if (node === parent.L) {
		sibling = parent.R;
		if (sibling.C) {
		  sibling.C = false;
		  parent.C = true;
		  RedBlackRotateLeft(this, parent);
		  sibling = parent.R;
		}
		if ((sibling.L && sibling.L.C)
			|| (sibling.R && sibling.R.C)) {
		  if (!sibling.R || !sibling.R.C) {
			sibling.L.C = false;
			sibling.C = true;
			RedBlackRotateRight(this, sibling);
			sibling = parent.R;
		  }
		  sibling.C = parent.C;
		  parent.C = sibling.R.C = false;
		  RedBlackRotateLeft(this, parent);
		  node = this._;
		  break;
		}
	  } else {
		sibling = parent.L;
		if (sibling.C) {
		  sibling.C = false;
		  parent.C = true;
		  RedBlackRotateRight(this, parent);
		  sibling = parent.L;
		}
		if ((sibling.L && sibling.L.C)
		  || (sibling.R && sibling.R.C)) {
		  if (!sibling.L || !sibling.L.C) {
			sibling.R.C = false;
			sibling.C = true;
			RedBlackRotateLeft(this, sibling);
			sibling = parent.L;
		  }
		  sibling.C = parent.C;
		  parent.C = sibling.L.C = false;
		  RedBlackRotateRight(this, parent);
		  node = this._;
		  break;
		}
	  }
	  sibling.C = true;
	  node = parent;
	  parent = parent.U;
	} while (!node.C);

	if (node) node.C = false;
}
};

function RedBlackRotateLeft(tree, node) {
var p = node,
	  q = node.R,
	  parent = p.U;

if (parent) {
	if (parent.L === p) parent.L = q;
	else parent.R = q;
} else {
	tree._ = q;
}

q.U = parent;
p.U = q;
p.R = q.L;
if (p.R) p.R.U = p;
q.L = p;
}

function RedBlackRotateRight(tree, node) {
var p = node,
	  q = node.L,
	  parent = p.U;

if (parent) {
	if (parent.L === p) parent.L = q;
	else parent.R = q;
} else {
	tree._ = q;
}

q.U = parent;
p.U = q;
p.L = q.R;
if (p.L) p.L.U = p;
q.R = p;
}

function RedBlackFirst(node) {
while (node.L) node = node.L;
return node;
}

/* harmony default export */ var src_RedBlackTree = (RedBlackTree);

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/Edge.js

function createEdge(left, right, v0, v1) {
var edge = [null, null],
	  index = Diagram_edges.push(edge) - 1;
edge.left = left;
edge.right = right;
if (v0) setEdgeEnd(edge, left, right, v0);
if (v1) setEdgeEnd(edge, right, left, v1);
cells[left.index].halfedges.push(index);
cells[right.index].halfedges.push(index);
return edge;
}

function createBorderEdge(left, v0, v1) {
var edge = [v0, v1];
edge.left = left;
return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
if (!edge[0] && !edge[1]) {
	edge[0] = vertex;
	edge.left = left;
	edge.right = right;
} else if (edge.left === right) {
	edge[1] = vertex;
} else {
	edge[0] = vertex;
}
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
var a = edge[0],
	  b = edge[1],
	  ax = a[0],
	  ay = a[1],
	  bx = b[0],
	  by = b[1],
	  t0 = 0,
	  t1 = 1,
	  dx = bx - ax,
	  dy = by - ay,
	  r;

r = x0 - ax;
if (!dx && r > 0) return;
r /= dx;
if (dx < 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
} else if (dx > 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
}

r = x1 - ax;
if (!dx && r < 0) return;
r /= dx;
if (dx < 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
} else if (dx > 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
}

r = y0 - ay;
if (!dy && r > 0) return;
r /= dy;
if (dy < 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
} else if (dy > 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
}

r = y1 - ay;
if (!dy && r < 0) return;
r /= dy;
if (dy < 0) {
	if (r > t1) return;
	if (r > t0) t0 = r;
} else if (dy > 0) {
	if (r < t0) return;
	if (r < t1) t1 = r;
}

if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
var v1 = edge[1];
if (v1) return true;

var v0 = edge[0],
	  left = edge.left,
	  right = edge.right,
	  lx = left[0],
	  ly = left[1],
	  rx = right[0],
	  ry = right[1],
	  fx = (lx + rx) / 2,
	  fy = (ly + ry) / 2,
	  fm,
	  fb;

if (ry === ly) {
	if (fx < x0 || fx >= x1) return;
	if (lx > rx) {
	  if (!v0) v0 = [fx, y0];
	  else if (v0[1] >= y1) return;
	  v1 = [fx, y1];
	} else {
	  if (!v0) v0 = [fx, y1];
	  else if (v0[1] < y0) return;
	  v1 = [fx, y0];
	}
} else {
	fm = (lx - rx) / (ry - ly);
	fb = fy - fm * fx;
	if (fm < -1 || fm > 1) {
	  if (lx > rx) {
		if (!v0) v0 = [(y0 - fb) / fm, y0];
		else if (v0[1] >= y1) return;
		v1 = [(y1 - fb) / fm, y1];
	  } else {
		if (!v0) v0 = [(y1 - fb) / fm, y1];
		else if (v0[1] < y0) return;
		v1 = [(y0 - fb) / fm, y0];
	  }
	} else {
	  if (ly < ry) {
		if (!v0) v0 = [x0, fm * x0 + fb];
		else if (v0[0] >= x1) return;
		v1 = [x1, fm * x1 + fb];
	  } else {
		if (!v0) v0 = [x1, fm * x1 + fb];
		else if (v0[0] < x0) return;
		v1 = [x0, fm * x0 + fb];
	  }
	}
}

edge[0] = v0;
edge[1] = v1;
return true;
}

function clipEdges(x0, y0, x1, y1) {
var i = Diagram_edges.length,
	  edge;

while (i--) {
	if (!connectEdge(edge = Diagram_edges[i], x0, y0, x1, y1)
		|| !clipEdge(edge, x0, y0, x1, y1)
		|| !(Math.abs(edge[0][0] - edge[1][0]) > Diagram_epsilon
			|| Math.abs(edge[0][1] - edge[1][1]) > Diagram_epsilon)) {
	  delete Diagram_edges[i];
	}
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/Cell.js

function createCell(site) {
return cells[site.index] = {
	site: site,
	halfedges: []
};
}

function cellHalfedgeAngle(cell, edge) {
var site = cell.site,
	  va = edge.left,
	  vb = edge.right;
if (site === vb) vb = va, va = site;
if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
if (site === va) va = edge[1], vb = edge[0];
else va = edge[0], vb = edge[1];
return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
	if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
	  var index = new Array(m),
		  array = new Array(m);
	  for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, Diagram_edges[halfedges[j]]);
	  index.sort(function(i, j) { return array[j] - array[i]; });
	  for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
	  for (j = 0; j < m; ++j) halfedges[j] = array[j];
	}
}
}

function clipCells(x0, y0, x1, y1) {
var nCells = cells.length,
	  iCell,
	  cell,
	  site,
	  iHalfedge,
	  halfedges,
	  nHalfedges,
	  start,
	  startX,
	  startY,
	  end,
	  endX,
	  endY,
	  cover = true;

for (iCell = 0; iCell < nCells; ++iCell) {
	if (cell = cells[iCell]) {
	  site = cell.site;
	  halfedges = cell.halfedges;
	  iHalfedge = halfedges.length;

	  // Remove any dangling clipped edges.
	  while (iHalfedge--) {
		if (!Diagram_edges[halfedges[iHalfedge]]) {
		  halfedges.splice(iHalfedge, 1);
		}
	  }

	  // Insert any border edges as necessary.
	  iHalfedge = 0, nHalfedges = halfedges.length;
	  while (iHalfedge < nHalfedges) {
		end = cellHalfedgeEnd(cell, Diagram_edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
		start = cellHalfedgeStart(cell, Diagram_edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
		if (Math.abs(endX - startX) > Diagram_epsilon || Math.abs(endY - startY) > Diagram_epsilon) {
		  halfedges.splice(iHalfedge, 0, Diagram_edges.push(createBorderEdge(site, end,
			  Math.abs(endX - x0) < Diagram_epsilon && y1 - endY > Diagram_epsilon ? [x0, Math.abs(startX - x0) < Diagram_epsilon ? startY : y1]
			  : Math.abs(endY - y1) < Diagram_epsilon && x1 - endX > Diagram_epsilon ? [Math.abs(startY - y1) < Diagram_epsilon ? startX : x1, y1]
			  : Math.abs(endX - x1) < Diagram_epsilon && endY - y0 > Diagram_epsilon ? [x1, Math.abs(startX - x1) < Diagram_epsilon ? startY : y0]
			  : Math.abs(endY - y0) < Diagram_epsilon && endX - x0 > Diagram_epsilon ? [Math.abs(startY - y0) < Diagram_epsilon ? startX : x0, y0]
			  : null)) - 1);
		  ++nHalfedges;
		}
	  }

	  if (nHalfedges) cover = false;
	}
}

// If there weren’t any edges, have the closest site cover the extent.
// It doesn’t matter which corner of the extent we measure!
if (cover) {
	var dx;
	var dy;
	var d2;
	var dc = Infinity;

	for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
	  if (cell = cells[iCell]) {
		site = cell.site;
		dx = site[0] - x0;
		dy = site[1] - y0;
		d2 = dx * dx + dy * dy;
		if (d2 < dc) dc = d2, cover = cell;
	  }
	}

	if (cover) {
	  var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
	  cover.halfedges.push(
		Diagram_edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
		Diagram_edges.push(createBorderEdge(site, v01, v11)) - 1,
		Diagram_edges.push(createBorderEdge(site, v11, v10)) - 1,
		Diagram_edges.push(createBorderEdge(site, v10, v00)) - 1
	  );
	}
}

// Lastly delete any cells with no edges; these were entirely clipped.
for (iCell = 0; iCell < nCells; ++iCell) {
	if (cell = cells[iCell]) {
	  if (!cell.halfedges.length) {
		delete cells[iCell];
	  }
	}
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/Circle.js

var circlePool = [];

var firstCircle;

function Circle() {
RedBlackNode(this);
this.x =
this.y =
this.arc =
this.site =
this.cy = null;
}

function attachCircle(arc) {
var lArc = arc.P,
	  rArc = arc.N;

if (!lArc || !rArc) return;

var lSite = lArc.site,
	  cSite = arc.site,
	  rSite = rArc.site;

if (lSite === rSite) return;

var bx = cSite[0],
	  by = cSite[1],
	  ax = lSite[0] - bx,
	  ay = lSite[1] - by,
	  cx = rSite[0] - bx,
	  cy = rSite[1] - by;

var d = 2 * (ax * cy - ay * cx);
if (d >= -Diagram_epsilon2) return;

var ha = ax * ax + ay * ay,
	  hc = cx * cx + cy * cy,
	  x = (cy * ha - ay * hc) / d,
	  y = (ax * hc - cx * ha) / d;

var circle = circlePool.pop() || new Circle;
circle.arc = arc;
circle.site = cSite;
circle.x = x + bx;
circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

arc.circle = circle;

var before = null,
	  node = Diagram_circles._;

while (node) {
	if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
	  if (node.L) node = node.L;
	  else { before = node.P; break; }
	} else {
	  if (node.R) node = node.R;
	  else { before = node; break; }
	}
}

Diagram_circles.insert(before, circle);
if (!before) firstCircle = circle;
}

function detachCircle(arc) {
var circle = arc.circle;
if (circle) {
	if (!circle.P) firstCircle = circle.N;
	Diagram_circles.remove(circle);
	circlePool.push(circle);
	RedBlackNode(circle);
	arc.circle = null;
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/Beach.js

var beachPool = [];

function Beach() {
RedBlackNode(this);
this.edge =
this.site =
this.circle = null;
}

function createBeach(site) {
var beach = beachPool.pop() || new Beach;
beach.site = site;
return beach;
}

function detachBeach(beach) {
detachCircle(beach);
beaches.remove(beach);
beachPool.push(beach);
RedBlackNode(beach);
}

function removeBeach(beach) {
var circle = beach.circle,
	  x = circle.x,
	  y = circle.cy,
	  vertex = [x, y],
	  previous = beach.P,
	  next = beach.N,
	  disappearing = [beach];

detachBeach(beach);

var lArc = previous;
while (lArc.circle
	  && Math.abs(x - lArc.circle.x) < Diagram_epsilon
	  && Math.abs(y - lArc.circle.cy) < Diagram_epsilon) {
	previous = lArc.P;
	disappearing.unshift(lArc);
	detachBeach(lArc);
	lArc = previous;
}

disappearing.unshift(lArc);
detachCircle(lArc);

var rArc = next;
while (rArc.circle
	  && Math.abs(x - rArc.circle.x) < Diagram_epsilon
	  && Math.abs(y - rArc.circle.cy) < Diagram_epsilon) {
	next = rArc.N;
	disappearing.push(rArc);
	detachBeach(rArc);
	rArc = next;
}

disappearing.push(rArc);
detachCircle(rArc);

var nArcs = disappearing.length,
	  iArc;
for (iArc = 1; iArc < nArcs; ++iArc) {
	rArc = disappearing[iArc];
	lArc = disappearing[iArc - 1];
	setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
}

lArc = disappearing[0];
rArc = disappearing[nArcs - 1];
rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

attachCircle(lArc);
attachCircle(rArc);
}

function addBeach(site) {
var x = site[0],
	  directrix = site[1],
	  lArc,
	  rArc,
	  dxl,
	  dxr,
	  node = beaches._;

while (node) {
	dxl = leftBreakPoint(node, directrix) - x;
	if (dxl > Diagram_epsilon) node = node.L; else {
	  dxr = x - rightBreakPoint(node, directrix);
	  if (dxr > Diagram_epsilon) {
		if (!node.R) {
		  lArc = node;
		  break;
		}
		node = node.R;
	  } else {
		if (dxl > -Diagram_epsilon) {
		  lArc = node.P;
		  rArc = node;
		} else if (dxr > -Diagram_epsilon) {
		  lArc = node;
		  rArc = node.N;
		} else {
		  lArc = rArc = node;
		}
		break;
	  }
	}
}

createCell(site);
var newArc = createBeach(site);
beaches.insert(lArc, newArc);

if (!lArc && !rArc) return;

if (lArc === rArc) {
	detachCircle(lArc);
	rArc = createBeach(lArc.site);
	beaches.insert(newArc, rArc);
	newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
	attachCircle(lArc);
	attachCircle(rArc);
	return;
}

if (!rArc) { // && lArc
	newArc.edge = createEdge(lArc.site, newArc.site);
	return;
}

// else lArc !== rArc
detachCircle(lArc);
detachCircle(rArc);

var lSite = lArc.site,
	  ax = lSite[0],
	  ay = lSite[1],
	  bx = site[0] - ax,
	  by = site[1] - ay,
	  rSite = rArc.site,
	  cx = rSite[0] - ax,
	  cy = rSite[1] - ay,
	  d = 2 * (bx * cy - by * cx),
	  hb = bx * bx + by * by,
	  hc = cx * cx + cy * cy,
	  vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

setEdgeEnd(rArc.edge, lSite, rSite, vertex);
newArc.edge = createEdge(lSite, site, null, vertex);
rArc.edge = createEdge(site, rSite, null, vertex);
attachCircle(lArc);
attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
var site = arc.site,
	  rfocx = site[0],
	  rfocy = site[1],
	  pby2 = rfocy - directrix;

if (!pby2) return rfocx;

var lArc = arc.P;
if (!lArc) return -Infinity;

site = lArc.site;
var lfocx = site[0],
	  lfocy = site[1],
	  plby2 = lfocy - directrix;

if (!plby2) return lfocx;

var hl = lfocx - rfocx,
	  aby2 = 1 / pby2 - 1 / plby2,
	  b = hl / plby2;

if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
var rArc = arc.N;
if (rArc) return leftBreakPoint(rArc, directrix);
var site = arc.site;
return site[1] === directrix ? site[0] : Infinity;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/Diagram.js

var Diagram_epsilon = 1e-6;
var Diagram_epsilon2 = 1e-12;
var beaches;
var cells;
var Diagram_circles;
var Diagram_edges;

function triangleArea(a, b, c) {
return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
return b[1] - a[1]
	  || b[0] - a[0];
}

function Diagram(sites, extent) {
var site = sites.sort(lexicographic).pop(),
	  x,
	  y,
	  circle;

Diagram_edges = [];
cells = new Array(sites.length);
beaches = new src_RedBlackTree;
Diagram_circles = new src_RedBlackTree;

while (true) {
	circle = firstCircle;
	if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
	  if (site[0] !== x || site[1] !== y) {
		addBeach(site);
		x = site[0], y = site[1];
	  }
	  site = sites.pop();
	} else if (circle) {
	  removeBeach(circle.arc);
	} else {
	  break;
	}
}

sortCellHalfedges();

if (extent) {
	var x0 = +extent[0][0],
		y0 = +extent[0][1],
		x1 = +extent[1][0],
		y1 = +extent[1][1];
	clipEdges(x0, y0, x1, y1);
	clipCells(x0, y0, x1, y1);
}

this.edges = Diagram_edges;
this.cells = cells;

beaches =
Diagram_circles =
Diagram_edges =
cells = null;
}

Diagram.prototype = {
constructor: Diagram,

polygons: function() {
	var edges = this.edges;

	return this.cells.map(function(cell) {
	  var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
	  polygon.data = cell.site.data;
	  return polygon;
	});
},

triangles: function() {
	var triangles = [],
		edges = this.edges;

	this.cells.forEach(function(cell, i) {
	  if (!(m = (halfedges = cell.halfedges).length)) return;
	  var site = cell.site,
		  halfedges,
		  j = -1,
		  m,
		  s0,
		  e1 = edges[halfedges[m - 1]],
		  s1 = e1.left === site ? e1.right : e1.left;

	  while (++j < m) {
		s0 = s1;
		e1 = edges[halfedges[j]];
		s1 = e1.left === site ? e1.right : e1.left;
		if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
		  triangles.push([site.data, s0.data, s1.data]);
		}
	  }
	});

	return triangles;
},

links: function() {
	return this.edges.filter(function(edge) {
	  return edge.right;
	}).map(function(edge) {
	  return {
		source: edge.left.data,
		target: edge.right.data
	  };
	});
},

find: function(x, y, radius) {
	var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

	// Use the previously-found cell, or start with an arbitrary one.
	while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
	var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

	// Traverse the half-edges to find a closer cell, if any.
	do {
	  cell = that.cells[i0 = i1], i1 = null;
	  cell.halfedges.forEach(function(e) {
		var edge = that.edges[e], v = edge.left;
		if ((v === cell.site || !v) && !(v = edge.right)) return;
		var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
		if (v2 < d2) d2 = v2, i1 = v.index;
	  });
	} while (i1 !== null);

	that._found = i0;

	return radius == null || d2 <= radius * radius ? cell.site : null;
}
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/src/voronoi.js

/* harmony default export */ var src_voronoi = (function() {
var x = src_point_x,
	  y = src_point_y,
	  extent = null;

function voronoi(data) {
	return new Diagram(data.map(function(d, i) {
	  var s = [Math.round(x(d, i, data) / Diagram_epsilon) * Diagram_epsilon, Math.round(y(d, i, data) / Diagram_epsilon) * Diagram_epsilon];
	  s.index = i;
	  s.data = d;
	  return s;
	}), extent);
}

voronoi.polygons = function(data) {
	return voronoi(data).polygons();
};

voronoi.links = function(data) {
	return voronoi(data).links();
};

voronoi.triangles = function(data) {
	return voronoi(data).triangles();
};

voronoi.x = function(_) {
	return arguments.length ? (x = typeof _ === "function" ? _ : d3_voronoi_src_constant(+_), voronoi) : x;
};

voronoi.y = function(_) {
	return arguments.length ? (y = typeof _ === "function" ? _ : d3_voronoi_src_constant(+_), voronoi) : y;
};

voronoi.extent = function(_) {
	return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
};

voronoi.size = function(_) {
	return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
};

return voronoi;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-voronoi/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-zoom/src/constant.js
/* harmony default export */ var d3_zoom_src_constant = (function(x) {
return function() {
	return x;
};
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-zoom/src/event.js
function ZoomEvent(target, type, transform) {
this.target = target;
this.type = type;
this.transform = transform;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
this.k = k;
this.x = x;
this.y = y;
}

Transform.prototype = {
constructor: Transform,
scale: function(k) {
	return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
},
translate: function(x, y) {
	return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
},
apply: function(point) {
	return [point[0] * this.k + this.x, point[1] * this.k + this.y];
},
applyX: function(x) {
	return x * this.k + this.x;
},
applyY: function(y) {
	return y * this.k + this.y;
},
invert: function(location) {
	return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
},
invertX: function(x) {
	return (x - this.x) / this.k;
},
invertY: function(y) {
	return (y - this.y) / this.k;
},
rescaleX: function(x) {
	return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
},
rescaleY: function(y) {
	return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
},
toString: function() {
	return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
}
};

var transform_identity = new Transform(1, 0, 0);

transform_transform.prototype = Transform.prototype;

function transform_transform(node) {
return node.__zoom || transform_identity;
}

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-zoom/src/noevent.js

function src_noevent_nopropagation() {
on_event.stopImmediatePropagation();
}

/* harmony default export */ var d3_zoom_src_noevent = (function() {
on_event.preventDefault();
on_event.stopImmediatePropagation();
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-zoom/src/zoom.js

// Ignore right-click, since that should open the context menu.
function zoom_defaultFilter() {
return !on_event.button;
}

function zoom_defaultExtent() {
var e = this, w, h;
if (e instanceof SVGElement) {
	e = e.ownerSVGElement || e;
	w = e.width.baseVal.value;
	h = e.height.baseVal.value;
} else {
	w = e.clientWidth;
	h = e.clientHeight;
}
return [[0, 0], [w, h]];
}

function defaultTransform() {
return this.__zoom || transform_identity;
}

function defaultWheelDelta() {
return -on_event.deltaY * (on_event.deltaMode ? 120 : 1) / 500;
}

function zoom_defaultTouchable() {
return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
	  dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
	  dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
	  dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
return transform.translate(
	dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
	dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
);
}

/* harmony default export */ var d3_zoom_src_zoom = (function() {
var filter = zoom_defaultFilter,
	  extent = zoom_defaultExtent,
	  constrain = defaultConstrain,
	  wheelDelta = defaultWheelDelta,
	  touchable = zoom_defaultTouchable,
	  scaleExtent = [0, Infinity],
	  translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
	  duration = 250,
	  interpolate = src_zoom,
	  gestures = [],
	  listeners = src_dispatch("start", "zoom", "end"),
	  touchstarting,
	  touchending,
	  touchDelay = 500,
	  wheelDelay = 150,
	  clickDistance2 = 0;

function zoom(selection) {
	selection
		.property("__zoom", defaultTransform)
		.on("wheel.zoom", wheeled)
		.on("mousedown.zoom", mousedowned)
		.on("dblclick.zoom", dblclicked)
	  .filter(touchable)
		.on("touchstart.zoom", touchstarted)
		.on("touchmove.zoom", touchmoved)
		.on("touchend.zoom touchcancel.zoom", touchended)
		.style("touch-action", "none")
		.style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
}

zoom.transform = function(collection, transform) {
	var selection = collection.selection ? collection.selection() : collection;
	selection.property("__zoom", defaultTransform);
	if (collection !== selection) {
	  schedule(collection, transform);
	} else {
	  selection.interrupt().each(function() {
		gesture(this, arguments)
			.start()
			.zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
			.end();
	  });
	}
};

zoom.scaleBy = function(selection, k) {
	zoom.scaleTo(selection, function() {
	  var k0 = this.__zoom.k,
		  k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	  return k0 * k1;
	});
};

zoom.scaleTo = function(selection, k) {
	zoom.transform(selection, function() {
	  var e = extent.apply(this, arguments),
		  t0 = this.__zoom,
		  p0 = centroid(e),
		  p1 = t0.invert(p0),
		  k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	  return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
	});
};

zoom.translateBy = function(selection, x, y) {
	zoom.transform(selection, function() {
	  return constrain(this.__zoom.translate(
		typeof x === "function" ? x.apply(this, arguments) : x,
		typeof y === "function" ? y.apply(this, arguments) : y
	  ), extent.apply(this, arguments), translateExtent);
	});
};

zoom.translateTo = function(selection, x, y) {
	zoom.transform(selection, function() {
	  var e = extent.apply(this, arguments),
		  t = this.__zoom,
		  p = centroid(e);
	  return constrain(transform_identity.translate(p[0], p[1]).scale(t.k).translate(
		typeof x === "function" ? -x.apply(this, arguments) : -x,
		typeof y === "function" ? -y.apply(this, arguments) : -y
	  ), e, translateExtent);
	});
};

function scale(transform, k) {
	k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
	return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
}

function translate(transform, p0, p1) {
	var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
	return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
}

function centroid(extent) {
	return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
}

function schedule(transition, transform, center) {
	transition
		.on("start.zoom", function() { gesture(this, arguments).start(); })
		.on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
		.tween("zoom", function() {
		  var that = this,
			  args = arguments,
			  g = gesture(that, args),
			  e = extent.apply(that, args),
			  p = center || centroid(e),
			  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
			  a = that.__zoom,
			  b = typeof transform === "function" ? transform.apply(that, args) : transform,
			  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
		  return function(t) {
			if (t === 1) t = b; // Avoid rounding error on end.
			else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
			g.zoom(null, t);
		  };
		});
}

function gesture(that, args) {
	for (var i = 0, n = gestures.length, g; i < n; ++i) {
	  if ((g = gestures[i]).that === that) {
		return g;
	  }
	}
	return new Gesture(that, args);
}

function Gesture(that, args) {
	this.that = that;
	this.args = args;
	this.index = -1;
	this.active = 0;
	this.extent = extent.apply(that, args);
}

Gesture.prototype = {
	start: function() {
	  if (++this.active === 1) {
		this.index = gestures.push(this) - 1;
		this.emit("start");
	  }
	  return this;
	},
	zoom: function(key, transform) {
	  if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
	  if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
	  if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
	  this.that.__zoom = transform;
	  this.emit("zoom");
	  return this;
	},
	end: function() {
	  if (--this.active === 0) {
		gestures.splice(this.index, 1);
		this.index = -1;
		this.emit("end");
	  }
	  return this;
	},
	emit: function(type) {
	  customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
	}
};

function wheeled() {
	if (!filter.apply(this, arguments)) return;
	var g = gesture(this, arguments),
		t = this.__zoom,
		k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
		p = mouse(this);

	// If the mouse is in the same location as before, reuse it.
	// If there were recent wheel events, reset the wheel idle timeout.
	if (g.wheel) {
	  if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
		g.mouse[1] = t.invert(g.mouse[0] = p);
	  }
	  clearTimeout(g.wheel);
	}

	// If this wheel event won’t trigger a transform change, ignore it.
	else if (t.k === k) return;

	// Otherwise, capture the mouse point and location at the start.
	else {
	  g.mouse = [p, t.invert(p)];
	  interrupt(this);
	  g.start();
	}

	d3_zoom_src_noevent();
	g.wheel = setTimeout(wheelidled, wheelDelay);
	g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

	function wheelidled() {
	  g.wheel = null;
	  g.end();
	}
}

function mousedowned() {
	if (touchending || !filter.apply(this, arguments)) return;
	var g = gesture(this, arguments),
		v = src_select(on_event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
		p = mouse(this),
		x0 = on_event.clientX,
		y0 = on_event.clientY;

	nodrag(on_event.view);
	src_noevent_nopropagation();
	g.mouse = [p, this.__zoom.invert(p)];
	interrupt(this);
	g.start();

	function mousemoved() {
	  d3_zoom_src_noevent();
	  if (!g.moved) {
		var dx = on_event.clientX - x0, dy = on_event.clientY - y0;
		g.moved = dx * dx + dy * dy > clickDistance2;
	  }
	  g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
	}

	function mouseupped() {
	  v.on("mousemove.zoom mouseup.zoom", null);
	  yesdrag(on_event.view, g.moved);
	  d3_zoom_src_noevent();
	  g.end();
	}
}

function dblclicked() {
	if (!filter.apply(this, arguments)) return;
	var t0 = this.__zoom,
		p0 = mouse(this),
		p1 = t0.invert(p0),
		k1 = t0.k * (on_event.shiftKey ? 0.5 : 2),
		t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

	d3_zoom_src_noevent();
	if (duration > 0) src_select(this).transition().duration(duration).call(schedule, t1, p0);
	else src_select(this).call(zoom.transform, t1);
}

function touchstarted() {
	if (!filter.apply(this, arguments)) return;
	var g = gesture(this, arguments),
		touches = on_event.changedTouches,
		started,
		n = touches.length, i, t, p;

	src_noevent_nopropagation();
	for (i = 0; i < n; ++i) {
	  t = touches[i], p = src_touch(this, touches, t.identifier);
	  p = [p, this.__zoom.invert(p), t.identifier];
	  if (!g.touch0) g.touch0 = p, started = true;
	  else if (!g.touch1) g.touch1 = p;
	}

	// If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
	if (touchstarting) {
	  touchstarting = clearTimeout(touchstarting);
	  if (!g.touch1) {
		g.end();
		p = src_select(this).on("dblclick.zoom");
		if (p) p.apply(this, arguments);
		return;
	  }
	}

	if (started) {
	  touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
	  interrupt(this);
	  g.start();
	}
}

function touchmoved() {
	var g = gesture(this, arguments),
		touches = on_event.changedTouches,
		n = touches.length, i, t, p, l;

	d3_zoom_src_noevent();
	if (touchstarting) touchstarting = clearTimeout(touchstarting);
	for (i = 0; i < n; ++i) {
	  t = touches[i], p = src_touch(this, touches, t.identifier);
	  if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
	  else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
	}
	t = g.that.__zoom;
	if (g.touch1) {
	  var p0 = g.touch0[0], l0 = g.touch0[1],
		  p1 = g.touch1[0], l1 = g.touch1[1],
		  dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
		  dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
	  t = scale(t, Math.sqrt(dp / dl));
	  p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
	  l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
	}
	else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
	else return;
	g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
}

function touchended() {
	var g = gesture(this, arguments),
		touches = on_event.changedTouches,
		n = touches.length, i, t;

	src_noevent_nopropagation();
	if (touchending) clearTimeout(touchending);
	touchending = setTimeout(function() { touchending = null; }, touchDelay);
	for (i = 0; i < n; ++i) {
	  t = touches[i];
	  if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
	  else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
	}
	if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
	if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
	else g.end();
}

zoom.wheelDelta = function(_) {
	return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : d3_zoom_src_constant(+_), zoom) : wheelDelta;
};

zoom.filter = function(_) {
	return arguments.length ? (filter = typeof _ === "function" ? _ : d3_zoom_src_constant(!!_), zoom) : filter;
};

zoom.touchable = function(_) {
	return arguments.length ? (touchable = typeof _ === "function" ? _ : d3_zoom_src_constant(!!_), zoom) : touchable;
};

zoom.extent = function(_) {
	return arguments.length ? (extent = typeof _ === "function" ? _ : d3_zoom_src_constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
};

zoom.scaleExtent = function(_) {
	return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
};

zoom.translateExtent = function(_) {
	return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
};

zoom.constrain = function(_) {
	return arguments.length ? (constrain = _, zoom) : constrain;
};

zoom.duration = function(_) {
	return arguments.length ? (duration = +_, zoom) : duration;
};

zoom.interpolate = function(_) {
	return arguments.length ? (interpolate = _, zoom) : interpolate;
};

zoom.on = function() {
	var value = listeners.on.apply(listeners, arguments);
	return value === listeners ? zoom : value;
};

zoom.clickDistance = function(_) {
	return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
};

return zoom;
});

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3-zoom/index.js

// CONCATENATED MODULE: /Users/jose.balsas/dev/liferay/clay/node_modules/d3/index.js
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "bisect", function() { return bisect; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "bisectRight", function() { return bisectRight; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return bisectLeft; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ascending", function() { return ascending; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "bisector", function() { return bisector; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "descending", function() { return descending; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "deviation", function() { return deviation; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "extent", function() { return src_extent; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "histogram", function() { return src_histogram; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return freedmanDiaconis; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return scott; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return sturges; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "max", function() { return src_max; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "mean", function() { return src_mean; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "median", function() { return median; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "merge", function() { return src_merge; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "min", function() { return src_min; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "pairs", function() { return pairs; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "permute", function() { return permute; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "quantile", function() { return quantile; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "range", function() { return src_range; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scan", function() { return scan; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "sum", function() { return src_sum; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ticks", function() { return ticks; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return tickIncrement; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tickStep", function() { return tickStep; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "transpose", function() { return src_transpose; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "variance", function() { return variance; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "axisTop", function() { return axisTop; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "axisRight", function() { return axisRight; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "axisBottom", function() { return axisBottom; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "axisLeft", function() { return axisLeft; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "brush", function() { return src_brush; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "brushX", function() { return brushX; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "brushY", function() { return brushY; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "brushSelection", function() { return brushSelection; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "chord", function() { return src_chord; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ribbon", function() { return src_ribbon; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "nest", function() { return src_nest; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "set", function() { return src_set; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "map", function() { return src_map; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "keys", function() { return src_keys; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "values", function() { return src_values; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "entries", function() { return src_entries; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "color", function() { return color_color; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "rgb", function() { return color_rgb; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "lab", function() { return lab; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "cubehelix", function() { return cubehelix_cubehelix; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "contours", function() { return src_contours; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "contourDensity", function() { return src_density; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "dispatch", function() { return src_dispatch; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "drag", function() { return src_drag; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "dragDisable", function() { return nodrag; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "dragEnable", function() { return yesdrag; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return dsv; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "csvParse", function() { return csvParse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return csvParseRows; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "csvFormat", function() { return csvFormat; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return csvFormatRows; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tsvParse", function() { return tsvParse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return tsvParseRows; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return tsvFormat; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return tsvFormatRows; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeLinear", function() { return linear_linear; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeQuad", function() { return quadInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return quadIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return quadOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return quadInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCubic", function() { return cubicInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return cubicIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return cubicOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return cubicInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easePoly", function() { return polyInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return polyIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return polyOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return polyInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeSin", function() { return sinInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return sinIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return sinOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return sinInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeExp", function() { return expInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return expIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return expOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return expInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCircle", function() { return circleInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return circleIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return circleOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return circleInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBounce", function() { return bounceOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return bounceIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return bounceOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return bounceInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBack", function() { return backInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return backIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return backOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return backInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeElastic", function() { return elasticOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return elasticIn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return elasticOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return elasticInOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "blob", function() { return blob; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "buffer", function() { return src_buffer; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "dsv", function() { return dsv_dsv; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "csv", function() { return dsv_csv; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tsv", function() { return dsv_tsv; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "image", function() { return src_image; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "json", function() { return json; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "text", function() { return src_text; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "xml", function() { return xml; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "html", function() { return xml_html; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "svg", function() { return svg; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceCenter", function() { return src_center; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceCollide", function() { return collide; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceLink", function() { return src_link; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceManyBody", function() { return manyBody; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceRadial", function() { return radial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceSimulation", function() { return src_simulation; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceX", function() { return d3_force_src_x; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "forceY", function() { return d3_force_src_y; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return defaultLocale; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "format", function() { return defaultLocale_format; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return defaultLocale_formatPrefix; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "formatLocale", function() { return src_locale; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return formatSpecifier; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return precisionFixed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return precisionPrefix; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "precisionRound", function() { return precisionRound; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoArea", function() { return d3_geo_src_area; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoBounds", function() { return bounds; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return src_centroid; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoCircle", function() { return src_circle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return clip_antimeridian; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return clip_circle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return clip_extent; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return clipRectangle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoContains", function() { return src_contains; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoDistance", function() { return src_distance; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return graticule_graticule; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return graticule10; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return src_interpolate; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoLength", function() { return src_length; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoPath", function() { return d3_geo_src_path; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return albers; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return projection_albersUsa; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return azimuthalEqualArea; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return azimuthalEqualAreaRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return azimuthalEquidistant; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return azimuthalEquidistantRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return conicConformal; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return conicConformalRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return conicEqualArea; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return conicEqualAreaRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return conicEquidistant; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return conicEquidistantRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return equirectangular; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return equirectangularRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return gnomonic; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return gnomonicRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return projection_identity; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoProjection", function() { return projection_projection; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return projectionMutator; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoMercator", function() { return mercator; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return mercatorRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return naturalEarth1; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return naturalEarth1Raw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return orthographic; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return orthographicRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return stereographic; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return stereographicRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return transverseMercator; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return transverseMercatorRaw; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoRotation", function() { return src_rotation; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoStream", function() { return src_stream; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "geoTransform", function() { return src_transform; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "cluster", function() { return cluster; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "hierarchy", function() { return hierarchy; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "pack", function() { return src_pack; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "packSiblings", function() { return siblings; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "packEnclose", function() { return enclose; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "partition", function() { return src_partition; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stratify", function() { return src_stratify; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "tree", function() { return src_tree; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemap", function() { return src_treemap; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemapBinary", function() { return binary; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemapDice", function() { return dice; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemapSlice", function() { return treemap_slice; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemapSliceDice", function() { return sliceDice; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemapSquarify", function() { return squarify; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "treemapResquarify", function() { return treemap_resquarify; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolate", function() { return src_value; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return src_array; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return src_basis; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return basisClosed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return src_date; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return src_number; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return src_object; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return src_round; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateString", function() { return src_string; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return src_zoom; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return src_rgb; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return rgbBasis; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return rgbBasisClosed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return src_hsl; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return hslLong; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return lab_lab; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return src_hcl; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return hclLong; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return src_cubehelix; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return cubehelixLong; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "quantize", function() { return quantize; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "path", function() { return src_path; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "polygonArea", function() { return d3_polygon_src_area; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "polygonCentroid", function() { return d3_polygon_src_centroid; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "polygonHull", function() { return hull; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "polygonContains", function() { return d3_polygon_src_contains; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "polygonLength", function() { return d3_polygon_src_length; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "quadtree", function() { return quadtree; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "randomUniform", function() { return uniform; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "randomNormal", function() { return src_normal; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "randomLogNormal", function() { return logNormal; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "randomBates", function() { return bates; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "randomIrwinHall", function() { return irwinHall; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "randomExponential", function() { return src_exponential; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleBand", function() { return band; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scalePoint", function() { return band_point; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return identity_identity; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return src_linear_linear; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleLog", function() { return log_log; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return ordinal; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return implicit; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scalePow", function() { return pow_pow; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return pow_sqrt; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return quantile_quantile; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return quantize_quantize; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return threshold_threshold; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleTime", function() { return src_time; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return utcTime; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return sequential; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return category10; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return Accent; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return Dark2; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePaired", function() { return Paired; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return Pastel1; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return Pastel2; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return Set1; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return Set2; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return Set3; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return BrBG; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return BrBG_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return PRGn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return PRGn_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return PiYG; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return PiYG_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return PuOr; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePuOr", function() { return PuOr_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return RdBu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeRdBu", function() { return RdBu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return RdGy; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeRdGy", function() { return RdGy_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return RdYlBu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeRdYlBu", function() { return RdYlBu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return RdYlGn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeRdYlGn", function() { return RdYlGn_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return Spectral; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeSpectral", function() { return Spectral_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return BuGn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeBuGn", function() { return BuGn_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return BuPu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeBuPu", function() { return BuPu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return GnBu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeGnBu", function() { return GnBu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return OrRd; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeOrRd", function() { return OrRd_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return PuBuGn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePuBuGn", function() { return PuBuGn_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return PuBu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePuBu", function() { return PuBu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return PuRd; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePuRd", function() { return PuRd_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return RdPu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeRdPu", function() { return RdPu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return YlGnBu; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeYlGnBu", function() { return YlGnBu_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return YlGn; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeYlGn", function() { return YlGn_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return YlOrBr; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeYlOrBr", function() { return YlOrBr_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return YlOrRd; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeYlOrRd", function() { return YlOrRd_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return Blues; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return Blues_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return Greens; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeGreens", function() { return Greens_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return Greys; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeGreys", function() { return Greys_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return Purples; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemePurples", function() { return Purples_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return Reds; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeReds", function() { return Reds_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return Oranges; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "schemeOranges", function() { return Oranges_scheme; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return sequential_multi_cubehelix; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return sequential_multi_rainbow; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return warm; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return cool; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return viridis; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return magma; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return inferno; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return plasma; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "create", function() { return src_create; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "creator", function() { return creator; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "local", function() { return local; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "matcher", function() { return src_matcher; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "mouse", function() { return mouse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "namespace", function() { return namespace; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "namespaces", function() { return namespaces; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "clientPoint", function() { return src_point; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "select", function() { return src_select; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "selectAll", function() { return src_selectAll; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "selection", function() { return src_selection; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "selector", function() { return src_selector; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "selectorAll", function() { return selectorAll; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "style", function() { return styleValue; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "touch", function() { return src_touch; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "touches", function() { return src_touches; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "window", function() { return src_window; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "event", function() { return on_event; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "customEvent", function() { return customEvent; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "arc", function() { return src_arc; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "area", function() { return d3_shape_src_area; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "line", function() { return src_line; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "pie", function() { return src_pie; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "areaRadial", function() { return areaRadial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "radialArea", function() { return areaRadial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "lineRadial", function() { return src_lineRadial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "radialLine", function() { return src_lineRadial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "pointRadial", function() { return pointRadial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return linkHorizontal; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "linkVertical", function() { return linkVertical; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "linkRadial", function() { return linkRadial; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbol", function() { return src_symbol; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbols", function() { return symbols; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return symbol_circle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolCross", function() { return symbol_cross; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return diamond; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return square; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolStar", function() { return star; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return triangle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "symbolWye", function() { return wye; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return curve_basisClosed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return basisOpen; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveBasis", function() { return curve_basis; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveBundle", function() { return curve_bundle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return cardinalClosed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return cardinalOpen; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return cardinal; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return catmullRomClosed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return catmullRomOpen; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return curve_catmullRom; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return linearClosed; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveLinear", function() { return curve_linear; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return monotoneX; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return monotoneY; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveNatural", function() { return natural; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveStep", function() { return curve_step; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return stepAfter; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return stepBefore; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stack", function() { return src_stack; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return expand; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return diverging; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return offset_none; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return silhouette; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return wiggle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return order_ascending; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return order_descending; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return insideOut; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return order_none; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return order_reverse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeInterval", function() { return newInterval; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return src_millisecond; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMilliseconds", function() { return milliseconds; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMillisecond", function() { return src_millisecond; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMilliseconds", function() { return milliseconds; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeSecond", function() { return src_second; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeSeconds", function() { return seconds; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcSecond", function() { return src_second; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcSeconds", function() { return seconds; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMinute", function() { return src_minute; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMinutes", function() { return minutes; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeHour", function() { return src_hour; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeHours", function() { return hours; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeDay", function() { return src_day; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeDays", function() { return days; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeWeek", function() { return sunday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeWeeks", function() { return sundays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeSunday", function() { return sunday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeSundays", function() { return sundays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMonday", function() { return monday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMondays", function() { return mondays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeTuesday", function() { return tuesday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeTuesdays", function() { return tuesdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeWednesday", function() { return wednesday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeWednesdays", function() { return wednesdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeThursday", function() { return thursday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeThursdays", function() { return thursdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeFriday", function() { return friday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeFridays", function() { return fridays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeSaturday", function() { return saturday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeSaturdays", function() { return saturdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMonth", function() { return src_month; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeMonths", function() { return months; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeYear", function() { return src_year; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeYears", function() { return years; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMinute", function() { return src_utcMinute; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return utcMinutes; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcHour", function() { return src_utcHour; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcHours", function() { return utcHours; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcDay", function() { return src_utcDay; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcDays", function() { return utcDays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcWeek", function() { return utcSunday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcWeeks", function() { return utcSundays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcSunday", function() { return utcSunday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcSundays", function() { return utcSundays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMonday", function() { return utcMonday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMondays", function() { return utcMondays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return utcTuesday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return utcTuesdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return utcWednesday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return utcWednesdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcThursday", function() { return utcThursday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return utcThursdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcFriday", function() { return utcFriday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcFridays", function() { return utcFridays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return utcSaturday; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return utcSaturdays; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMonth", function() { return src_utcMonth; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcMonths", function() { return utcMonths; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcYear", function() { return src_utcYear; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcYears", function() { return utcYears; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeFormatDefaultLocale", function() { return defaultLocale_defaultLocale; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeFormat", function() { return timeFormat; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeParse", function() { return timeParse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcFormat", function() { return utcFormat; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "utcParse", function() { return utcParse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeFormatLocale", function() { return formatLocale; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "isoFormat", function() { return isoFormat; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "isoParse", function() { return isoParse; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "timeout", function() { return src_timeout; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interval", function() { return src_interval; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "transition", function() { return src_transition_transition; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "active", function() { return src_active; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "interrupt", function() { return interrupt; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "voronoi", function() { return src_voronoi; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "zoom", function() { return d3_zoom_src_zoom; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return transform_transform; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return transform_identity; });

/***/ }),
/* 14 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
	throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
	throw new Error('clearTimeout has not been defined');
}
(function () {
	try {
		if (typeof setTimeout === 'function') {
			cachedSetTimeout = setTimeout;
		} else {
			cachedSetTimeout = defaultSetTimout;
		}
	} catch (e) {
		cachedSetTimeout = defaultSetTimout;
	}
	try {
		if (typeof clearTimeout === 'function') {
			cachedClearTimeout = clearTimeout;
		} else {
			cachedClearTimeout = defaultClearTimeout;
		}
	} catch (e) {
		cachedClearTimeout = defaultClearTimeout;
	}
} ())
function runTimeout(fun) {
	if (cachedSetTimeout === setTimeout) {
		//normal enviroments in sane situations
		return setTimeout(fun, 0);
	}
	// if setTimeout wasn't available but was latter defined
	if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		cachedSetTimeout = setTimeout;
		return setTimeout(fun, 0);
	}
	try {
		// when when somebody has screwed with setTimeout but no I.E. maddness
		return cachedSetTimeout(fun, 0);
	} catch(e) {
		try {
			// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
			return cachedSetTimeout.call(null, fun, 0);
		} catch(e) {
			// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
			return cachedSetTimeout.call(this, fun, 0);
		}
	}

}
function runClearTimeout(marker) {
	if (cachedClearTimeout === clearTimeout) {
		//normal enviroments in sane situations
		return clearTimeout(marker);
	}
	// if clearTimeout wasn't available but was latter defined
	if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		cachedClearTimeout = clearTimeout;
		return clearTimeout(marker);
	}
	try {
		// when when somebody has screwed with setTimeout but no I.E. maddness
		return cachedClearTimeout(marker);
	} catch (e) {
		try {
			// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
			return cachedClearTimeout.call(null, marker);
		} catch (e) {
			// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
			// Some versions of I.E. have different rules for clearTimeout vs setTimeout
			return cachedClearTimeout.call(this, marker);
		}
	}

}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
	if (!draining || !currentQueue) {
		return;
	}
	draining = false;
	if (currentQueue.length) {
		queue = currentQueue.concat(queue);
	} else {
		queueIndex = -1;
	}
	if (queue.length) {
		drainQueue();
	}
}

function drainQueue() {
	if (draining) {
		return;
	}
	var timeout = runTimeout(cleanUpNextTick);
	draining = true;

	var len = queue.length;
	while (len) {
		currentQueue = queue;
		queue = [];
		while (++queueIndex < len) {
			if (currentQueue) {
				currentQueue[queueIndex].run();
			}
		}
		queueIndex = -1;
		len = queue.length;
	}
	currentQueue = null;
	draining = false;
	runClearTimeout(timeout);
}

process.nextTick = function(fun) {
	var args = new Array(arguments.length - 1);
	if (arguments.length > 1) {
		for (var i = 1; i < arguments.length; i++) {
			args[i - 1] = arguments[i];
		}
	}
	queue.push(new Item(fun, args));
	if (queue.length === 1 && !draining) {
		runTimeout(drainQueue);
	}
};

// v8 likes predictible objects
function Item(fun, array) {
	this.fun = fun;
	this.array = array;
}
Item.prototype.run = function() {
	this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function(name) { return [] }

process.binding = function(name) {
	throw new Error('process.binding is not supported');
};

process.cwd = function() { return '/' };
process.chdir = function(dir) {
	throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var METAL_DATA = '__metal_data__';

/**
 * Set of utilities for dom data operations
 */

var domData = function() {
	function domData() {
		_classCallCheck(this, domData);
	}

	_createClass(domData, null, [{
		key: 'get',

		/**
* Gets Metal.js's data for the given element.
* @param {!Element} element
* @param {string=} name Optional property from the data to be returned.
* @param {*=} initialValue Optional value to the set the requested property
*     to if it doesn't exist yet in the data.
* @return {!Object}
*/
		value: function get(element, name, initialValue) {
			if (!element[METAL_DATA]) {
				element[METAL_DATA] = {};
			}
			if (!name) {
				return element[METAL_DATA];
			}
			if (!(0, _metal.isDef)(element[METAL_DATA][name]) && (0, _metal.isDef)(initialValue)) {
				element[METAL_DATA][name] = initialValue;
			}
			return element[METAL_DATA][name];
		}

		/**
* Checks if the given element has data stored in it.
* @param {!Element} element
* @return {boolean}
*/

	}, {
		key: 'has',
		value: function has(element) {
			return !!element[METAL_DATA];
		}

		/**
* Sets Metal.js's data for the given element.
* @param {!Element} element
* @param {string=} name Property from the data to be set.
* @param {*=} value Value to be set on the element.
* @return {!Object|*}
*/

	}, {
		key: 'set',
		value: function set(element, name, value) {
			if (!element[METAL_DATA]) {
				element[METAL_DATA] = {};
			}
			if (!name || !(0, _metal.isDef)(value)) {
				return element[METAL_DATA];
			}
			element[METAL_DATA][name] = value;
			return element[METAL_DATA][name];
		}
	}]);

	return domData;
}();

exports.default = domData;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getOriginalFns = getOriginalFns;
exports.getOriginalFn = getOriginalFn;
exports.startInterception = startInterception;
exports.stopInterception = stopInterception;

__webpack_require__(27);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Gets the original incremental dom functions.
 * @return {!Object}
 */
function getOriginalFns() {
	return originalFns;
}

/**
 * Gets the original incremental dom function with the given name.
 * @param {string} name
 * @return {!Object}
 */
function getOriginalFn(name) {
	return originalFns[name];
}

/**
 * Starts intercepting calls to incremental dom, replacing them with the given
 * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`
 * and `attr` are the only ones that can't be intercepted, since they'll
 * automatically be converted into equivalent calls to `elementOpen` and
 * `elementClose`.
 * @param {!Object} fns Functions to be called instead of the original ones
 *     from incremental DOM. Should be given as a map from the function name
 *     to the function that should intercept it. All interceptors will receive
 *     the original function as the first argument, the actual arguments from
 *     from the original call following it.
 */
function startInterception(fns) {
	fns.attr = fnAttr;
	fns.elementOpenEnd = fnOpenEnd;
	fns.elementOpenStart = fnOpenStart;
	fns.elementVoid = fnVoid;
	fnStack.push(fns);
}

/**
 * Restores the original `elementOpen` function from incremental dom to the
 * implementation it used before the last call to `startInterception`.
 */
function stopInterception() {
	fnStack.pop();
}

var originalFns = {
	attr: IncrementalDOM.attr,
	attributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],
	elementClose: IncrementalDOM.elementClose,
	elementOpen: IncrementalDOM.elementOpen,
	elementOpenEnd: IncrementalDOM.elementOpenEnd,
	elementOpenStart: IncrementalDOM.elementOpenStart,
	elementVoid: IncrementalDOM.elementVoid,
	text: IncrementalDOM.text
};

var fnStack = [];

var collectedArgs = [];

function fnAttr(name, value) {
	collectedArgs.push(name, value);
}

function fnOpenStart(tag, key, statics) {
	collectedArgs = [tag, key, statics];
}

function fnOpenEnd() {
	var _IncrementalDOM;

	return (_IncrementalDOM = IncrementalDOM).elementOpen.apply(_IncrementalDOM, _toConsumableArray(collectedArgs));
}

function fnVoid() {
	IncrementalDOM.elementOpen.apply(null, arguments);
	return IncrementalDOM.elementClose.apply(null, arguments);
}

function getStack() {
	return fnStack.length > 0 ? fnStack[fnStack.length - 1] : null;
}

function buildHandleCall(name) {
	var data = {
		name: name
	};
	var fn = handleCall.bind(data);
	return fn;
}

function handleCall() {
	var name = this.name; // eslint-disable-line
	var stack = getStack();
	var fn = stack && stack[name] || originalFns[name];
	return fn.apply(undefined, arguments);
}

IncrementalDOM.attr = buildHandleCall('attr');
IncrementalDOM.elementClose = buildHandleCall('elementClose');
IncrementalDOM.elementOpen = buildHandleCall('elementOpen');
IncrementalDOM.elementOpenEnd = buildHandleCall('elementOpenEnd');
IncrementalDOM.elementOpenStart = buildHandleCall('elementOpenStart');
IncrementalDOM.elementVoid = buildHandleCall('elementVoid');
IncrementalDOM.text = buildHandleCall('text');

IncrementalDOM.attributes[IncrementalDOM.symbols.default] = buildHandleCall('attributes');

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ChartBase = exports.d3 = exports.bb = undefined;

var _billboard = __webpack_require__(33);

var _metalState = __webpack_require__(3);

var _metal = __webpack_require__(1);

var _data = __webpack_require__(21);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _d = __webpack_require__(13);

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PROP_NAME_MAP = {
	axis: 'axes',
	class: 'classes',
	color: 'colors',
	name: 'names',
	regions: 'regions',
	type: 'types',
	x: 'xs'
};

var DEFAULT_COLORS = ['#4B9BFF', '#FFB46E', '#FF5F5F', '#50D2A0', '#FF73C3', '#9CE269', '#AF78FF', '#FFD76E', '#5FC8FF'];

var DEFAULT_LINE_CASSES = ['bb-line-dashed-2-2', 'bb-line-dashed-2-3', 'bb-line-dashed-2-4', 'bb-line-dashed-3-2', 'bb-line-dashed-3-3', 'bb-line-dashed-3-4', 'bb-line-dashed-4-2', 'bb-line-dashed-4-3', 'bb-line-dashed-4-4'];

var DEFAULT_TILES = ['circles', 'diagonal-left-large', 'diagonal-left-small', 'diagonal-right-large', 'diagonal-right-small', 'horizontal-large', 'horizontal-small', 'vertical-large', 'vertical-small'];

var DEFAULT_POINT_PATTERNS = ['circle', 'rectangle', '<polygon points="2.5 0 0 5 5 5"></polygon>', '<polygon points="2.5 0 0 2.5 2.5 5 5 2.5"></polygon>', '<polygon points="0 0 2.5 5 5 0"></polygon>', '<path d="M5,5 a1,1 0 1,1 5,0">', '<path d="M0,0 a1,1 0 0,0 5,0">', '<rect width="5" height="2.5"></rect>', '<rect width="2.5" height="5"></rect>'];

/**
 * Chart Base prototype.
 * @class ChartBase
 *
 * @mixin
 */
var ChartBase = {
	/**
* @inheritDoc
* @memberof ChartBase
*/
	attached: function attached() {
		var _this = this;

		if ((0, _metal.isServerSide)()) {
			return;
		}

		this._addEventListeners();

		var config = this.getInitialConfig();
		var data = (0, _metal.isDefAndNotNull)(config.columns) ? config.columns : config.data;

		if (!data) {
			return;
		}

		(0, _data.resolveData)(data).then(function (data) {
			_this._resolvedData = data;

			if ((0, _metal.isDefAndNotNull)(_this.props) && (0, _metal.isDefAndNotNull)(_this.props._loading)) {
				_this.props._loading = false;
			} else {
				_this._loading = false;
			}

			if (!(0, _metal.isDefAndNotNull)(data)) {
				_this.emit('chartError', new Error('unable to load Chart data.'));
				return;
			}

			_this._setupPolling();

			var config = _this._constructChartConfig();
			_this.bbChart = _billboard.bb.generate(config);
			_this.emit('chartReady');
		}).catch(function (err) {
			_this.emit('chartError', err);
		});
	},

	/**
* @inheritDoc
* @memberof ChartBase
*/
	disposed: function disposed() {
		if ((0, _metal.isServerSide)()) {
			return;
		}

		if (this._pollingInterval) {
			clearInterval(this._pollingInterval);
			this._pollingInterval = null;
		}

		if (this.bbChart) {
			this.bbChart.destroy();
		}
	},

	/**
* Adds event listeners
* @memberof ChartBase
* @protected
*/
	_addEventListeners: function _addEventListeners() {
		this.on('dataChanged', this._handleDataChanged.bind(this));
		this.on('groupsChanged', this._handleGroupsChanged.bind(this));
		this.on('_loadingChanged', this._handleLoadingChanged.bind(this));
		this.on('regionsChanged', this._handleRegionsChanged.bind(this));
		this.on('sizeChanged', this._handleSizeChanged.bind(this));
		this.on('typeChanged', this._handleTypeChanged.bind(this));
		this.on('xChanged', this._handleXChanged.bind(this));
	},

	/**
* @inheritDoc
* @memberof ChartBase
*/
	shouldUpdate: function shouldUpdate() {
		return false;
	},

	/**
* Constructs `axis` billboard config property.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_constructAxisConfig: function _constructAxisConfig() {
		var state = this._getStateObj();

		return {
			rotated: state.axisRotated,
			x: state.axisX,
			y2: state.axisY2,
			y: state.axisY
		};
	},

	/**
* Constructs config object for `bb.generate` method.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_constructChartConfig: function _constructChartConfig() {
		var state = this._getStateObj();
		var axis = this._constructAxisConfig();
		var data = this._constructDataConfig();
		var zoom = this._constructZoomConfig();
		var color = this._constructTilesConfig();

		var config = {
			area: state.area,
			axis: axis,
			bindto: this.element.querySelector('[ref="chart"]'),
			bubble: state.bubble,
			color: color,
			data: data,
			grid: state.grid,
			legend: state.legend,
			line: state.line,
			loading: state.loading,
			padding: state.padding,
			pie: state.pie,
			point: state.point,
			regions: state.regions,
			resize: state.resizeAuto,
			size: state.size,
			spline: state.splineInterpolationType,
			subchart: state.subchart,
			svg: state.svgClassname,
			title: state.title,
			tooltip: state.tooltip,
			transition: state.transitionDuration,
			zoom: zoom
		};

		/**
* Chart init event.
* @event chartInit
* @memberof ChartBase
*/
		config.oninit = this._emitChartEvent.bind(this, 'chartInit');
		/**
* Chart mouse out event.
* @event chartMouseout
* @memberof ChartBase
*/
		config.onout = this._emitChartEvent.bind(this, 'chartMouseout');
		/**
* Chart mouse over event.
* @event chartMouseover
* @memberof ChartBase
*/
		config.onover = this._emitChartEvent.bind(this, 'chartMouseover');
		/**
* Chart rendered event.
* @event chartRendered
* @memberof ChartBase
*/
		config.onrendered = this._emitChartEvent.bind(this, 'chartRendered');
		/**
* Chart resize event.
* @event chartResize
* @memberof ChartBase
*/
		config.onresize = this._emitChartEvent.bind(this, 'chartResize');
		/**
* Chart resized event.
* @event chartResized
* @memberof ChartBase
*/
		config.onresized = this._emitChartEvent.bind(this, 'chartResized');

		return config;
	},

	/**
* Constructs various `data` billboard properties from `data` state.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_constructChartDataConfig: function _constructChartDataConfig() {
		var data = this._resolvedData;
		var config = {
			columns: this._createDataArray(data)
		};

		for (var i = 0; i < data.length; i++) {
			var column = data[i];

			var id = column.id;

			var keys = Object.keys(column);

			for (var j = 0; j < keys.length; j++) {
				var key = keys[j];

				if (key === 'data' || key === 'id') {
					continue;
				}

				if (key === 'hide') {
					config.hide = config.hide || [];

					if (column.hide) {
						config.hide.push(column.id);
					}
				} else {
					// eslint-disable-next-line
					config[PROP_NAME_MAP[key]] = config[PROP_NAME_MAP[key]] || {};

					config[PROP_NAME_MAP[key]][id] = column[key];
				}
			}
		}

		return config;
	},

	/**
* When tiles for true always leave `colors` empty,
* this ensures that` colors.tiles` is more important.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_constructColorsConfig: function _constructColorsConfig() {
		var _getStateObj = this._getStateObj(),
			colors = _getStateObj.colors,
			color = _getStateObj.color;

		if (color && color.tiles) {
			colors = {};
		}

		return colors;
	},

	/**
* Constructs `data` billboard config property.
* @memberof ChartBase
* @param {boolean} attachListeners
* @protected
* @return {Object}
*/
	_constructDataConfig: function _constructDataConfig() {
		var attachListeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

		var state = this._getStateObj();
		var colors = this._constructColorsConfig();
		var config = {
			color: state.colorFormatter,
			colors: colors,
			empty: state.emptyLabelText,
			groups: state.groups,
			hide: state.hide,
			json: state.json,
			keys: state.keys,
			labels: state.labels,
			mimeType: state.mimeType,
			order: state.order,
			rows: state.rows,
			selection: state.selection,
			type: state.type,
			url: state.url,
			x: state.x,
			xFormat: state.xFormat,
			xLocaltime: state.xLocaltime,
			xSort: state.xSort,
			xs: state.xs
		};

		var dataConfig = this._constructChartDataConfig();

		Object.assign(config, dataConfig);

		if (attachListeners) {
			/**
	* Point click event.
	* @event pointClick
	* @memberof ChartBase
	*/
			config.onclick = this._emitChartEvent.bind(this, 'pointClick');
			/**
	* Point mouse out event.
	* @event pointMouseout
	* @memberof ChartBase
	*/
			config.onout = this._emitChartEvent.bind(this, 'pointMouseout');
			/**
	* Point mouse over event.
	* @event pointMouseoever
	* @memberof ChartBase
	*/
			config.onover = this._emitChartEvent.bind(this, 'pointMouseover');
			/**
	* Data selected event.
	* @event dataSelected
	* @memberof ChartBase
	*/
			config.onselected = this._emitChartEvent.bind(this, 'dataSelected');
			/**
	* Data unselected event.
	* @event dataUnselected
	* @memberof ChartBase
	*/
			config.onunselected = this._emitChartEvent.bind(this, 'dataUnselected');
		}

		return config;
	},

	/**
* Constructs color tiles for passed to billboard.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_constructTilesConfig: function _constructTilesConfig() {
		var _getStateObj2 = this._getStateObj(),
			color = _getStateObj2.color;

		if (color.tiles) {
			var tiles = this._getTiles();

			color.tiles = function() {
				return tiles;
			};
			color.pattern = DEFAULT_COLORS;
		}

		return color;
	},

	/**
* Constructs `zoom` billboard config property.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_constructZoomConfig: function _constructZoomConfig() {
		var state = this._getStateObj();
		var zoom = state.zoom;
		var config = zoom || {};

		/**
* Zoom event.
* @event zoom
* @memberof ChartBase
*/
		config.onzoom = this._emitChartEvent.bind(this, 'zoom');
		/**
* Zoom end event.
* @event zoomEnd
* @memberof ChartBase
*/
		config.onzoomend = this._emitChartEvent.bind(this, 'zoomEnd');
		/**
* Zoom start event.
* @event zoomStart
* @memberof ChartBase
*/
		config.onzoomstart = this._emitChartEvent.bind(this, 'zoomStart');

		return config;
	},

	/**
* Converts `data` state into consumable array for billboard.js
* @memberof ChartBase
* @param {Array} data
* @protected
* @return {Array}
*/
	_createDataArray: function _createDataArray(data) {
		return data.map(function (_ref) {
			var data = _ref.data,
				id = _ref.id;

			return [id].concat(data);
		});
	},

	/**
* Emits event based on arguments array.
* @memberof ChartBase
* @protected
*/
	_emitChartEvent: function _emitChartEvent() {
		this.emit.apply(this, arguments); // eslint-disable-line
	},

	/**
* Gets all columns
* @memberof ChartBase
* @protected
* @return {?Object}
*/
	_getColumns: function _getColumns() {
		return this.data;
	},

	/**
* Gets column by column id.
* @memberof ChartBase
* @param {string} id column id
* @protected
* @return {?Object}
*/
	_getData: function _getData(id) {
		return this.data.find(function (data) {
			return data.id === id;
		});
	},

	/**
* Retrieves state object, used to allow JSX implementation.
* @memberof ChartBase
* @protected
* @return {Object}
*/
	_getStateObj: function _getStateObj() {
		return this;
	},

	/**
* Get all tiles of the DOM.
* @memberof ChartBase
* @protected
* @return {?Elements}
*/
	_getTiles: function _getTiles() {
		return DEFAULT_TILES.filter(function (val) {
			return document.querySelector('#' + val);
		}).map(function (val) {
			return document.querySelector('#' + val);
		});
	},

	/**
* Maps `data` state to chart via `bb.load` method.
* @memberof ChartBase
* @param {Object} event The change event.
* @protected
*/
	_handleDataChanged: function _handleDataChanged(event) {
		this._updateData(event.newVal);
	},

	/**
* Maps `groups` state to chart via `bb.groups` method.
* @memberof ChartBase
* @protected
*/
	_handleGroupsChanged: function _handleGroupsChanged(_ref2) {
		var newVal = _ref2.newVal;

		this.bbChart.groups(newVal);
	},

	/**
* Handles `loading` state.
* @memberof ChartBase
* @protected
*/
	_handleLoadingChanged: function _handleLoadingChanged(_ref3) {
		var newVal = _ref3.newVal;

		var chart = this.element.querySelector('[ref="chart"]');
		var placeholder = this.element.querySelector('[ref="placeholder"]');

		if (!newVal) {
			chart.removeAttribute('hidden');
			placeholder.setAttribute('hidden', 'hidden');
		} else {
			chart.setAttribute('hidden', 'hidden');
			placeholder.removeAttribute('hidden');
		}
	},

	/**
* Maps `regions` state to chart via `bb.regions` method.
* @memberof ChartBase
* @protected
*/
	_handleRegionsChanged: function _handleRegionsChanged(_ref4) {
		var newVal = _ref4.newVal;

		this.bbChart.regions(newVal);
	},

	/**
* Maps `size` state to chart via `bb.resize` method.
* @memberof ChartBase
* @protected
*/
	_handleSizeChanged: function _handleSizeChanged(_ref5) {
		var newVal = _ref5.newVal;

		this.bbChart.resize(newVal);
	},

	/**
* Maps `type` state to chart via `bb.transform` method.
* @memberof ChartBase
* @protected
*/
	_handleTypeChanged: function _handleTypeChanged(_ref6) {
		var newVal = _ref6.newVal;

		this.bbChart.transform(newVal);
	},

	/**
* Maps `x` state to chart via `bb.x` method.
* @memberof ChartBase
* @protected
*/
	_handleXChanged: function _handleXChanged(_ref7) {
		var newVal = _ref7.newVal;

		var column = this._getData(newVal);

		this.bbChart.x(column.data);
	},

	/**
* Maps xs value to data points.
* @memberof ChartBase
* @param {Object} xs
* @protected
* @return {Object}
*/
	_mapXSValues: function _mapXSValues(xs) {
		var _this2 = this;

		return Object.keys(xs).reduce(function (xsValues, key) {
			var value = xs[key];

			var xColumn = _this2._getData(value);

			xsValues[key] = xColumn.data;

			return xsValues;
		}, {});
	},

	/**
* Determines which ids should be passed to the unload property.
* @memberof ChartBase
* @param {Array} newData
* @param {Array} prevData
* @return {Array}
* @static
*/
	_resolveRemovedData: function _resolveRemovedData(newData, prevData) {
		var ids = newData.map(function (data) {
			return data[0];
		});

		return prevData.reduce(function (removedIds, data) {
			var id = data[0];

			if (ids.indexOf(id) === -1) {
				removedIds.push(id);
			}

			return removedIds;
		}, []);
	},

	/**
* Set's the chart's data
* @memberof ChartBase
* @param {?Object} columns The data to use.
* @protected
*/
	_setColumns: function _setColumns(columns) {
		this.data = columns;
	},

	/**
* Sets up the polling interval.
* @memberof ChartBase
* @protected
*/
	_setupPolling: function _setupPolling() {
		var _this3 = this;

		var config = this.getInitialConfig();
		var data = config.data;
		var pollingInterval = config.pollingInterval;

		if (pollingInterval) {
			if (this._pollingInterval) {
				clearInterval(this._pollingInterval);
			}

			this._pollingInterval = setInterval(function () {
				_this3._updateData(data);
			}, pollingInterval);
		}
	},

	/**
* Updates the chart's data.
* @memberof ChartBase
* @param {Object} data The new data to load
* @protected
*/
	_updateData: function _updateData(data) {
		var _this4 = this;

		(0, _data.resolveData)(data).then(function (val) {
			var prevVal = _this4._createDataArray(_this4._resolvedData);

			_this4._resolvedData = val;

			var data = _this4._constructDataConfig(false);
			var newVal = data.columns;
			var removedIds = _this4._resolveRemovedData(newVal, prevVal);

			if (removedIds.length) {
				data.unload = removedIds;
			}

			_this4.bbChart.load(data);

			if (data.xs) {
				_this4.bbChart.xs(_this4._mapXSValues(data.xs));
			}

			_this4.emit('dataResolved', data);
		});
	}
};

/**
 * State definition.
 * @static
 * @type {!Object}
 */
ChartBase.STATE = {
	/**
* Sets the `loading` state.
*/
	_loading: _metalState.Config.bool().internal().value(true),

	/**
* Data that will be rendered to the chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	area: _metalState.Config.shapeOf({
		above: _metalState.Config.bool().value(false),
		zerobased: _metalState.Config.bool().value(true)
	}),

	/**
* Switches the x and y axis.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	axisRotated: _metalState.Config.bool(),

	/**
* Styling and behavior of x axis.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	axisX: _metalState.Config.shapeOf({
		categories: _metalState.Config.array(),
		extent: _metalState.Config.array(),
		height: _metalState.Config.number(),
		label: _metalState.Config.object().string(),
		localtime: _metalState.Config.bool(),
		max: _metalState.Config.number(),
		min: _metalState.Config.number(),
		padding: _metalState.Config.oneOfType([_metalState.Config.number(), _metalState.Config.object()]),
		show: _metalState.Config.bool(),
		tick: _metalState.Config.shapeOf({
			centered: _metalState.Config.bool(),
			count: _metalState.Config.number(),
			culling: _metalState.Config.bool().shapeOf({
				max: _metalState.Config.number()
			}),
			fit: _metalState.Config.bool(),
			format: _metalState.Config.oneOfType([_metalState.Config.func(), _metalState.Config.string()]),
			multiline: _metalState.Config.bool(),
			outer: _metalState.Config.bool(),
			rotate: _metalState.Config.number(),
			values: _metalState.Config.array(),
			width: _metalState.Config.number()
		}),
		type: _metalState.Config.oneOf(['category', 'indexed', 'timeseries'])
	}),

	/**
* Styling and behavior of y2 axis.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	axisY2: _metalState.Config.shapeOf({
		center: _metalState.Config.number(),
		default: _metalState.Config.array(),
		inner: _metalState.Config.bool(),
		inverted: _metalState.Config.bool(),
		label: _metalState.Config.object().string(),
		max: _metalState.Config.number(),
		min: _metalState.Config.number(),
		padding: _metalState.Config.oneOfType([_metalState.Config.number(), _metalState.Config.object()]),
		show: _metalState.Config.bool(),
		tick: _metalState.Config.shapeOf({
			count: _metalState.Config.number(),
			format: _metalState.Config.func(),
			outer: _metalState.Config.bool(),
			values: _metalState.Config.array()
		})
	}),

	/**
* Styling and behavior of y axis.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	axisY: _metalState.Config.shapeOf({
		center: _metalState.Config.number(),
		default: _metalState.Config.array(),
		format: _metalState.Config.func(),
		inner: _metalState.Config.bool(),
		inverted: _metalState.Config.bool(),
		label: _metalState.Config.object().string(),
		max: _metalState.Config.number(),
		min: _metalState.Config.number(),
		padding: _metalState.Config.oneOfType([_metalState.Config.number(), _metalState.Config.object()]),
		show: _metalState.Config.bool(),
		tick: _metalState.Config.shapeOf({
			count: _metalState.Config.number(),
			outer: _metalState.Config.bool(),
			values: _metalState.Config.array()
		}),
		type: _metalState.Config.oneOf(['category', 'indexed', 'timeseries'])
	}),

	/**
* Styling and behavior of bars.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	bar: _metalState.Config.shapeOf({
		width: _metalState.Config.number(),
		zerobased: _metalState.Config.bool()
	}),

	/** Styling and behavior of bubbles.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	bubble: _metalState.Config.shapeOf({
		maxR: _metalState.Config.number()
	}),

	/**
* Defines a custom color pattern for chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	color: _metalState.Config.shapeOf({
		pattern: _metalState.Config.array().value(DEFAULT_COLORS),
		threshhold: _metalState.Config.shapeOf({
			unit: _metalState.Config.string(),
			value: _metalState.Config.array(),
			max: _metalState.Config.number()
		}),
		tiles: _metalState.Config.oneOfType([_metalState.Config.bool().value(false), _metalState.Config.func()])
	}).value({
		pattern: DEFAULT_COLORS,
		tiles: false
	}),

	/**
* Defines a custom colors for data in chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	colors: _metalState.Config.object().value({}),

	/**
* Sets billboard's data.color config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Function|undefined)}
*/
	colorFormatter: _metalState.Config.func(),

	/**
* Data that will be rendered to the chart.
* @default undefined
* @deprecated since 2.0.0-rc.2
* @instance
* @memberof ChartBase
* @type {?(Array|undefined)}
*/
	columns: {
		setter: '_setColumns',
		valueFn: '_getColumns'
	},

	/**
* Data that will be rendered to the chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Array|undefined)}
*/
	data: _metalState.Config.oneOfType([_metalState.Config.arrayOf(_metalState.Config.shapeOf({
		axis: _metalState.Config.oneOf(['y', 'y2']),
		class: _metalState.Config.string(),
		color: _metalState.Config.string(),
		data: _metalState.Config.array().required(),
		hide: _metalState.Config.bool(),
		id: _metalState.Config.required().string(),
		name: _metalState.Config.string(),
		regions: _metalState.Config.array(),
		type: _metalState.Config.oneOf(_types2.default.all),
		x: _metalState.Config.string()
	})), _metalState.Config.object(), _metalState.Config.func(), _metalState.Config.string()]),

	/**
* Configuration options for donut chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	donut: _metalState.Config.shapeOf({
		label: _metalState.Config.shapeOf({
			show: _metalState.Config.bool(),
			format: _metalState.Config.func(),
			threshhold: _metalState.Config.number(),
			ratio: _metalState.Config.func().number()
		}),
		expand: _metalState.Config.bool(),
		width: _metalState.Config.number(),
		title: _metalState.Config.string(),
		padAngle: _metalState.Config.number()
	}),

	/**
* Sets label for when no data is loaded.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	emptyLabelText: _metalState.Config.string().setter(function (value) {
		return value ? { empty: { label: { text: value } } } : value;
	}),

	/**
* Configuration options for guage chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	gauge: _metalState.Config.shapeOf({
		fullCircle: _metalState.Config.bool(),
		lable: _metalState.Config.shapeOf({
			show: _metalState.Config.bool(),
			format: _metalState.Config.func()
		}),
		expand: _metalState.Config.bool(),
		min: _metalState.Config.number(),
		max: _metalState.Config.number(),
		startingAngle: _metalState.Config.number(),
		units: _metalState.Config.string(),
		width: _metalState.Config.number()
	}),

	/**
* Configuration options for grid chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	grid: _metalState.Config.shapeOf({
		// Cross reference this with source code, have a feeling this info is wrong
		focus: _metalState.Config.shapeOf({
			show: _metalState.Config.bool()
		}),
		lines: _metalState.Config.shapeOf({
			front: _metalState.Config.bool()
		}),
		x: _metalState.Config.shapeOf({
			show: _metalState.Config.bool(),
			lines: _metalState.Config.shapeOf({
				class: _metalState.Config.string(),
				position: _metalState.Config.oneOf(['start', 'middle', 'end']),
				text: _metalState.Config.string(),
				value: _metalState.Config.string()
			})
		}),
		y: _metalState.Config.shapeOf({
			show: _metalState.Config.bool(),
			lines: _metalState.Config.shapeOf({
				class: _metalState.Config.string(),
				position: _metalState.Config.oneOf(['start', 'middle', 'end']),
				text: _metalState.Config.string(),
				value: _metalState.Config.string()
			})
		}),
		ticks: _metalState.Config.number()
	}).value({
		x: {
			show: true
		},
		y: {
			show: true
		}
	}),

	/**
* Sets billboard's data.groups config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Array|undefined)}
*/
	groups: _metalState.Config.array(),

	/**
* If set to true hides all data.
* @default false
* @instance
* @memberof ChartBase
* @type {?(boolean|undefined)}
*/
	hide: _metalState.Config.bool().value(false),

	/**
* Intersection display options.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	intersection: _metalState.Config.shapeOf({
		enabled: _metalState.Config.bool(),
		brighten: _metalState.Config.bool(),
		inputType: _metalState.Config.shapeOf({
			mouse: _metalState.Config.bool(),
			touch: _metalState.Config.bool()
		})
	}),

	/**
* Sets billboard's data.json config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Array|boolean|undefined)}
*/
	json: _metalState.Config.array(),

	/**
* Sets billboard's data.keys config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Array|undefined)}
*/
	keys: _metalState.Config.array().setter(function (value) {
		return value ? { value: value } : value;
	}),

	/**
* Sets billboard's data.labels config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Boolean|Function|undefined)}
*/
	labels: _metalState.Config.bool().func().setter(function (value) {
		if (!value) {
			return value;
		} else if (typeof value === 'boolean') {
			return {
				labels: value
			};
		} else {
			return {
				labels: {
					format: value
				}
			};
		}
	}),

	/**
* Legend display options.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	legend: _metalState.Config.shapeOf({
		contents: _metalState.Config.shapeOf({
			bindto: _metalState.Config.string(),
			template: _metalState.Config.oneOfType([_metalState.Config.func(), _metalState.Config.string()])
		}),
		hide: _metalState.Config.bool(),
		position: _metalState.Config.oneOf(['bottom', 'inset', 'right']),
		inset: _metalState.Config.shapeOf({
			anchor: _metalState.Config.oneOf(['bottom-left', 'bottom-right', 'top-left', 'top-right']),
			step: _metalState.Config.number(),
			x: _metalState.Config.number(),
			y: _metalState.Config.number()
		}),
		show: _metalState.Config.bool()
	}),

	/**
* Display settings for chart lines.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	line: _metalState.Config.shapeOf({
		classes: _metalState.Config.array(),
		connectNull: _metalState.Config.bool(),
		step: _metalState.Config.shapeOf({
			type: _metalState.Config.oneOf(['step', 'step-after', 'step-before'])
		})
	}).value({
		classes: DEFAULT_LINE_CASSES
	}),

	/**
* Sets billboard's data.mimeType config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	mimeType: _metalState.Config.string(),

	/**
* Sets billboard's data.order config.
* @default desc
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	order: _metalState.Config.string().value('desc'),

	/**
* Sets padding on chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	padding: _metalState.Config.shapeOf({
		bottom: _metalState.Config.number(),
		left: _metalState.Config.number(),
		right: _metalState.Config.number(),
		top: _metalState.Config.number()
	}),

	/**
* Configuration options for pie chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	pie: _metalState.Config.shapeOf({
		label: _metalState.Config.shapeOf({
			show: _metalState.Config.bool(),
			format: _metalState.Config.func(),
			threshhold: _metalState.Config.number(),
			ratio: _metalState.Config.func().number()
		}),
		expand: _metalState.Config.bool(),
		padAngle: _metalState.Config.number()
	}),

	/**
* Configuration options for chart points.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	point: _metalState.Config.shapeOf({
		show: _metalState.Config.bool(),
		r: _metalState.Config.number(),
		focus: _metalState.Config.shapeOf({
			expand: _metalState.Config.shapeOf({
				enabled: _metalState.Config.bool(),
				r: _metalState.Config.bool()
			}),
			select: _metalState.Config.shapeOf({
				r: _metalState.Config.number()
			})
		}),
		pattern: _metalState.Config.array()
	}).value({
		pattern: DEFAULT_POINT_PATTERNS
	}),

	/**
* Set an interval (in ms) to fetch the data.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?Number}
*/
	pollingInterval: _metalState.Config.number(),

	/**
* Creates custom regions on chart that can be styled.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	regions: _metalState.Config.arrayOf(_metalState.Config.shapeOf({
		class: _metalState.Config.string(),
		enabled: _metalState.Config.oneOf(['x', 'y']).required(),
		end: _metalState.Config.oneOfType([_metalState.Config.number(), _metalState.Config.string()]).required(),
		start: _metalState.Config.oneOfType([_metalState.Config.number(), _metalState.Config.string()]).required()
	})),

	/**
* Determines if chart auto resizes when viewport size changes.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(boolean|undefined)}
*/
	resizeAuto: _metalState.Config.bool().setter(function (value) {
		return value ? { auto: value } : value;
	}),

	/**
* Load data from a multidimensional array. Sets billboard's `data.rows`
* config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(array|undefined)}
*/
	rows: _metalState.Config.array(),

	/**
* Sets billboard's `data.selection` config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	selection: _metalState.Config.shapeOf({
		draggable: _metalState.Config.bool(),
		enabled: _metalState.Config.bool(),
		grouped: _metalState.Config.bool(),
		isselectable: _metalState.Config.func(),
		multiple: _metalState.Config.bool()
	}),

	/**
* Sets size of chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	size: _metalState.Config.shapeOf({
		height: _metalState.Config.number(),
		width: _metalState.Config.number()
	}),

	/**
* Determines interpolation type of spline charts.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	splineInterpolationType: _metalState.Config.string().setter(function (value) {
		return value ? { interpolation: { type: value } } : value;
	}),

	/**
* Config options for subcharts.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	subchart: _metalState.Config.shapeOf({
		show: _metalState.Config.bool(),
		size: _metalState.Config.shapeOf({
			height: _metalState.Config.number()
		}),
		onbrush: _metalState.Config.func()
	}),

	/**
* Customizes classname for svg element.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	svgClassname: _metalState.Config.string().setter(function (value) {
		return value ? { classname: value } : value;
	}),

	/**
* Display options for title element.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	title: _metalState.Config.shapeOf({
		text: _metalState.Config.string(),
		padding: _metalState.Config.shapeOf({
			bottom: _metalState.Config.number(),
			left: _metalState.Config.number(),
			right: _metalState.Config.number(),
			top: _metalState.Config.number()
		}),
		position: _metalState.Config.string()
	}),

	/**
* Display options for tooltip.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	tooltip: _metalState.Config.shapeOf({
		show: _metalState.Config.bool(),
		grouped: _metalState.Config.bool(),
		format: _metalState.Config.shapeOf({
			name: _metalState.Config.func(),
			title: _metalState.Config.func(),
			value: _metalState.Config.func()
		}),
		contents: _metalState.Config.func()
	}),

	/**
* Sets duration of transitions.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(number|undefined)}
*/
	transitionDuration: _metalState.Config.number().setter(function (value) {
		return value ? { duration: value } : value;
	}),

	/**
* The variety of chart that will be rendered.
* @default line
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.all).value('line'),

	/**
* Load a CSV or JSON file from a URL.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	url: _metalState.Config.string(),

	/**
* Sets billboard's data.x config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	x: _metalState.Config.string(),

	/**
* Sets billboard's data.xFormat config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(string|undefined)}
*/
	xFormat: _metalState.Config.string(),

	/**
* Sets billboard's data.xLocaltime config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(boolean|undefined)}
*/
	xLocaltime: _metalState.Config.bool(),

	/**
* Sets billboard's data.xSort config.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	xSort: _metalState.Config.bool(),

	/**
* Configuration for bb chart zoom capabilities.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Object|undefined)}
*/
	zoom: _metalState.Config.shapeOf({
		enabled: _metalState.Config.bool().value(true),
		rescale: _metalState.Config.bool().value(false),
		extent: _metalState.Config.array()
	})
};

exports.bb = _billboard.bb;
exports.d3 = d3;
exports.ChartBase = ChartBase;
exports.default = ChartBase;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _metal = __webpack_require__(1);

var ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';
var ERROR_ONE_OF = 'Expected one of the following values:';
var ERROR_ONE_OF_TYPE = 'Expected one of given types.';

/**
 * Provides access to various type validators that will return an
 * instance of Error when validation fails. Note that all type validators
 * will also accept null or undefined values. To not accept these you should
 * instead make your state property required.
 */
var validators = {
	any: function any() {
		return function() {
			return true;
		};
	},
	array: buildTypeValidator('array'),
	bool: buildTypeValidator('boolean'),
	func: buildTypeValidator('function'),
	number: buildTypeValidator('number'),
	object: buildTypeValidator('object'),
	string: buildTypeValidator('string'),

	/**
* Creates a validator that checks that the value it receives is an array
* of items, and that all of the items pass the given validator.
* @param {!function()} validator Validator to check each item against.
* @return {!function()}
*/
	arrayOf: function arrayOf(validator) {
		if (isInvalid(validators.func(validator))) {
			throwConfigError('function', validator, 'arrayOf');
		}
		return maybe(function (value, name, context) {
			var result = validators.array(value, name, context);
			if (isInvalid(result)) {
				return result;
			}
			return validateArrayItems(validator, value, name, context);
		});
	},

	/**
* Creates a validator that checks for a value within a range.
* @param {!Number} min The minimum value allowed.
* @param {!Number} max The maximum value allowed.
* @return {!function()}
*/
	inRange: function inRange(min, max) {
		var minResult = validators.number(min);
		var maxResult = validators.number(max);
		if (isInvalid(minResult)) {
			return minResult;
		}
		if (isInvalid(maxResult)) {
			return maxResult;
		}
		return maybe(function (value) {
			var valueResult = validators.number(value);
			if (isInvalid(valueResult)) {
				return valueResult;
			}
			return value >= min && value <= max;
		});
	},

	/**
* Creates a validator that checks if a value is an instance of a given class.
* @param {!function()} expectedClass Class to check value against.
* @return {!function()}
*/
	instanceOf: function instanceOf(expectedClass) {
		return maybe(function (value, name, context) {
			if (value instanceof expectedClass) {
				return true;
			}
			var msg = 'Expected instance of ' + expectedClass;
			return composeError(msg, name, context);
		});
	},

	/**
* Creates a validator that checks that the value it receives is an object,
* and that all values within that object pass the given validator.
* @param {!function()} validator Validator to check each object value against.
* @return {!function()}
*/
	objectOf: function objectOf(validator) {
		if (isInvalid(validators.func(validator))) {
			throwConfigError('function', validator, 'objectOf');
		}
		return maybe(function (value, name, context) {
			for (var key in value) {
				if (isInvalid(validator(value[key]))) {
					return composeError(ERROR_OBJECT_OF_TYPE, name, context);
				}
			}
			return true;
		});
	},

	/**
* Creates a validator that checks if the received value matches one of the
* given values.
* @param {!Array} arrayOfValues Array of values to check equality against.
* @return {!function()}
*/
	oneOf: function oneOf(arrayOfValues) {
		return maybe(function (value, name, context) {
			var result = validators.array(arrayOfValues, name, context);
			if (isInvalid(result)) {
				return result;
			}
			return arrayOfValues.indexOf(value) === -1 ? composeError(composeOneOfErrorMessage(arrayOfValues), name, context) // eslint-disable-line
			: true;
		});
	},

	/**
* Creates a validator that checks if the received value matches one of the
* given types.
* @param {!Array} arrayOfTypeValidators Array of validators to check value
*     against.
* @return {!function()}
*/
	oneOfType: function oneOfType(arrayOfTypeValidators) {
		return maybe(function (value, name, context) {
			var result = validators.array(arrayOfTypeValidators, name, context); // eslint-disable-line
			if (isInvalid(result)) {
				return result;
			}

			for (var i = 0; i < arrayOfTypeValidators.length; i++) {
				// eslint-disable-next-line
				if (!isInvalid(arrayOfTypeValidators[i](value, name, context))) {
					return true;
				}
			}
			return composeError(ERROR_ONE_OF_TYPE, name, context);
		});
	},

	/**
* Creates a validator that checks if the received value is an object, and
* that its contents match the given shape.
* @param {!Object} shape An object containing validators for each key.
* @return {!function()}
*/
	shapeOf: function shapeOf(shape) {
		if (isInvalid(validators.object(shape))) {
			throwConfigError('object', shape, 'shapeOf');
		}
		return maybe(function (value, name, context) {
			var valueResult = validators.object(value, name, context);
			if (isInvalid(valueResult)) {
				return valueResult;
			}
			for (var key in shape) {
				if (Object.prototype.hasOwnProperty.call(shape, key)) {
					var validator = shape[key];
					var required = false;
					if (validator.config) {
						required = validator.config.required;
						validator = validator.config.validator;
					}
					if (required && !(0, _metal.isDefAndNotNull)(value[key]) || isInvalid(validator(value[key]))) {
						return validator(value[key], name + '.' + key, context);
					}
				}
			}
			return true;
		});
	}
};

/**
 * Creates a validator that checks against a specific primitive type.
 * @param {string} expectedType Type to check against.
 * @return {!function()} Function that runs the validator if called with
 *     arguments, or just returns it otherwise. This means that when using a
 *     type validator in `State` it may be just passed directly (like
 *     `validators.bool`), or called with no args (like `validators.bool()`).
 *     That's done to allow all validators to be used consistently, since some
 *     (like `arrayOf`) always require that you call the function before
 *     receiving the actual validator. Type validators don't need the call, but
 *     work if it's made anyway.
 */
function buildTypeValidator(expectedType) {
	var validatorFn = maybe(validateType.bind(null, expectedType));
	return function() {
		if (arguments.length === 0) {
			return validatorFn;
		} else {
			return validatorFn.apply(undefined, arguments);
		}
	};
}

/**
 * Composes a warning a warning message.
 * @param {string} error Error message to display to console.
 * @param {?string} name Name of state property that is giving the error.
 * @param {Object} context The property's owner.
 * @return {!Error}
 */
function composeError(error, name, context) {
	var compName = context ? (0, _metal.getFunctionName)(context.constructor) : null;
	var renderer = context && context.getRenderer && context.getRenderer();
	var parent = renderer && renderer.getParent && renderer.getParent();
	var parentName = parent ? (0, _metal.getFunctionName)(parent.constructor) : null;
	var location = parentName ? 'Check render method of \'' + parentName + '\'.' : '';
	return new Error('Invalid state passed to \'' + name + '\'.' + (' ' + error + ' Passed to \'' + compName + '\'. ' + location));
}

/**
 * Composes an error message for Config.oneOf validator.
 * @param {!Array} arrayOfValues Array of values to check equality against.
 * @return {!Error}
 */
function composeOneOfErrorMessage(arrayOfValues) {
	return ERROR_ONE_OF + ' ' + JSON.stringify(arrayOfValues) + '.';
}

/**
 * Returns the type of the given value.
 * @param {*} value Any value.
 * @return {string} Type of value.
 */
function getType(value) {
	return Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
}

/**
 * Checks if the given validator result says that the value is invalid.
 * @param {boolean|!Error} result
 * @return {boolean}
 */
function isInvalid(result) {
	return result instanceof Error;
}

/**
 * Wraps the given validator so that it also accepts null/undefined values.
 *   a validator that checks a value against a single type, null, or
 * undefined.
 * @param {!function()} typeValidator Validator to wrap.
 * @return {!function()} Wrapped validator.
 */
function maybe(typeValidator) {
	return function(value, name, context) {
		return (0, _metal.isDefAndNotNull)(value) ? typeValidator(value, name, context) : true; // eslint-disable-line
	};
}

/**
 * Throws error if validator is invoked with incorrect type.
 * @param {string} expectedType String representing the expected type.
 * @param {*} value The value to match the type of.
 * @param {!string} name Name of the function the validator is intended for.
 */
function throwConfigError(expectedType, value, name) {
	var type = getType(value);
	throw new Error('Expected type ' + expectedType + ', but received type ' + type + '. passed to ' + name + '.');
}

/**
 * Checks if all the items of the given array pass the given validator.
 * @param {!function()} validator
 * @param {*} value The array to validate items for.
 * @param {string} name The name of the array property being checked.
 * @param {!Object} context Owner of the array property being checked.
 * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
 */
function validateArrayItems(validator, value, name, context) {
	for (var i = 0; i < value.length; i++) {
		if (isInvalid(validator(value[i], name, context))) {
			var itemValidatorError = validator(value[i], name, context);
			var errorMessage = 'Validator for ' + name + '[' + i + '] says: "' + itemValidatorError + '"';
			return composeError(errorMessage, name, context);
		}
	}
	return true;
}

/**
 * Checks if the given value matches the expected type.
 * @param {string} expectedType String representing the expected type.
 * @param {*} value The value to match the type of.
 * @param {string} name The name of the property being checked.
 * @param {!Object} context Owner of the property being checked.
 * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
 */
function validateType(expectedType, value, name, context) {
	var type = getType(value);
	if (type !== expectedType) {
		var msg = 'Expected type \'' + expectedType + '\', but received type \'' + type + '\'.';
		return composeError(msg, name, context);
	}
	return true;
}

exports.default = validators;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

compatibilityModeData_ = data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
if (compatibilityModeData_ === undefined) {
	if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
	  enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
	}
}
return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
if (!fn.name) {
	var str = fn.toString();
	fn.name = str.substring(9, str.indexOf('('));
}
return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 * @return {Object}
 */
function getStaticProperty(ctor, propertyName) {
var mergeFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getFirstTruthy_;

var mergedName = propertyName + '_MERGED';
if (!ctor.hasOwnProperty(mergedName)) {
	// eslint-disable-next-line
	var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
	if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
	  merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
	}
	ctor[mergedName] = merged;
}
return ctor[mergedName];
}

/**
 * Gets an unique id. If `object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 * @return {number}
 */
function getUid(object, noInheritance) {
if (object) {
	var id = object[UID_PROPERTY];
	if (noInheritance && !object.hasOwnProperty(UID_PROPERTY)) {
	  id = null;
	}
	return id || (object[UID_PROPERTY] = uniqueIdCounter_++);
}
return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(returnValue) {
return returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @param {?Object} options Contains `checkEnv` property which if true, checks
 * the NODE_ENV variable. If NODE_ENV equals 'test', the function returns false.
 * @return {boolean}
 */
function isServerSide() {
var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { checkEnv: true };

var serverSide = typeof process !== 'undefined' && !process.browser;
if (serverSide && options.checkEnv) {
	serverSide = typeof process.env !== 'undefined' && process.env.NODE_ENV !== 'test';
}
return serverSide;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventHandle utility. Holds information about an event subscription, and
 * allows removing them easily.
 * EventHandle is a Disposable, but it's important to note that the
 * EventEmitter that created it is not the one responsible for disposing it.
 * That responsibility is for the code that holds a reference to it.
 * @extends {Disposable}
 */
var EventHandle = function(_Disposable) {
	_inherits(EventHandle, _Disposable);

	/**
* EventHandle constructor
* @param {!EventEmitter} emitter Emitter the event was subscribed to.
* @param {string} event The name of the event that was subscribed to.
* @param {!Function} listener The listener subscribed to the event.
*/
	function EventHandle(emitter, event, listener) {
		_classCallCheck(this, EventHandle);

		/**
* The EventEmitter instance that the event was subscribed to.
* @type {EventEmitter}
* @protected
*/
		var _this = _possibleConstructorReturn(this, (EventHandle.__proto__ || Object.getPrototypeOf(EventHandle)).call(this));

		_this.emitter_ = emitter;

		/**
* The name of the event that was subscribed to.
* @type {string}
* @protected
*/
		_this.event_ = event;

		/**
* The listener subscribed to the event.
* @type {Function}
* @protected
*/
		_this.listener_ = listener;
		return _this;
	}

	/**
* Disposes of this instance's object references.
* @override
*/

	_createClass(EventHandle, [{
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.removeListener();
			this.emitter_ = null;
			this.listener_ = null;
		}

		/**
* Removes the listener subscription from the emitter.
*/

	}, {
		key: 'removeListener',
		value: function removeListener() {
			if (!this.emitter_.isDisposed()) {
				this.emitter_.removeListener(this.event_, this.listener_);
			}
		}
	}]);

	return EventHandle;
}(_metal.Disposable);

exports.default = EventHandle;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.resolveData = resolveData;

var _metal = __webpack_require__(1);

/**
 * @param {Array|Function|Object} data
 * @return {Promise}
 */
function resolveData(data) {
	return new Promise(function (resolve, reject) {
		if (Array.isArray(data) || (0, _metal.isObject)(data) && !(0, _metal.isFunction)(data)) {
			resolve(data);
		} else if ((0, _metal.isFunction)(data)) {
			data().then(function (val) {
				return resolve(val);
			});
		} else if ((0, _metal.isString)(data)) {
			fetch(data, { cors: 'cors' }).then(function (res) {
				return res.json();
			}).then(function (res) {
				if (!(0, _metal.isDefAndNotNull)(res)) {
					return reject(res);
				}
				if ((0, _metal.isDefAndNotNull)(res.data)) {
					return resolve(res.data);
				} else {
					return resolve(res);
				}
			});
		} else {
			reject('Could not resolve data: ' + data);
		}
	});
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.addListenersFromObj = addListenersFromObj;
exports.getComponentFn = getComponentFn;

var _metal = __webpack_require__(1);

/**
 * Adds the listeners specified in the given object.
 * @param {!Component} component
 * @param {Object} events
 * @return {!Array<!EventHandle>} Handles from all subscribed events.
 */
function addListenersFromObj(component, events) {
	var eventNames = Object.keys(events || {});
	var handles = [];
	for (var i = 0; i < eventNames.length; i++) {
		var info = extractListenerInfo_(component, events[eventNames[i]]);
		if (info.fn) {
			var handle = void 0;
			if (info.selector) {
				handle = component.delegate(eventNames[i], info.selector, info.fn); // eslint-disable-line
			} else {
				handle = component.on(eventNames[i], info.fn);
			}
			handles.push(handle);
		}
	}
	return handles;
}

/**
 * Extracts listener info from the given value.
 * @param {!Component} component
 * @param {function()|string|{selector:string,fn:function()}|string} value
 * @return {!{selector:string,fn:function()}}
 * @protected
 */
function extractListenerInfo_(component, value) {
	var info = {
		fn: value
	};
	if ((0, _metal.isObject)(value) && !(0, _metal.isFunction)(value)) {
		info.selector = value.selector;
		info.fn = value.fn;
	}
	if ((0, _metal.isString)(info.fn)) {
		info.fn = getComponentFn(component, info.fn);
	}
	return info;
}

/**
 * Gets the listener function from its name. Throws an error if none exist.
 * @param {!Component} component
 * @param {string} fnName
 * @return {function()}
 */
function getComponentFn(component, fnName) {
	if ((0, _metal.isFunction)(component[fnName])) {
		return component[fnName].bind(component);
	} else {
		console.error('No function named ' + fnName + ' was found in the component\n\t\t\t"' + (0, _metal.getFunctionName)(component.constructor) + '". Make sure that you specify\n\t\t\tvalid function names when adding inline listeners');
	}
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metalEvents = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is a special EventHandle, that is responsible for dom events, instead
 * of EventEmitter events.
 * @extends {EventHandle}
 */
var DomEventHandle = function(_EventHandle) {
	_inherits(DomEventHandle, _EventHandle);

	/**
* The constructor for `DomEventHandle`.
* @param {!EventEmitter} emitter Emitter the event was subscribed to.
* @param {string} event The name of the event that was subscribed to.
* @param {!Function} listener The listener subscribed to the event.
* @param {boolean} capture Flag indicating if listener should be triggered
*   during capture phase, instead of during the bubbling phase. Defaults to false.
* @constructor
*/
	function DomEventHandle(emitter, event, listener, capture) {
		_classCallCheck(this, DomEventHandle);

		var _this = _possibleConstructorReturn(this, (DomEventHandle.__proto__ || Object.getPrototypeOf(DomEventHandle)).call(this, emitter, event, listener));

		_this.capture_ = capture;
		return _this;
	}

	/**
* @inheritDoc
*/

	_createClass(DomEventHandle, [{
		key: 'removeListener',
		value: function removeListener() {
			this.emitter_.removeEventListener(this.event_, this.listener_, this.capture_);
		}
	}]);

	return DomEventHandle;
}(_metalEvents.EventHandle);

exports.default = DomEventHandle;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = __webpack_require__(7);

var _metal = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class with static methods responsible for doing browser feature checks.
 */
var features = function() {
	function features() {
		_classCallCheck(this, features);
	}

	_createClass(features, null, [{
		key: 'checkAnimationEventName',

		/**
* Some browsers still supports prefixed animation events. This method can
* be used to retrieve the current browser event name for both, animation
* and transition.
* @return {object}
*/
		value: function checkAnimationEventName() {
			if (features.animationEventName_ === undefined) {
				features.animationEventName_ = {
					animation: features.checkAnimationEventName_('animation'),
					transition: features.checkAnimationEventName_('transition')
				};
			}
			return features.animationEventName_;
		}

		/**
* @protected
* @param {string} type Type to test: animation, transition.
* @return {string} Browser event name.
*/

	}, {
		key: 'checkAnimationEventName_',
		value: function checkAnimationEventName_(type) {
			var prefixes = ['Webkit', 'MS', 'O', ''];
			var typeTitleCase = _metal.string.replaceInterval(type, 0, 1, type.substring(0, 1).toUpperCase());
			var suffixes = [typeTitleCase + 'End', typeTitleCase + 'End', typeTitleCase + 'End', type + 'end'];
			if (!features.animationElement_) {
				features.animationElement_ = document.createElement('div');
			}
			for (var i = 0; i < prefixes.length; i++) {
				if (features.animationElement_.style[prefixes[i] + typeTitleCase] !== undefined // eslint-disable-line
				) {
						return prefixes[i].toLowerCase() + suffixes[i];
					}
			}
			return type + 'end';
		}

		/**
* Some browsers (like IE9) change the order of element attributes, when html
* is rendered. This method can be used to check if this behavior happens on
* the current browser.
* @return {boolean}
*/

	}, {
		key: 'checkAttrOrderChange',
		value: function checkAttrOrderChange() {
			if (features.attrOrderChange_ === undefined) {
				var originalContent = '<div data-component="" data-ref=""></div>';
				var element = document.createElement('div');
				(0, _dom.append)(element, originalContent);
				features.attrOrderChange_ = originalContent !== element.innerHTML;
			}
			return features.attrOrderChange_;
		}
	}]);

	return features;
}();

features.animationElement_ = undefined;
features.animationEventName_ = undefined;
features.attrOrderChange_ = undefined;

exports.default = features;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

var _metalState = __webpack_require__(3);

var _metalState2 = _interopRequireDefault(_metalState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BLACKLIST = {
	components: true,
	context: true,
	element: true,
	refs: true,
	state: true,
	stateKey: true,
	wasRendered: true
};
var DATA_MANAGER_DATA = '__DATA_MANAGER_DATA__';

/**
 * Class to handle Component Data
 */

var ComponentDataManager = function() {
	function ComponentDataManager() {
		_classCallCheck(this, ComponentDataManager);
	}

	_createClass(ComponentDataManager, [{
		key: 'createState_',

		/**
* Creates the `State` instance that will handle the main component data.
* @param {!Component} component
* @param {!Object} data
* @protected
*/
		value: function createState_(component, data) {
			var state = new _metalState2.default(component.getInitialConfig(), component, component); // eslint-disable-line
			state.setKeysBlacklist(BLACKLIST);
			state.configState(_metal.object.mixin({}, data, _metalState2.default.getStateStatic(component.constructor)));
			this.getManagerData(component).state_ = state;
		}

		/**
* Disposes of any data being used by the manager in this component.
* @param {!Component} component
*/

	}, {
		key: 'dispose',
		value: function dispose(component) {
			var data = this.getManagerData(component);
			if (data.state_) {
				data.state_.dispose();
			}
			component[DATA_MANAGER_DATA] = null;
		}

		/**
* Gets the data with the given name.
* @param {!Component} component
* @param {string} name
* @return {*}
*/

	}, {
		key: 'get',
		value: function get(component, name) {
			return this.getManagerData(component).state_.get(name);
		}

		/**
* Gets the manager data for the given component.
* @param {!Component} component
* @return {Object}
*/

	}, {
		key: 'getManagerData',
		value: function getManagerData(component) {
			return component[DATA_MANAGER_DATA];
		}

		/**
* Gets the keys for state data that can be synced via `sync` functions.
* @param {!Component} component
* @return {!Array<string>}
*/

	}, {
		key: 'getSyncKeys',
		value: function getSyncKeys(component) {
			return this.getManagerData(component).state_.getStateKeys();
		}

		/**
* Gets the keys for state data.
* @param {!Component} component
* @return {!Array<string>}
*/

	}, {
		key: 'getStateKeys',
		value: function getStateKeys(component) {
			return this.getManagerData(component).state_.getStateKeys();
		}

		/**
* Gets the whole state data.
* @param {!Component} component
* @return {!Object}
*/

	}, {
		key: 'getState',
		value: function getState(component) {
			return this.getManagerData(component).state_.getState();
		}

		/**
* Gets the `State` instance being used.
* @param {!Component} component
* @return {!Object}
*/

	}, {
		key: 'getStateInstance',
		value: function getStateInstance(component) {
			return this.getManagerData(component).state_;
		}

		/**
* Updates all non internal data with the given values (or to the default
* value if none is given).
* @param {!Component} component
* @param {!Object} data
* @param {State=} state
*/

	}, {
		key: 'replaceNonInternal',
		value: function replaceNonInternal(component, data) {
			var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getManagerData(component).state_;

			var keys = state.getStateKeys();
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				if (!state.getStateKeyConfig(key).internal) {
					if (data.hasOwnProperty(key)) {
						state.set(key, data[key]);
					} else {
						state.setDefaultValue(key);
					}
				}
			}
		}

		/**
* Sets the value of all the specified state keys.
* @param {!Component} component
* @param {!Object.<string,*>} state A map of state keys to the values they
*   should be set to.
* @param {function()=} callback An optional function that will be run
*   after the next batched update is triggered.
*/

	}, {
		key: 'setState',
		value: function setState(component, state, callback) {
			this.getManagerData(component).state_.setState(state, callback);
		}

		/**
* Sets up the specified component's data.
* @param {!Component} component
* @param {!Object} data
*/

	}, {
		key: 'setUp',
		value: function setUp(component, data) {
			component[DATA_MANAGER_DATA] = {};
			this.createState_(component, data);
		}
	}]);

	return ComponentDataManager;
}();

exports.default = new ComponentDataManager();

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Base class that component renderers should extend from. It defines the
 * required methods all renderers should have.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ComponentRenderer = function() {
	function ComponentRenderer() {
		_classCallCheck(this, ComponentRenderer);
	}

	_createClass(ComponentRenderer, [{
		key: 'dispose',

		/**
* Disposes of any data specific to the given component.
* @param {!Component} component
*/
		value: function dispose() {}

		/**
* Returns extra configuration for data that should be added to the manager.
* Sub classes can override to return `State` config for properties that
* should be added to the component.
* @param {!Component} component
*/

	}, {
		key: 'getExtraDataConfig',
		value: function getExtraDataConfig() {}

		/**
* Renders the whole content (including its main element) and informs the
* component about it. Should be overridden by sub classes.
* @param {!Component} component
*/

	}, {
		key: 'render',
		value: function render(component) {
			if (!component.element) {
				component.element = document.createElement('div');
			}
			component.informRendered();
		}

		/**
* Sets up this component to be used by this renderer. Sub classes should
* override as needed for more behavior.
* @param {!Component} component
*/

	}, {
		key: 'setUp',
		value: function setUp() {}

		/**
* Updates the component's element html. This is automatically called when
* the value of at least one of the component's state keys has changed.
* Should be implemented by sub classes. Sub classes have to remember to call
* "informRendered" on the component when any update rendering is done.
* @param {!Component} component
* @param {Object.<string, Object>} changes Object containing the names
*     of all changed state keys, each mapped to an object with its new
*     (newVal) and previous (prevVal) values.
*/

	}, {
		key: 'update',
		value: function update() {}
	}]);

	return ComponentRenderer;
}();

exports.default = new ComponentRenderer();

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _incrementalDom = __webpack_require__(61);

var IncrementalDOM = _interopRequireWildcard(_incrementalDom);

var _incrementalDomString = __webpack_require__(62);

var IncrementalDOMString = _interopRequireWildcard(_incrementalDomString);

var _metal = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

if ((0, _metal.isServerSide)()) {
	// Overrides global.IncrementalDOM virtual elements with incremental dom
	// string implementation for server side rendering. At the moment it does not
	// override for Node.js tests since tests are using jsdom to simulate the
	// browser.
	global.IncrementalDOM = IncrementalDOMString;
} else {
	var scope = typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window;

	scope.IncrementalDOM = IncrementalDOM;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.clearChanges = clearChanges;
exports.getChanges = getChanges;
exports.trackChanges = trackChanges;

var _data = __webpack_require__(9);

/**
 * Clears the changes tracked so far.
 * @param {!Object} data
 */
function clearChanges(data) {
data.changes = null;
}

/**
 * Handles the `stateKeyChanged` event from a component. Stores change data.
 * @param {!Object} data
 * @param {!Object} eventData
 * @private
 */
function handleStateKeyChanged_(data, eventData) {
data.changes = data.changes || {};
var type = eventData.type || 'props';
data.changes[type] = data.changes[type] || {};
data.changes[type][eventData.key] = eventData;
}

/**
 * Returns an object with changes in the given component since the last time,
 * or null if there weren't any.
 * @param {!Component} component
 * @return {Object}
 */
function getChanges(component) {
return (0, _data.getData)(component).changes;
}

/**
 * Starts tracking changes for the given component
 * @param {!Component} component
 */
function trackChanges(component) {
var data = (0, _data.getData)(component);
component.on('stateKeyChanged', handleStateKeyChanged_.bind(null, data));
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CHILD_OWNER = undefined;
exports.captureChildren = captureChildren;
exports.isChildTag = isChildTag;
exports.getOwner = getOwner;
exports.renderChildTree = renderChildTree;

var _callArgs = __webpack_require__(30);

var _metal = __webpack_require__(1);

var _incrementalDomAop = __webpack_require__(16);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Property identifying a specific object as a Metal.js child node, and
 * pointing to the component instance that created it.
 * @type {string}
 */
var CHILD_OWNER = exports.CHILD_OWNER = '__metalChildOwner';

/**
 * Captures all child elements from incremental dom calls.
 * @param {!Component} component The component that is capturing children.
 * @param {!function()} callback Function to be called when children have all
 *     been captured.
 * @param {Object} data Data to pass to the callback function when calling it.
 */
function captureChildren(component, callback, data) {
	owner_ = component;
	callback_ = callback;
	callbackData_ = data;
	tree_ = {
		props: {
			children: []
		}
	};
	tree_.config = tree_.props;
	currentParent_ = tree_;
	isCapturing_ = true;
	(0, _incrementalDomAop.startInterception)({
		elementClose: handleInterceptedCloseCall_,
		elementOpen: handleInterceptedOpenCall_,
		text: handleInterceptedTextCall_
	});
}

/**
 * Checks if the given tag was built from a component's children.
 * @param {*} tag
 * @return {boolean}
 */
function isChildTag(tag) {
	return (0, _metal.isDef)(tag.tag);
}

/**
 * Gets the node's original owner.
 * @param {!Object} node
 * @return {Component}
 */
function getOwner(node) {
	return node[CHILD_OWNER];
}

/**
 * Renders a children tree through incremental dom.
 * @param {!{args: Array, children: !Array, isText: ?boolean}} tree
 * @param {function()=} skipNode Optional function that is called for
 *     each node to be rendered. If it returns true, the node will be skipped.
 * @protected
 */
function renderChildTree(tree, skipNode) {
	if (isCapturing_) {
		// If capturing, just add the node directly to the captured tree.
		addChildToTree(tree);
		return;
	}

	if (skipNode && skipNode.call(null, tree)) {
		return;
	}

	if ((0, _metal.isDef)(tree.text)) {
		var args = tree.args ? tree.args : [];
		args[0] = tree.text;
		IncrementalDOM.text.apply(null, args);
	} else {
		var _args = (0, _callArgs.buildCallFromConfig)(tree.tag, tree.props);
		_args[0] = {
			tag: _args[0],
			owner: getOwner(tree)
		};
		IncrementalDOM.elementOpen.apply(null, _args);
		if (tree.props.children) {
			for (var i = 0; i < tree.props.children.length; i++) {
				renderChildTree(tree.props.children[i], skipNode);
			}
		}
		IncrementalDOM.elementClose(tree.tag);
	}
}

var callbackData_ = void 0;
var callback_ = void 0;
var currentParent_ = void 0;
var isCapturing_ = false;
var owner_ = void 0;
var tree_ = void 0;

/**
 * Adds a child element to the tree.
 * @param {!Array} args The arguments passed to the incremental dom call.
 * @param {boolean=} isText Optional flag indicating if the child is a
 *     text element.
 * @protected
 * @return {Object}
 */
function addChildCallToTree_(args) {
	var isText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	var child = _defineProperty({
		parent: currentParent_
	}, CHILD_OWNER, owner_);

	if (isText) {
		child.text = args[0];
		if (args.length > 1) {
			child.args = args;
		}
	} else {
		child.tag = args[0];
		child.props = (0, _callArgs.buildConfigFromCall)(args);
		child.props.children = [];
		child.config = child.props;
	}

	addChildToTree(child);
	return child;
}

function addChildToTree(child) {
	currentParent_.props.children.push(child);
}

/**
 * Handles an intercepted call to the `elementClose` function from incremental
 * dom.
 * @protected
 * @return {Element | boolean}
 */
function handleInterceptedCloseCall_() {
	if (currentParent_ === tree_) {
		(0, _incrementalDomAop.stopInterception)();
		isCapturing_ = false;
		var node = callback_.call(owner_, tree_, callbackData_);
		callback_ = null;
		callbackData_ = null;
		currentParent_ = null;
		owner_ = null;
		tree_ = null;
		return node;
	} else {
		currentParent_ = currentParent_.parent;
		return true;
	}
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom.
 * @param {!function()} originalFn The original function before interception.
 * @protected
 */
function handleInterceptedOpenCall_() {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	currentParent_ = addChildCallToTree_(args);
}

/**
 * Handles an intercepted call to the `text` function from incremental dom.
 * @param {!function()} originalFn The original function before interception.
 * @protected
 */
function handleInterceptedTextCall_() {
	for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		args[_key2] = arguments[_key2];
	}

	addChildCallToTree_(args, true);
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Builds the component config object from its incremental dom call's
 * arguments.
 * @param {!Array} args
 * @return {!Object}
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.buildConfigFromCall = buildConfigFromCall;
exports.buildCallFromConfig = buildCallFromConfig;
function buildConfigFromCall(args) {
	var config = {};
	if (args[1]) {
		config.key = args[1];
	}
	var attrsArr = (args[2] || []).concat(args.slice(3));
	for (var i = 0; i < attrsArr.length; i += 2) {
		config[attrsArr[i]] = attrsArr[i + 1];
	}
	return config;
}

/**
 * Builds an incremental dom call array from the given tag and config object.
 * @param {string} tag
 * @param {!Object} config
 * @return {!Array}
 */
function buildCallFromConfig(tag, config) {
	var call = [tag, config.key, []];
	var keys = Object.keys(config);
	for (var i = 0; i < keys.length; i++) {
		if (keys[i] !== 'children' && keys[i] !== 'key') {
			call.push(keys[i], config[keys[i]]);
		}
	}
	return call;
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getComponentBeingRendered = getComponentBeingRendered;
exports.isComponentTag_ = isComponentTag_;
exports.render = render;
exports.renderChild = renderChild;
exports.renderFunction = renderFunction;

var _attributes = __webpack_require__(64);

var _callArgs = __webpack_require__(30);

var _children = __webpack_require__(29);

var _changes = __webpack_require__(28);

var _metalDom = __webpack_require__(11);

var _data = __webpack_require__(9);

var _metal = __webpack_require__(1);

var _unused = __webpack_require__(65);

var _incrementalDomAop = __webpack_require__(16);

var _metalComponent = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var renderingComponents_ = [];
var emptyChildren_ = [];

/**
 * Adds the given css classes to the specified arguments for an incremental
 * dom call, merging with the existing value if there is one.
 * @param {string} elementClasses
 * @param {!Object} config
 * @private
 */
function addElementClasses_(elementClasses, config) {
	if (config.class) {
		config.class += ' ' + elementClasses;
		config.class = removeDuplicateClasses_(config.class);
	} else {
		config.class = elementClasses;
	}
}

/**
 * Builds the "children" array to be passed to the current component.
 * @param {!Array<!Object>} children
 * @return {!Array<!Object>}
 * @private
 */
function buildChildren_(children) {
	return children.length === 0 ? emptyChildren_ : children;
}

/**
 * Finishes the render operation, doing some cleaups.
 * @param {!Component} component
 * @private
 */
function cleanUpRender_(component) {
	(0, _incrementalDomAop.stopInterception)();
	if (!(0, _data.getData)(component).rootElementReached) {
		component.element = null;
	}
	component.informRendered();
	finishedRenderingComponent_();
}

/**
 * Removes the most recent component from the queue of rendering components.
 * @private
 */
function finishedRenderingComponent_() {
	renderingComponents_.pop();
	if (renderingComponents_.length === 0) {
		(0, _unused.disposeUnused)();
	}
}

/**
 * Generates a key for the next element to be rendered.
 * @param {!Component} component
 * @param {?string} key The key originally passed to the element.
 * @return {?string}
 * @private
 */
function generateKey_(component, key) {
	var data = (0, _data.getData)(component);
	if (!data.rootElementReached && data.config.key) {
		key = data.config.key;
	}
	return component.getRenderer().generateKey(component, key);
}

/**
 * Gets the child components stored in the given object.
 * @param {!Object} data
 * @return {!Array<!Component>}
 * @private
 */
function getChildComponents_(data) {
	data.childComponents = data.childComponents || [];
	return data.childComponents;
}

/**
 * Gets the component being currently rendered.
 * @return {Component}
 */
function getComponentBeingRendered() {
	return renderingComponents_[renderingComponents_.length - 1];
}

/**
 * Gets the data object that should be currently used. This object will either
 * come from the current element being rendered by incremental dom or from
 * the component instance being rendered (only when the current element is the
 * component's direct parent).
 * @return {!Object}
 * @private
 */
function getCurrentData() {
	var element = IncrementalDOM.currentElement();
	var comp = getComponentBeingRendered();
	var obj = (0, _data.getData)(comp);
	if (obj.rootElementReached && comp.element && element !== comp.element.parentNode) {
		obj = _metalDom.domData.get(element);
	}
	obj.icComponentsData = obj.icComponentsData || {};
	return obj.icComponentsData;
}

/**
 * Returns the "ref" to be used for a component. Uses "key" as "ref" when
 * compatibility mode is on for the current renderer.
 * @param {!Component} owner
 * @param {!Object} config
 * @return {?string}
 * @private
 */
function getRef_(owner, config) {
	var compatData = (0, _metal.getCompatibilityModeData)();
	if (compatData) {
		var ownerRenderer = owner.getRenderer();
		var renderers = compatData.renderers;
		var useKey = !renderers || renderers.indexOf(ownerRenderer) !== -1 || renderers.indexOf(ownerRenderer.RENDERER_NAME) !== -1;
		if (useKey && config.key && !config.ref) {
			return config.key;
		}
	}
	return config.ref;
}

/**
 * Gets the sub component referenced by the given tag and config data,
 * creating it if it doesn't yet exist.
 * @param {string|!Function} tagOrCtor The tag name.
 * @param {!Object} config The config object for the sub component.
 * @param {!Component} owner
 * @return {!Component} The sub component.
 * @protected
 */
function getSubComponent_(tagOrCtor, config, owner) {
	var Ctor = tagOrCtor;
	if ((0, _metal.isString)(Ctor)) {
		Ctor = _metalComponent.ComponentRegistry.getConstructor(tagOrCtor);
	}

	var ref = getRef_(owner, config);
	var comp = void 0;
	if ((0, _metal.isDef)(ref)) {
		comp = match_(owner.components[ref], Ctor, config, owner);
		owner.components[ref] = comp;
		owner.refs[ref] = comp;
	} else {
		var data = getCurrentData();
		var key = config.key;
		if (!(0, _metal.isDef)(key)) {
			var type = (0, _metal.getUid)(Ctor, true);
			data.currCount = data.currCount || {};
			data.currCount[type] = data.currCount[type] || 0;
			key = '__METAL_IC__' + type + '_' + data.currCount[type]++;
		}
		comp = match_(data.prevComps ? data.prevComps[key] : null, Ctor, config, owner);
		data.currComps = data.currComps || {};
		data.currComps[key] = comp;
	}

	return comp;
}

/**
 * Handles the event of children having finished being captured.
 * @param {!Object} tree The captured children in tree format.
 * @private
 * @return {Object}
 */
function handleChildrenCaptured_(tree, _ref) {
	var props = _ref.props,
		tag = _ref.tag;

	props.children = buildChildren_(tree.props.children);
	return renderFromTag_(tag, props);
}

/**
 * Handles a child being rendered via `IncrementalDomChildren.render`. Skips
 * component nodes so that they can be rendered the correct way without
 * having to recapture both them and their children via incremental dom.
 * @param {!Object} node
 * @return {boolean}
 * @private
 */
function handleChildRender_(node) {
	if (node.tag && isComponentTag_(node.tag)) {
		node.props.children = buildChildren_(node.props.children);
		renderFromTag_(node.tag, node.props, (0, _children.getOwner)(node));
		return true;
	}
}

/**
 * Handles an intercepted call to the attributes default handler from
 * incremental dom.
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 * @private
 */
function handleInterceptedAttributesCall_(element, name, value) {
	(0, _attributes.applyAttribute)(getComponentBeingRendered(), element, name, value);
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom.
 * @param {string} tag
 * @private
 * @return {Object}
 */
function handleInterceptedOpenCall_(tag) {
	if (isComponentTag_(tag)) {
		return handleSubComponentCall_.apply(undefined, arguments);
	} else {
		return handleRegularCall_.apply(undefined, arguments);
	}
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom, done for a regular element. Among other things, adds any inline
 * listeners found on the first render and makes sure that component root
 * elements are always reused.
 * @param {!Component} owner
 * @param {!Array} args
 * @return {!Element} The rendered element.
 * @private
 */
function handleRegularCall_() {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	var config = (0, _callArgs.buildConfigFromCall)(args);
	var tag = args[0];

	var comp = getComponentBeingRendered();
	var owner = comp;
	if ((0, _children.isChildTag)(tag)) {
		owner = tag.owner;
		tag = tag.tag;
	}
	config.key = generateKey_(comp, config.key);

	if (!(0, _data.getData)(comp).rootElementReached) {
		var elementClasses = comp.getDataManager().get(comp, 'elementClasses');
		if (elementClasses) {
			addElementClasses_(elementClasses, config);
		}
	}
	(0, _attributes.convertListenerNamesToFns)(comp, config);

	var call = (0, _callArgs.buildCallFromConfig)(tag, config);
	var node = (0, _incrementalDomAop.getOriginalFn)('elementOpen').apply(undefined, _toConsumableArray(call));
	resetNodeData_(node);
	updateElementIfNotReached_(comp, node);

	if ((0, _metal.isDefAndNotNull)(config.ref)) {
		owner.refs[config.ref] = node;
	}
	owner.getRenderer().handleNodeRendered(node);

	return node;
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom, done for a sub component element. Creates and updates the appropriate
 * sub component.
 * @private
 */
function handleSubComponentCall_() {
	for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		args[_key2] = arguments[_key2];
	}

	(0, _children.captureChildren)(getComponentBeingRendered(), handleChildrenCaptured_, {
		props: (0, _callArgs.buildConfigFromCall)(args),
		tag: args[0]
	});
}

/**
 * Passes down elementClasses to a child component if the parent component
 * returns another component at the top level (HOC).
 * @param {*} parent The parent component
 * @param {*} config The config of the subcomponent
 */
function inheritElementClasses_(parent, config) {
	var parentData = (0, _data.getData)(parent);
	var parentConfig = parentData.config;

	if (!parentData.rootElementReached && parentConfig && (0, _metal.isString)(parentConfig.elementClasses)) {
		var currentClasses = '';
		if ((0, _metal.isString)(config.elementClasses)) {
			currentClasses = config.elementClasses + ' ';
		}

		config.elementClasses = currentClasses + parentConfig.elementClasses;
	}
}

/**
 * Checks if the given tag represents a metal component.
 * @param {string} tag
 * @return {boolean}
 * @private
 */
function isComponentTag_(tag) {
	return (0, _metal.isFunction)(tag) || (0, _metal.isString)(tag) && tag[0] === tag[0].toUpperCase(); // eslint-disable-line
}

/**
 * Checks if the given component can be a match for a constructor.
 * @param {!Component} comp
 * @param {!function()} Ctor
 * @param {!Component} owner
 * @return {boolean}
 * @private
 */
function isMatch_(comp, Ctor, owner) {
	if (!comp || comp.constructor !== Ctor || comp.isDisposed()) {
		return false;
	}
	return (0, _data.getData)(comp).owner === owner;
}

/**
 * Returns the given component if it matches the specified constructor
 * function. Otherwise, returns a new instance of the given constructor. On
 * both cases the component's state and config will be updated.
 * @param {Component} comp
 * @param {!function()} Ctor
 * @param {!Object} config
 * @param {!Component} owner
 * @return {!Component}
 * @private
 */
function match_(comp, Ctor, config, owner) {
	if (isMatch_(comp, Ctor, owner)) {
		comp.startSkipUpdates();
		comp.getDataManager().replaceNonInternal(comp, config);
		comp.stopSkipUpdates();
	} else {
		comp = new Ctor(config, false);
	}
	(0, _data.getData)(comp).config = config;
	return comp;
}

/**
 * Prepares the render operation, resetting the component's data and starting
 * the incremental dom interception.
 * @param {!Component} component
 * @private
 */
function prepareRender_(component) {
	renderingComponents_.push(component);

	var data = (0, _data.getData)(component);
	resetComponentsData_(data.icComponentsData);
	(0, _changes.clearChanges)(data);
	data.rootElementReached = false;
	component.refs = {};

	if (data.childComponents) {
		(0, _unused.schedule)(data.childComponents);
		data.childComponents = null;
	}

	(0, _incrementalDomAop.startInterception)({
		attributes: handleInterceptedAttributesCall_,
		elementOpen: handleInterceptedOpenCall_
	});
}

/**
 * Removes duplicate css classes from the given string.
 * @param {string} classString
 * @return {string}
 * @private
 */
function removeDuplicateClasses_(classString) {
	var classes = [];
	var all = classString.split(/\s+/);
	var used = {};
	for (var i = 0; i < all.length; i++) {
		if (!used[all[i]]) {
			used[all[i]] = true;
			classes.push(all[i]);
		}
	}
	return classes.join(' ');
}

/**
 * Renders the component with incremental dom function calls. This assumes that
 * an incremental dom `patch` is already running, and that this function has
 * been called inside it.
 * @param {!Component} component
 */
function render(component) {
	prepareRender_(component);
	component.getRenderer().renderIncDom(component);
	cleanUpRender_(component);
}

/**
 * Renders the given child node.
 * @param {!Object} child
 */
function renderChild(child) {
	(0, _children.renderChildTree)(child, handleChildRender_);
}

/**
 * Renders the contents for the given tag.
 * @param {!function()|string} tag
 * @param {!Object} config
 * @param {Component=} owner
 * @private
 * @return {Object}
 */
function renderFromTag_(tag, config, owner) {
	if ((0, _metal.isString)(tag) || tag.prototype.getRenderer) {
		var comp = renderSubComponent_(tag, config, owner);
		updateElementIfNotReached_(getComponentBeingRendered(), comp.element);
		return comp.element;
	} else {
		return tag(config);
	}
}

/**
 * Creates and renders the given function, which can either be a simple
 * incremental dom function or a component constructor.
 * @param {!IncrementalDomRenderer} renderer
 * @param {!function()} fnOrCtor Either a simple incremental dom function or a
 *     component constructor.
 * @param {Object|Element=} dataOrElement Optional config data for the
 *     function or parent for the rendered content.
 * @param {Element=} parent Optional parent for the rendered content.
 * @return {!Component} The rendered component's instance.
 */
function renderFunction(renderer, fnOrCtor, dataOrElement, parent) {
	if (!_metalComponent.Component.isComponentCtor(fnOrCtor)) {
		var fn = fnOrCtor;

		var TempComponent = function(_Component) {
			_inherits(TempComponent, _Component);

			function TempComponent() {
				_classCallCheck(this, TempComponent);

				return _possibleConstructorReturn(this, (TempComponent.__proto__ || Object.getPrototypeOf(TempComponent)).apply(this, arguments));
			}

			_createClass(TempComponent, [{
				key: 'created',
				value: function created() {
					var parent = getComponentBeingRendered();
					if (parent) {
						updateContext_(this, parent);
					}
				}
			}, {
				key: 'render',
				value: function render() {
					fn(this.getInitialConfig());
				}
			}]);

			return TempComponent;
		}(_metalComponent.Component);

		TempComponent.RENDERER = renderer;
		fnOrCtor = TempComponent;
	}
	return _metalComponent.Component.render(fnOrCtor, dataOrElement, parent);
}

/**
 * This updates the sub component that is represented by the given data.
 * The sub component is created, added to its parent and rendered. If it
 * had already been rendered before though, it will only have its state
 * updated instead.
 * @param {string|!function()} tagOrCtor The tag name or constructor function.
 * @param {!Object} config The config object for the sub component.
 * @param {ComponentRenderer=} owner
 * @return {!Component} The updated sub component.
 * @private
 */
function renderSubComponent_(tagOrCtor, config, owner) {
	var parent = getComponentBeingRendered();
	owner = owner || parent;

	inheritElementClasses_(parent, config);

	var comp = getSubComponent_(tagOrCtor, config, owner);
	updateContext_(comp, parent);

	var data = (0, _data.getData)(comp);
	data.parent = parent;
	data.owner = owner;

	var parentData = (0, _data.getData)(parent);
	getChildComponents_(parentData).push(comp);
	if (!config.key && !parentData.rootElementReached) {
		config.key = parentData.config.key;
	}

	if (comp.portalElement && (0, _metal.isServerSide)()) {
		return comp;
	}

	if (!comp.portalElement) {
		comp.getRenderer().renderInsidePatch(comp);
	}

	if (!comp.wasRendered) {
		comp.renderComponent();
	}
	return comp;
}

/**
 * Resets the given incremental dom data object, preparing it for the next pass.
 * @param {Object} data
 * @private
 */
function resetComponentsData_(data) {
	if (data) {
		data.prevComps = data.currComps;
		data.currComps = null;
		data.currCount = null;
	}
}
/**
 * Resets all data stored in the given node.
 * @param {!Element} node
 * @private
 */
function resetNodeData_(node) {
	if (_metalDom.domData.has(node)) {
		resetComponentsData_(_metalDom.domData.get(node).icComponentsData);
	}
}

/**
 * Updates the given component's context according to the data from the
 * component that is currently being rendered.
 * @param {!Component} comp
 * @param {!Component} parent
 * @protected
 */
function updateContext_(comp, parent) {
	var context = comp.context;
	var childContext = parent.getChildContext ? parent.getChildContext() : null; // eslint-disable-line
	_metal.object.mixin(context, parent.context, childContext);
	comp.context = context;
}

/**
 * Updates this renderer's component's element with the given values, unless
 * it has already been reached by an earlier call.
 * @param {!Component} component
 * @param {!Element} node
 * @private
 */
function updateElementIfNotReached_(component, node) {
	var data = (0, _data.getData)(component);
	if (!data.rootElementReached) {
		data.rootElementReached = true;
		if (component.element !== node) {
			component.element = node;
		}
	}
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AreaLineChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _AreaLineChartSoy = __webpack_require__(68);

var _AreaLineChartSoy2 = _interopRequireDefault(_AreaLineChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * AreaLine Chart Component
 * @augments Chart
 */
var AreaLineChart = function(_Chart) {
	_inherits(AreaLineChart, _Chart);

	function AreaLineChart() {
		_classCallCheck(this, AreaLineChart);

		return _possibleConstructorReturn(this, (AreaLineChart.__proto__ || Object.getPrototypeOf(AreaLineChart)).apply(this, arguments));
	}

	return AreaLineChart;
}(_Chart3.default);

AreaLineChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default area
* @instance
* @memberof AreaLineChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.area).value('area')
};

_metalSoy2.default.register(AreaLineChart, _AreaLineChartSoy2.default);

exports.AreaLineChart = AreaLineChart;
exports.default = AreaLineChart;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 *
 * billboard.js, JavaScript chart library
 * http://naver.github.io/billboard.js/
 *
 * @version 1.4.1
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if (true)
		module.exports = factory(__webpack_require__(13));
	else if(typeof define === 'function' && define.amd)
		define(["d3"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3")) : factory(root["d3"]);
		for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE__4__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;
exports.bb = undefined;

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_Axis = __webpack_require__(5),
	_Axis2 = _interopRequireDefault(_Axis),
	_util = __webpack_require__(6),
	util = _interopRequireWildcard(_util);

__webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) return obj; var newObj = {}; if (obj != null) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]); return newObj.default = obj, newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @namespace bb
 * @version 1.4.1
 */
var bb = {
	/**
* Version information
* @property {String} version version
* @example
*    bb.version;  // "1.0.0"
* @memberOf bb
*/
	version: "1.4.1",
	/**
* generate charts
* @param {Options} options chart options
* @memberOf bb
* @return {Chart}
* @see {@link Options} for different generation options
* @see {@link Chart} for different methods API
* @example
*  <!-- chart holder -->
* <div id="LineChart"></div>
* @example
*   // generate chart with options
*  var chart = bb.generate({
*      "bindto": "#LineChart"
*      "data": {
*          "columns": [
*              ["data1", 30, 200, 100, 400, 150, 250],
*              ["data2", 50, 20, 10, 40, 15, 25]
*           ]
*      }
*  });
*
*  // call some API
*  // ex) get the data of 'data1'
*  chart.data("data1");
*/
	generate: function generate(config) {
		var inst = new _Chart2.default(config);

		return inst.internal.charts = this.instance, this.instance.push(inst), inst;
	},

	/**
* An array containing instance created
* @property {Array} instance instance array
* @example
*  // generate charts
*  var chart1 = bb.generate(...);
*  var chart2 = bb.generate(...);
*
*  bb.instance;  // [ chart1, chart2, ... ]
* @memberOf bb
*/
	instance: [],
	/**
* Internal chart object
* @private
*/
	chart: {
		fn: _Chart2.default.prototype,
		internal: {
			fn: _ChartInternal2.default.prototype,
			axis: {
				fn: _Axis2.default.prototype
			}
		}
	}
}; /**
	* Copyright (c) 2017 NAVER Corp.
	* billboard.js project is licensed under the MIT license
	*/

for (var p in util) /^__/.test(p) || (_ChartInternal2.default.prototype[p] = util[p]);

__webpack_require__(12), __webpack_require__(14), __webpack_require__(15), __webpack_require__(16), __webpack_require__(17), __webpack_require__(18), __webpack_require__(19), __webpack_require__(20), __webpack_require__(21), __webpack_require__(22), __webpack_require__(23), __webpack_require__(24), __webpack_require__(25), __webpack_require__(26), __webpack_require__(27), __webpack_require__(28), __webpack_require__(29), __webpack_require__(30), __webpack_require__(31), __webpack_require__(32), __webpack_require__(33), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), __webpack_require__(40), __webpack_require__(41), __webpack_require__(42), __webpack_require__(43), __webpack_require__(44), __webpack_require__(45), __webpack_require__(46), __webpack_require__(47), __webpack_require__(48), __webpack_require__(49), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(58), __webpack_require__(59), __webpack_require__(60), __webpack_require__(62), __webpack_require__(9), __webpack_require__(63), __webpack_require__(64);
exports.bb = bb;
exports.default = bb;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;

var _classCallCheck2 = __webpack_require__(2),
	_classCallCheck3 = _interopRequireDefault(_classCallCheck2),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/
var Chart = function Chart(config) {
(0, _classCallCheck3.default)(this, Chart);

var $$ = new _ChartInternal2.default(this);

this.internal = $$, $$.loadConfig(config), $$.beforeInit(config), $$.init(), $$.afterInit(config), function bindThis(fn, target, argThis) {
	Object.keys(fn).forEach(function (key) {
	  target[key] = fn[key].bind(argThis), Object.keys(fn[key]).length && bindThis(fn[key], target[key], argThis);
	});
}(Chart.prototype, this, this);
}; /**
	* Copyright (c) 2017 NAVER Corp.
	* billboard.js project is licensed under the MIT license
	* @license MIT
	* @ignore
	*/

exports.default = Chart;
module.exports = exports["default"];

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;

exports.default = function(instance, Constructor) {
if (!(instance instanceof Constructor)) {
	throw new TypeError("Cannot call a class as a function");
}
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;

var _classCallCheck2 = __webpack_require__(2),
	_classCallCheck3 = _interopRequireDefault(_classCallCheck2),
	_d3TimeFormat = __webpack_require__(4),
	_d3Selection = __webpack_require__(4),
	_d3Array = __webpack_require__(4),
	_d3Transition = __webpack_require__(4),
	_Axis = __webpack_require__(5),
	_Axis2 = _interopRequireDefault(_Axis),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
*/
var ChartInternal = function() {
	function ChartInternal(api) {
		(0, _classCallCheck3.default)(this, ChartInternal);

		var $$ = this;

		$$.api = api, $$.config = $$.getOptions(), $$.data = {}, $$.cache = {}, $$.axes = {};
	}

	return ChartInternal.prototype.beforeInit = function beforeInit() {
		var $$ = this,
			config = $$.config;
		(0, _util.isFunction)(config.onbeforeinit) && config.onbeforeinit.call($$);
	}, ChartInternal.prototype.afterInit = function afterInit() {
		var $$ = this,
			config = $$.config;
		(0, _util.isFunction)(config.onafterinit) && config.onafterinit.call($$);
	}, ChartInternal.prototype.init = function init() {
		var $$ = this,
			config = $$.config;

		if ($$.initParams(), config.data_url) $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);else if (config.data_json) $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));else if (config.data_rows) $$.initWithData($$.convertRowsToData(config.data_rows));else if (config.data_columns) $$.initWithData($$.convertColumnsToData(config.data_columns));else throw Error("url or json or rows or columns is required.");
	}, ChartInternal.prototype.initParams = function initParams() {
		var $$ = this,
			config = $$.config;
		$$.datetimeId = "bb-" + +new Date(), $$.clipId = $$.datetimeId + "-clip", $$.clipIdForXAxis = $$.clipId + "-xaxis", $$.clipIdForYAxis = $$.clipId + "-yaxis", $$.clipIdForGrid = $$.clipId + "-grid", $$.clipIdForSubchart = $$.clipId + "-subchart", $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis), $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null, $$.dragging = !1, $$.flowing = !1, $$.cancelClick = !1, $$.mouseover = !1, $$.transiting = !1, $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), $$.extraLineClasses = $$.generateExtraLineClass(), $$.dataTimeFormat = config.data_xLocaltime ? _d3TimeFormat.timeParse : _d3TimeFormat.utcParse, $$.axisTimeFormat = config.axis_x_localtime ? _d3TimeFormat.timeFormat : _d3TimeFormat.utcFormat, $$.defaultAxisTimeFormat = function(d) {
			var specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDay() && d.getDate() !== 1 && "%-m/%-d" || d.getDate() !== 1 && "%b %d" || d.getMonth() && "%-m/%-d" || "%Y/%-m/%-d";

			return $$.axisTimeFormat(specifier)(d);
		}, $$.hiddenTargetIds = [], $$.hiddenLegendIds = [], $$.focusedTargetIds = [], $$.defocusedTargetIds = [], $$.xOrient = config.axis_rotated ? "left" : "bottom", $$.yOrient = config.axis_rotated ? config.axis_y_inner ? "top" : "bottom" : config.axis_y_inner ? "right" : "left", $$.y2Orient = config.axis_rotated ? config.axis_y2_inner ? "bottom" : "top" : config.axis_y2_inner ? "left" : "right", $$.subXOrient = config.axis_rotated ? "left" : "bottom", $$.isLegendRight = config.legend_position === "right", $$.isLegendInset = config.legend_position === "inset", $$.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", $$.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", $$.legendStep = 0, $$.legendItemWidth = 0, $$.legendItemHeight = 0, $$.currentMaxTickWidths = {
			x: 0,
			y: 0,
			y2: 0
		}, $$.rotated_padding_left = 30, $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30, $$.rotated_padding_top = 5, $$.withoutFadeIn = {}, $$.intervalForObserveInserted = undefined, $$.inputType = $$.convertInputType(), $$.axes.subx = (0, _d3Selection.selectAll)([]);
	}, ChartInternal.prototype.initWithData = function initWithData(data) {
		var $$ = this,
			config = $$.config,
			binding = !0;
		$$.axis = new _Axis2.default($$), $$.initBrush && $$.initBrush(), $$.initZoom && $$.initZoom();

		var bindto = {
			element: config.bindto,
			classname: "bb"
		};

		if ((0, _util.isObject)(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $$.selectChart = (0, _util.isFunction)(bindto.element.node) ? config.bindto.element : (0, _d3Selection.select)(bindto.element ? bindto.element : []), $$.selectChart.empty() && ($$.selectChart = (0, _d3Selection.select)(document.createElement("div")).style("opacity", "0"), $$.observeInserted($$.selectChart), binding = !1), $$.selectChart.html("").classed(bindto.classname, !0), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.hasType("gauge") && (config.legend_show = !1), $$.updateSizes(), $$.updateScales(), $$.x.domain((0, _d3Array.extent)($$.getXDomain($$.data.targets))), $$.y.domain($$.getYDomain($$.data.targets, "y")), $$.y2.domain($$.getYDomain($$.data.targets, "y2")), $$.subX.domain($$.x.domain()), $$.subY.domain($$.y.domain()), $$.subY2.domain($$.y2.domain()), $$.orgXDomain = $$.x.domain(), $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && $$.inputType) {
			var isTouch = $$.inputType === "touch";

			$$.svg.on(isTouch ? "touchstart" : "mouseenter", function() {
				return config.onover.call($$);
			}).on(isTouch ? "touchend" : "mouseleave", function() {
				return config.onout.call($$);
			});
		}

		config.svg_classname && $$.svg.attr("class", config.svg_classname), $$.defs = $$.svg.append("defs"), $$.clipChart = $$.appendClip($$.defs, $$.clipId), $$.clipXAxis = $$.appendClip($$.defs, $$.clipIdForXAxis), $$.clipYAxis = $$.appendClip($$.defs, $$.clipIdForYAxis), $$.clipGrid = $$.appendClip($$.defs, $$.clipIdForGrid), $$.clipSubchart = $$.appendClip($$.defs, $$.clipIdForSubchart), (0, _util.isFunction)(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
			return $$.defs.append(function () {
				return p.node;
			});
		}), $$.updateSvgSize();

		// Set initialized scales to brush and zoom
		// if ($$.brush) { $$.brush.scale($$.subX); }
		// if (config.zoom_enabled) { $$.zoom.scale($$.x); }

		// Define regions
		var main = $$.svg.append("g").attr("transform", $$.getTranslate("main"));

		$$.main = main, config.subchart_show && $$.initSubchart && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), main.append("text").attr("class", _classes2.default.text + " " + _classes2.default.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
		.attr("dominant-baseline", "middle"), $$.initRegion(), $$.initGrid(), config.clipPath || $$.axis.init();

		// Define g for chart area
		var g = main.append("g").attr("class", _classes2.default.chart);

		// Draw with targets
		if (config.clipPath && g.attr("clip-path", $$.clipPath), config.grid_lines_front && $$.initGridLines(), $$.initEventRect(), $$.initChartElements(), main.insert("rect", config.zoom_privileged ? null : "g." + _classes2.default.regions).attr("class", _classes2.default.zoomRect).attr("width", $$.width).attr("height", $$.height).style("opacity", "0").on("dblclick.zoom", null), config.axis_x_extent && $$.brush.scale($$.getDefaultExtent()), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), binding && ($$.updateDimension(), config.oninit.call($$), $$.redraw({
			withTransition: !1,
			withTransform: !0,
			withUpdateXDomain: !0,
			withUpdateOrgXDomain: !0,
			withTransitionForAxis: !1
		}), config.data_onmin || config.data_onmax))

			// data.onmin/max callback
			{
				var _minMax = $$.getMinMaxData();

				(0, _util.isFunction)(config.data_onmin) && config.data_onmin.call($$, _minMax.min), (0, _util.isFunction)(config.data_onmax) && config.data_onmax.call($$, _minMax.max);
			}

		// Bind resize event
		$$.bindResize(), $$.api.element = $$.selectChart.node();
	}, ChartInternal.prototype.initChartElements = function initChartElements() {
		var _this = this;

		["Pie", "Bar", "Line", "Arc", "Gauge", "Bubble", "Text"].forEach(function (v) {
			var method = "init" + v;

			_this[method] && _this[method]();
		});
	}, ChartInternal.prototype.smoothLines = function smoothLines(el, type) {
		type === "grid" && el.each(function () {
			var g = (0, _d3Selection.select)(this);

			g.attr({
				"x1": Math.ceil(g.attr("x1")),
				"x2": Math.ceil(g.attr("x2")),
				"y1": Math.ceil(g.attr("y1")),
				"y2": Math.ceil(g.attr("y2"))
			});
		});
	}, ChartInternal.prototype.updateSizes = function updateSizes() {
		var $$ = this,
			config = $$.config,
			legendHeight = $$.legend ? $$.getLegendHeight() : 0,
			legendWidth = $$.legend ? $$.getLegendWidth() : 0,
			legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,
			hasArc = $$.hasArcType(),
			xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
			subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0;
		$$.currentWidth = $$.getCurrentWidth(), $$.currentHeight = $$.getCurrentHeight(), $$.margin = config.axis_rotated ? {
			top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
			right: hasArc ? 0 : $$.getCurrentPaddingRight(),
			bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
			left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
		} : {
			top: 4 + $$.getCurrentPaddingTop(), // for top tick text
			right: hasArc ? 0 : $$.getCurrentPaddingRight(),
			bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
			left: hasArc ? 0 : $$.getCurrentPaddingLeft()
		}, $$.margin2 = config.axis_rotated ? {
			top: $$.margin.top,
			right: NaN,
			bottom: 20 + legendHeightForBottom,
			left: $$.rotated_padding_left
		} : {
			top: $$.currentHeight - subchartHeight - legendHeightForBottom,
			right: NaN,
			bottom: xAxisHeight + legendHeightForBottom,
			left: $$.margin.left
		}, $$.margin3 = {
			top: 0,
			right: NaN,
			bottom: 0,
			left: 0
		}, $$.updateSizeForLegend && $$.updateSizeForLegend(legendHeight, legendWidth), $$.width = $$.currentWidth - $$.margin.left - $$.margin.right, $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom, $$.width < 0 && ($$.width = 0), $$.height < 0 && ($$.height = 0), $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width, $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom, $$.width2 < 0 && ($$.width2 = 0), $$.height2 < 0 && ($$.height2 = 0), $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0), $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && ($$.arcHeight += $$.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), $$.isLegendRight && hasArc && ($$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1);
	}, ChartInternal.prototype.updateTargets = function updateTargets(targets) {
		var $$ = this;

		// -- Main --

		// -- Text -- //
		$$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType() && $$.updateTargetsForArc && $$.updateTargetsForArc(targets), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
	}, ChartInternal.prototype.showTargets = function showTargets() {
		var $$ = this;

		$$.svg.selectAll("." + _classes2.default.target).filter(function (d) {
			return $$.isTargetToShow(d.id);
		}).transition().duration($$.config.transition_duration).style("opacity", "1");
	}, ChartInternal.prototype.redraw = function redraw() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			transitionsValue = arguments[1],
			$$ = this,
			main = $$.main,
			config = $$.config,
			areaIndices = $$.getShapeIndices($$.isAreaType),
			barIndices = $$.getShapeIndices($$.isBarType),
			lineIndices = $$.getShapeIndices($$.isLineType),
			waitForDraw = void 0,
			flow = void 0,
			hideAxis = $$.hasArcType(),
			targetsToShow = $$.filterTargetsToShow($$.data.targets),
			xv = $$.xv.bind($$),
			tickValues = void 0,
			intervalForCulling = void 0,
			xDomainForZoom = void 0,
			withY = (0, _util.getOption)(options, "withY", !0),
			withSubchart = (0, _util.getOption)(options, "withSubchart", !0),
			withTransition = (0, _util.getOption)(options, "withTransition", !0),
			withTransform = (0, _util.getOption)(options, "withTransform", !1),
			withUpdateXDomain = (0, _util.getOption)(options, "withUpdateXDomain", !1),
			withUpdateOrgXDomain = (0, _util.getOption)(options, "withUpdateOrgXDomain", !1),
			withTrimXDomain = (0, _util.getOption)(options, "withTrimXDomain", !0),
			withUpdateXAxis = (0, _util.getOption)(options, "withUpdateXAxis", withUpdateXDomain),
			withLegend = (0, _util.getOption)(options, "withLegend", !1),
			withEventRect = (0, _util.getOption)(options, "withEventRect", !0),
			withDimension = (0, _util.getOption)(options, "withDimension", !0),
			withTransitionForExit = (0, _util.getOption)(options, "withTransitionForExit", withTransition),
			withTransitionForAxis = (0, _util.getOption)(options, "withTransitionForAxis", withTransition),
			duration = withTransition ? config.transition_duration : 0,
			durationForExit = withTransitionForExit ? duration : 0,
			durationForAxis = withTransitionForAxis ? duration : 0,
			transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);

		// show/hide if manual culling needed
		if ($$.inputType === "touch" && $$.hideTooltip(), withLegend && config.legend_show && !config.legend_contents_bindto ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : withDimension && $$.updateDimension(!0), $$.isCategorized() && targetsToShow.length === 0 && $$.x.domain([0, $$.axes.x.selectAll(".tick").size()]), targetsToShow.length ? ($$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain), !config.axis_x_tick_values && (tickValues = $$.axis.updateXAxisTickValues(targetsToShow))) : ($$.xAxis.tickValues([]), $$.subXAxis.tickValues([])), config.zoom_rescale && !options.flow && (xDomainForZoom = $$.x.orgDomain()), $$.y.domain($$.getYDomain(targetsToShow, "y", xDomainForZoom)), $$.y2.domain($$.getYDomain(targetsToShow, "y2", xDomainForZoom)), !config.axis_y_tick_values && config.axis_y_tick_count && $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count, $$.isTimeSeriesY())), !config.axis_y2_tick_values && config.axis_y2_tick_count && $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count)), $$.axis.redraw(transitions, hideAxis), $$.axis.updateLabels(withTransition), (withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) if (config.axis_x_tick_culling && tickValues) {
				for (var _i = 1; _i < tickValues.length; _i++) if (tickValues.length / _i < config.axis_x_tick_culling_max) {
					intervalForCulling = _i;

					break;
				}

				$$.svg.selectAll("." + _classes2.default.axisX + " .tick text").each(function (e) {
					var index = tickValues.indexOf(e);

					index >= 0 && (0, _d3Selection.select)(this).style("display", index % intervalForCulling ? "none" : "block");
				});
			} else $$.svg.selectAll("." + _classes2.default.axisX + " .tick text").style("display", "block");

		// setup drawer - MEMO: these must be called after axis updated
		var drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, !1) : undefined,
			drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined,
			drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, !1) : undefined,
			xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, !0),
			yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, !1);

		withY && ($$.subY.domain($$.getYDomain(targetsToShow, "y")), $$.subY2.domain($$.getYDomain(targetsToShow, "y2"))), $$.updateXgridFocus(), main.select("text." + _classes2.default.text + "." + _classes2.default.empty).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).transition().style("opacity", targetsToShow.length ? 0 : 1), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $$.redrawArc && $$.redrawArc(duration, durationForExit, withTransform), config.subchart_show && $$.redrawSubchart && $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices), main.selectAll("." + _classes2.default.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !options.flow && withEventRect && ($$.redrawEventRect(), $$.updateZoom && $$.updateZoom()), $$.updateCircleY();

		// generate circle x/y functions depending on updated params
		var cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
			cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$);
		options.flow && (flow = $$.generateFlow({
			targets: targetsToShow,
			flow: options.flow,
			duration: options.flow.duration,
			drawBar: drawBar,
			drawLine: drawLine,
			drawArea: drawArea,
			cx: cx,
			cy: cy,
			xv: xv,
			xForText: xForText,
			yForText: yForText
		})), (duration || flow) && $$.isTabVisible() ? (0, _d3Transition.transition)().duration(duration).each(function () {
			waitForDraw = $$.generateWait(), [$$.redrawBar(drawBar, !0), $$.redrawLine(drawLine, !0), $$.redrawArea(drawArea, !0), $$.redrawCircle(cx, cy, !0, flow), $$.redrawText(xForText, yForText, options.flow, !0), $$.redrawRegion(!0), $$.redrawGrid(!0)].reduce(function (acc, t1) {
				return t1.forEach(function (t2) {
					acc.push(t2);
				}), acc;
			}, []).forEach(function (t) {
				waitForDraw.add(t);
			});
		}).call(waitForDraw, function() {
			flow && flow(), config.onrendered && config.onrendered.call($$);
		}) : ($$.redrawBar(drawBar), $$.redrawLine(drawLine), $$.redrawArea(drawArea), $$.redrawCircle(cx, cy), $$.redrawText(xForText, yForText, options.flow), $$.redrawRegion(), $$.redrawGrid(), config.onrendered && config.onrendered.call($$)), $$.mapToIds($$.data.targets).forEach(function (id) {
			$$.withoutFadeIn[id] = !0;
		});
	}, ChartInternal.prototype.updateAndRedraw = function updateAndRedraw() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			$$ = this,
			config = $$.config,
			transitions = void 0;
		options.withTransition = (0, _util.getOption)(options, "withTransition", !0), options.withTransform = (0, _util.getOption)(options, "withTransform", !1), options.withLegend = (0, _util.getOption)(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = (0, _util.getOption)(options, "withTransitionForTransform", options.withTransition), $$.updateSizes(), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
	}, ChartInternal.prototype.redrawWithoutRescale = function redrawWithoutRescale() {
		this.redraw({
			withY: !1,
			withSubchart: !1,
			withEventRect: !1,
			withTransitionForAxis: !1
		});
	}, ChartInternal.prototype.isTimeSeries = function isTimeSeries() {
		return this.config.axis_x_type === "timeseries";
	}, ChartInternal.prototype.isCategorized = function isCategorized() {
		return this.config.axis_x_type.indexOf("category") >= 0;
	}, ChartInternal.prototype.isCustomX = function isCustomX() {
		var $$ = this,
			config = $$.config;

		return !$$.isTimeSeries() && (config.data_x || (0, _util.notEmpty)(config.data_xs));
	}, ChartInternal.prototype.isTimeSeriesY = function isTimeSeriesY() {
		return this.config.axis_y_type === "timeseries";
	}, ChartInternal.prototype.getTranslate = function getTranslate(target) {
		var $$ = this,
			config = $$.config,
			x = void 0,
			y = void 0;

		return target === "main" ? (x = (0, _util.asHalfPixel)($$.margin.left), y = (0, _util.asHalfPixel)($$.margin.top)) : target === "context" ? (x = (0, _util.asHalfPixel)($$.margin2.left), y = (0, _util.asHalfPixel)($$.margin2.top)) : target === "legend" ? (x = $$.margin3.left, y = $$.margin3.top) : target === "x" ? (x = 0, y = config.axis_rotated ? 0 : $$.height) : target === "y" ? (x = 0, y = config.axis_rotated ? $$.height : 0) : target === "y2" ? (x = config.axis_rotated ? 0 : $$.width, y = config.axis_rotated ? 1 : 0) : target === "subx" ? (x = 0, y = config.axis_rotated ? 0 : $$.height2) : target === "arc" && (x = $$.arcWidth / 2, y = $$.arcHeight / 2), "translate(" + x + ", " + y + ")";
	}, ChartInternal.prototype.initialOpacity = function initialOpacity(d) {
		return d.value !== null && this.withoutFadeIn[d.id] ? "1" : "0";
	}, ChartInternal.prototype.initialOpacityForCircle = function initialOpacityForCircle(d) {
		return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
	}, ChartInternal.prototype.opacityForCircle = function opacityForCircle(d) {
		var opacity = this.config.point_show ? "1" : "0";

		return (0, _util.isValue)(d.value) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
	}, ChartInternal.prototype.opacityForText = function opacityForText() {
		return this.hasDataLabel() ? "1" : "0";
	}, ChartInternal.prototype.xx = function xx(d) {
		return this.config.zoom_enabled && this.zoomScale ? d ? this.zoomScale(d.x) : null : d ? this.x(d.x) : null;
	}, ChartInternal.prototype.xv = function xv(d) {
		var $$ = this,
			value = d.value;

		return $$.isTimeSeries() ? value = $$.parseDate(d.value) : $$.isCategorized() && (0, _util.isString)(d.value) && (value = $$.config.axis_x_categories.indexOf(d.value)), Math.ceil($$.x(value));
	}, ChartInternal.prototype.yv = function yv(d) {
		var $$ = this,
			yScale = d.axis && d.axis === "y2" ? $$.y2 : $$.y;

		return Math.ceil(yScale(d.value));
	}, ChartInternal.prototype.subxx = function subxx(d) {
		return d ? this.subX(d.x) : null;
	}, ChartInternal.prototype.transformMain = function transformMain(withTransition, transitions) {
		var $$ = this,
			xAxis = void 0,
			yAxis = void 0,
			y2Axis = void 0;
		transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = $$.main.select("." + _classes2.default.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = $$.main.select("." + _classes2.default.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = $$.main.select("." + _classes2.default.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), $$.main.select("." + _classes2.default.chartArcs).attr("transform", $$.getTranslate("arc"));
	}, ChartInternal.prototype.transformAll = function transformAll(withTransition, transitions) {
		var $$ = this;

		$$.transformMain(withTransition, transitions), $$.config.subchart_show && $$.transformContext(withTransition, transitions), $$.legend && $$.transformLegend(withTransition);
	}, ChartInternal.prototype.updateSvgSize = function updateSvgSize() {
		var $$ = this,
			brush = $$.svg.select("." + _classes2.default.brush + " .overlay"),
			brushHeight = brush.size() ? brush.attr("height") : 0;
		$$.svg.attr("width", $$.currentWidth).attr("height", $$.currentHeight), $$.svg.selectAll(["#" + $$.clipId, "#" + $$.clipIdForGrid]).select("rect").attr("width", $$.width).attr("height", $$.height), $$.svg.select("#" + $$.clipIdForXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), $$.svg.select("#" + $$.clipIdForYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), $$.svg.select("#" + $$.clipIdForSubchart).select("rect").attr("width", $$.width).attr("height", brushHeight), $$.svg.select("." + _classes2.default.zoomRect).attr("width", $$.width).attr("height", $$.height), $$.brush && $$.brush.scale($$.subX, brushHeight);
	}, ChartInternal.prototype.updateDimension = function updateDimension(withoutAxis) {
		var $$ = this;

		withoutAxis || ($$.config.axis_rotated ? ($$.axes.x.call($$.xAxis), $$.axes.subx.call($$.subXAxis)) : ($$.axes.y.call($$.yAxis), $$.axes.y2.call($$.y2Axis))), $$.updateSizes(), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
	}, ChartInternal.prototype.observeInserted = function observeInserted(selection) {
		var $$ = this;

		if ((0, _util.isUndefined)(MutationObserver)) return void (console && console.error && console.error("MutationObserver not defined."));

		var observer = new MutationObserver(function (mutations) {
			mutations.forEach(function (mutation) {
				mutation.type === "childList" && mutation.previousSibling && (observer.disconnect(), $$.intervalForObserveInserted = window.setInterval(function () {
					selection.node().parentNode && (window.clearInterval($$.intervalForObserveInserted), $$.updateDimension(), $$.brush && $$.brush.update(), $$.config.oninit.call($$), $$.redraw({
						withTransform: !0,
						withUpdateXDomain: !0,
						withUpdateOrgXDomain: !0,
						withTransition: !1,
						withTransitionForTransform: !1,
						withLegend: !0
					}), selection.transition().style("opacity", "1"));
				}, 10));
			});
		});

		observer.observe(selection.node(), {
			attributes: !0,
			childList: !0,
			characterData: !0
		});
	}, ChartInternal.prototype.bindResize = function bindResize() {
		var $$ = this,
			config = $$.config;
		$$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(function () {
			config.onresize.call($$);
		}), config.resize_auto && $$.resizeFunction.add(function () {
			$$.resizeTimeout !== undefined && window.clearTimeout($$.resizeTimeout), $$.resizeTimeout = window.setTimeout(function () {
				delete $$.resizeTimeout, $$.api.flush();
			}, 100);
		}), $$.resizeFunction.add(function () {
			config.onresized.call($$);
		}), (0, _util.addEvent)(window, "resize", $$.resizeFunction);
	}, ChartInternal.prototype.generateResize = function generateResize() {

		function callResizeFunctions() {
			resizeFunctions.forEach(function (f) {
				return f();
			});
		}

		var resizeFunctions = [];

		return callResizeFunctions.add = function(f) {
			resizeFunctions.push(f);
		}, callResizeFunctions.remove = function(f) {
			for (var i = 0; i < resizeFunctions.length; i++) if (resizeFunctions[i] === f) {
				resizeFunctions.splice(i, 1);

				break;
			}
		}, callResizeFunctions;
	}, ChartInternal.prototype.endall = function endall(transition, callback) {
		var n = 0;

		transition.each(function () {
			return ++n;
		}).on("end", function() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

			--n || callback.apply.apply(callback, [this].concat(args));
		});
	}, ChartInternal.prototype.generateWait = function generateWait() {
		var transitionsToWait = [],
			f = function(transition, callback) {

			function loop() {
				var done = 0;

				transitionsToWait.forEach(function (t) {
					if (t.empty()) return void (done += 1);

					try {
						t.transition();
					} catch (e) {
						done += 1;
					}
				}), done === transitionsToWait.length ? (clearTimeout(timer), callback && callback()) : timer = setTimeout(loop, 20);
			}

			var timer = void 0;loop();
		};

		return f.add = function(transition) {
			Array.isArray(transition) ? transitionsToWait = [].concat(transitionsToWait, transition) : transitionsToWait.push(transition);
		}, f;
	}, ChartInternal.prototype.parseDate = function parseDate(date) {
		var $$ = this,
			parsedDate = void 0;

		return date instanceof Date ? parsedDate = date : (0, _util.isString)(date) ? parsedDate = $$.dataTimeFormat($$.config.data_xFormat)(date) : (0, _util.isNumber)(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
	}, ChartInternal.prototype.isTabVisible = function isTabVisible() {
		var hidden = void 0;

		return (0, _util.isDefined)(document.hidden) ? hidden = "hidden" : (0, _util.isDefined)(document.mozHidden) ? hidden = "mozHidden" : (0, _util.isDefined)(document.msHidden) ? hidden = "msHidden" : (0, _util.isDefined)(document.webkitHidden) && (hidden = "webkitHidden"), !document[hidden];
	}, ChartInternal.prototype.convertInputType = function convertInputType() {
		var $$ = this,
			config = $$.config,
			isMobile = $$.isMobile(),
			hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in window,
			hasTouch = !1;

		return config.interaction_inputType_touch && (hasTouch = "ontouchmove" in window || window.DocumentTouch && document instanceof window.DocumentTouch), hasMouse && "mouse" || hasTouch && "touch" || null;
	}, ChartInternal;
}(); /**
	  * Copyright (c) 2017 NAVER Corp.
	  * billboard.js project is licensed under the MIT license
	  * @ignore
	  */

exports.default = ChartInternal;
module.exports = exports["default"];

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__4__;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;

var _classCallCheck2 = __webpack_require__(2),
	_classCallCheck3 = _interopRequireDefault(_classCallCheck2),
	_d3Selection = __webpack_require__(4),
	_util = __webpack_require__(6),
	_bb = __webpack_require__(9),
	_bb2 = _interopRequireDefault(_bb),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var Axis = function() {
	function Axis(owner) {
		(0, _classCallCheck3.default)(this, Axis), this.owner = owner;
	}

	return Axis.prototype.init = function init() {
		var $$ = this.owner,
			config = $$.config,
			main = $$.main;
		$$.axes.x = main.append("g").attr("class", _classes2.default.axis + " " + _classes2.default.axisX).attr("clip-path", $$.clipPathForXAxis).attr("transform", $$.getTranslate("x")).style("visibility", config.axis_x_show ? "visible" : "hidden"), $$.axes.x.append("text").attr("class", _classes2.default.axisXLabel).attr("transform", config.axis_rotated ? "rotate(-90)" : "").style("text-anchor", this.textAnchorForXAxisLabel.bind(this)), $$.axes.y = main.append("g").attr("class", _classes2.default.axis + " " + _classes2.default.axisY).attr("clip-path", config.axis_y_inner ? "" : $$.clipPathForYAxis).attr("transform", $$.getTranslate("y")).style("visibility", config.axis_y_show ? "visible" : "hidden"), $$.axes.y.append("text").attr("class", _classes2.default.axisYLabel).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForYAxisLabel.bind(this)), $$.axes.y2 = main.append("g").attr("class", _classes2.default.axis + " " + _classes2.default.axisY2).attr("transform", $$.getTranslate("y2")).style("visibility", config.axis_y2_show ? "visible" : "hidden"), $$.axes.y2.append("text").attr("class", _classes2.default.axisY2Label).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForY2AxisLabel.bind(this));
	}, Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
		var $$ = this.owner,
			config = $$.config,
			isCategory = $$.isCategorized(),
			axisParams = {
			isCategory: isCategory,
			withOuterTick: withOuterTick,
			tickMultiline: config.axis_x_tick_multiline,
			tickWidth: config.axis_x_tick_width,
			tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
			tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
			withoutTransition: withoutTransition,
			orgXScale: $$.x
		},
			axis = (0, _bb2.default)(axisParams).scale($$.zoomScale || scale).orient(orient),
			newTickValues = tickValues;

		return $$.isTimeSeries() && tickValues && !(0, _util.isFunction)(tickValues) && (newTickValues = tickValues.map(function (v) {
			return $$.parseDate(v);
		})), axis.tickFormat(tickFormat).tickValues(newTickValues), isCategory && (axis.tickCentered(config.axis_x_tick_centered), (0, _util.isEmpty)(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), axis;
	}, Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
		var $$ = this.owner,
			config = $$.config,
			tickValues = void 0;

		return (config.axis_x_tick_fit || config.axis_x_tick_count) && (tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries())), axis ? axis.tickValues(tickValues) : ($$.xAxis.tickValues(tickValues), $$.subXAxis.tickValues(tickValues)), tickValues;
	}, Axis.prototype.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
		var $$ = this.owner,
			config = $$.config,
			axisParams = {
			withOuterTick: withOuterTick,
			withoutTransition: withoutTransition,
			tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate
		},
			axis = (0, _bb2.default)(axisParams).scale(scale).orient(orient).tickFormat(tickFormat);

		return $$.isTimeSeriesY() ? axis.ticks(config.axis_y_tick_time_value) : axis.tickValues(tickValues), axis;
	}, Axis.prototype.getId = function getId(id) {
		var config = this.owner.config;

		return id in config.data_axes ? config.data_axes[id] : "y";
	}, Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
		var $$ = this.owner,
			config = $$.config,
			tickFormat = config.axis_x_tick_format,
			isTimeSeries = $$.isTimeSeries(),
			isCategorized = $$.isCategorized(),
			format = void 0;

		return tickFormat ? (0, _util.isFunction)(tickFormat) ? format = tickFormat : isTimeSeries && (format = function(date) {
			return date ? $$.axisTimeFormat(tickFormat)(date) : "";
		}) : isTimeSeries ? format = $$.defaultAxisTimeFormat : format = isCategorized ? $$.categoryName : function(v) {
			return v < 0 ? v.toFixed(0) : v;
		}, (0, _util.isFunction)(format) ? function(v) {
			return format.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
		} : format;
	}, Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
		return tickValues || (axis ? axis.tickValues() : undefined);
	}, Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
		return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
	}, Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
		return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
	}, Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
		return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
	}, Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
		var $$ = this.owner;

		return $$.config["axis_" + axisId + "_label"];
	}, Axis.prototype.getLabelText = function getLabelText(axisId) {
		var option = this.getLabelOptionByAxisId(axisId),
			text = void 0;

		return text = (0, _util.isString)(option) ? option : option ? option.text : null, text;
	}, Axis.prototype.setLabelText = function setLabelText(axisId, text) {
		var $$ = this.owner,
			config = $$.config,
			option = this.getLabelOptionByAxisId(axisId);
		(0, _util.isString)(option) ? config["axis_" + axisId + "_label"] = text : option && (option.text = text);
	}, Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
		var option = this.getLabelOptionByAxisId(axisId),
			position = (0, _util.isObjectType)(option) && option.position ? option.position : defaultPosition;

		return {
			isInner: !!~position.indexOf("inner"),
			isOuter: !!~position.indexOf("outer"),
			isLeft: !!~position.indexOf("left"),
			isCenter: !!~position.indexOf("center"),
			isRight: !!~position.indexOf("right"),
			isTop: !!~position.indexOf("top"),
			isMiddle: !!~position.indexOf("middle"),
			isBottom: !!~position.indexOf("bottom")
		};
	}, Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
		return this.getLabelPosition("x", this.owner.config.axis_rotated ? "inner-top" : "inner-right");
	}, Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
		return this.getLabelPosition("y", this.owner.config.axis_rotated ? "inner-right" : "inner-top");
	}, Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
		return this.getLabelPosition("y2", this.owner.config.axis_rotated ? "inner-right" : "inner-top");
	}, Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
		var label = void 0;

		return label = id === "y2" ? this.getY2AxisLabelPosition() : id === "y" ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition(), label;
	}, Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
		return this.getLabelText("x");
	}, Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
		return this.getLabelText("y");
	}, Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
		return this.getLabelText("y2");
	}, Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
		var $$ = this.owner,
			x = void 0;

		return x = forHorizontal ? position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width : position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0, x;
	}, Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
		var dx = void 0;

		return dx = forHorizontal ? position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop ? "-0.5em" : position.isBottom ? "0.5em" : "0", dx;
	}, Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
		var anchor = void 0;

		return anchor = forHorizontal ? position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom ? "start" : position.isMiddle ? "middle" : "end", anchor;
	}, Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
		return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
	}, Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
		return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
	}, Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
		return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
	}, Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
		return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
	}, Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
		return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
	}, Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
		return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
	}, Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
		var $$ = this.owner,
			config = $$.config,
			position = this.getXAxisLabelPosition();
		return config.axis_rotated ? position.isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : position.isInner ? "-0.5em" : config.axis_x_height ? config.axis_x_height - 10 : "3em";
	}, Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
		var $$ = this.owner,
			position = this.getYAxisLabelPosition();
		return $$.config.axis_rotated ? position.isInner ? "-0.5em" : "3em" : position.isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
	}, Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
		var $$ = this.owner,
			position = this.getY2AxisLabelPosition();
		return $$.config.axis_rotated ? position.isInner ? "1.2em" : "-2.2em" : position.isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
	}, Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
		var $$ = this.owner;

		return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
	}, Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
		var $$ = this.owner;

		return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
	}, Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
		var $$ = this.owner;

		return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
	}, Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
		var $$ = this.owner,
			config = $$.config,
			maxWidth = 0,
			dummy = void 0,
			svg = void 0;

		if (withoutRecompute && $$.currentMaxTickWidths[id]) return $$.currentMaxTickWidths[id];

		if ($$.svg) {
			var targetsToShow = $$.filterTargetsToShow($$.data.targets),
				scale = void 0,
				axis = void 0;
			/^y2?$/.test(id) ? (scale = $$[id].copy().domain($$.getYDomain(targetsToShow, id)), axis = this.getYAxis(scale, $$[id + "Orient"], config["axis_" + id + "_tick_format"], $$[id + "AxisTickValues"], !1, !0, !0)) : (scale = $$.x.copy().domain($$.getXDomain(targetsToShow)), axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, !1, !0, !0), this.updateXAxisTickValues(targetsToShow, axis)), dummy = (0, _d3Selection.select)("body").append("div").classed("bb", !0), svg = dummy.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px"), svg.append("g").call(axis).each(function () {
				(0, _d3Selection.select)(this).selectAll("text").each(function () {
					var boxWidth = this.getBoundingClientRect().width;

					maxWidth < boxWidth && (maxWidth = boxWidth);
				}), dummy.remove();
			});
		}

		return $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth, $$.currentMaxTickWidths[id];
	}, Axis.prototype.updateLabels = function updateLabels(withTransition) {
		var $$ = this.owner,
			axisXLabel = $$.main.select("." + _classes2.default.axisX + " ." + _classes2.default.axisXLabel),
			axisYLabel = $$.main.select("." + _classes2.default.axisY + " ." + _classes2.default.axisYLabel),
			axisY2Label = $$.main.select("." + _classes2.default.axisY2 + "  ." + _classes2.default.axisY2Label);
		(withTransition ? axisXLabel.transition() : axisXLabel).attr("x", this.xForXAxisLabel.bind(this)).attr("dx", this.dxForXAxisLabel.bind(this)).attr("dy", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this)), (withTransition ? axisYLabel.transition() : axisYLabel).attr("x", this.xForYAxisLabel.bind(this)).attr("dx", this.dxForYAxisLabel.bind(this)).attr("dy", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this)), (withTransition ? axisY2Label.transition() : axisY2Label).attr("x", this.xForY2AxisLabel.bind(this)).attr("dx", this.dxForY2AxisLabel.bind(this)).attr("dy", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));
	}, Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
		var p = (0, _util.isNumber)(padding) ? padding : padding[key];

		// assume padding is pixels if unit is not specified
		return (0, _util.isValue)(p) ? padding.unit === "ratio" ? padding[key] * domainLength : this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
	}, Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
		var $$ = this.owner,
			length = $$.config.axis_rotated ? $$.width : $$.height;

		return domainLength * (pixels / length);
	}, Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
		var tickValues = values,
			start = void 0,
			end = void 0,
			count = void 0,
			interval = void 0,
			i = void 0,
			tickValue = void 0;

		if (tickCount) {
			var targetCount = (0, _util.isFunction)(tickCount) ? tickCount() : tickCount;

			// compute ticks according to tickCount
			if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {

				for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);

				tickValues.push(end);
			}
		}

		return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
			return a - b;
		})), tickValues;
	}, Axis.prototype.generateTransitions = function generateTransitions(duration) {
		var $$ = this.owner,
			axes = $$.axes;

		return {
			axisX: duration ? axes.x.transition().duration(duration) : axes.x,
			axisY: duration ? axes.y.transition().duration(duration) : axes.y,
			axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
			axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
		};
	}, Axis.prototype.redraw = function redraw(transitions, isHidden) {
		var $$ = this.owner,
			opacity = isHidden ? "0" : "1";
		$$.axes.x.style("opacity", opacity), $$.axes.y.style("opacity", opacity), $$.axes.y2.style("opacity", opacity), $$.axes.subx.style("opacity", opacity), transitions.axisX.call($$.xAxis), transitions.axisY.call($$.yAxis), transitions.axisY2.call($$.y2Axis), transitions.axisSubX.call($$.subXAxis);
	}, Axis;
}();

exports.default = Axis;
module.exports = exports["default"];

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;
exports.getCssRules = exports.toArray = exports.capitalize = exports.merge = exports.getRectSegList = exports.removeEvent = exports.addEvent = exports.extend = exports.brushEmpty = exports.getBrushSelection = exports.diffDomain = exports.getPathBox = exports.sanitise = exports.hasValue = exports.getOption = exports.asHalfPixel = exports.isFunction = exports.ceil10 = exports.notEmpty = exports.isObjectType = exports.isObject = exports.isEmpty = exports.isArray = exports.isNumber = exports.isString = exports.isBoolean = exports.isUndefined = exports.isDefined = exports.isValue = undefined;

var _typeof2 = __webpack_require__(7),
	_typeof3 = _interopRequireDefault(_typeof2),
	_d3Selection = __webpack_require__(4),
	_d3Brush = __webpack_require__(4),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isValue = function(v) {
	return v || v === 0;
},
	isFunction = function(v) {
	return typeof v === "function";
},
	isString = function(v) {
	return typeof v === "string";
},
	isNumber = function(v) {
	return typeof v === "number";
},
	isUndefined = function(v) {
	return typeof v === "undefined";
},
	isDefined = function(v) {
	return typeof v !== "undefined";
},
	isBoolean = function(v) {
	return typeof v === "boolean";
},
	ceil10 = function(v) {
	return Math.ceil(v / 10) * 10;
},
	asHalfPixel = function(n) {
	return Math.ceil(n) + .5;
},
	diffDomain = function(d) {
	return d[1] - d[0];
},
	isObjectType = function(v) {
	return (typeof v === "undefined" ? "undefined" : (0, _typeof3.default)(v)) === "object";
},
	isEmpty = function(o) {
	return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && Object.keys(o).length === 0;
},
	isArray = function(arr) {
	return arr && arr.constructor === Array;
},
	isObject = function(obj) {
	return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
},
	notEmpty = function(o) {
	return !isEmpty(o);
},
	getOption = function(options, key, defaultValue) {
	return isDefined(options[key]) ? options[key] : defaultValue;
},
	hasValue = function(dict, value) {
	var found = !1;

	return Object.keys(dict).forEach(function (key) {
		return dict[key] === value && (found = !0);
	}), found;
},
	sanitise = function(str) {
	return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
},
	getRectSegList = function(path) {
	/*
* seg1 ---------- seg2
*   |               |
*   |               |
*   |               |
* seg0 ---------- seg3
* */
	var bbox = path.getBBox(),
		list = [];

	// seg0

	return list.push({
		x: bbox.x,
		y: bbox.y + bbox.height
	}), list.push({
		x: bbox.x,
		y: bbox.y
	}), list.push({
		x: bbox.x + bbox.width,
		y: bbox.y
	}), list.push({
		x: bbox.x + bbox.width,
		y: bbox.y + bbox.height
	}), list;
},
	getPathBox = function(path) {
	var box = path.getBoundingClientRect(),
		items = getRectSegList(path),
		minX = items[0].x,
		minY = Math.min(items[0].y, items[1].y);

	return {
		x: minX,
		y: minY,
		width: box.width,
		height: box.height
	};
},
	getBrushSelection = function() {
	var selection = null,
		event = _d3Selection.event;

	// check from event

	return event && event.constructor.name === "BrushEvent" ? selection = event.selection : this.context && (selection = this.context.select("." + _classes2.default.brush).node()) && (selection = (0, _d3Brush.brushSelection)(selection)), selection;
},
	brushEmpty = function() {
	var selection = this.getBrushSelection();

	return !selection || selection[0] === selection[1];
};
/**
 * Check if is array
 * @param {Array} arr
 * @returns {Boolean}
 * @private
 */

/**
 * Check if is object
 * @param {Object} obj
 * @returns {Boolean}
 * @private
 */

/**
 * Replace tag sign to html entity
 * @param {String} str
 * @return {String}
 * @private
 */

// substitution of SVGPathSeg API polyfill

// return brush selection array
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

function extend() {
	var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
		source = arguments[1];

	for (var p in source) target[p] = source[p];

	return target;
}

var SUPPORT_ADDEVENTLISTENER = "addEventListener" in document,
	SUPPORT_PASSIVE = function() {
	var supportsPassiveOption = !1;

	try {
		SUPPORT_ADDEVENTLISTENER && Object.defineProperty && document.addEventListener("test", null, Object.defineProperty({}, "passive", {
			get: function get() {
				supportsPassiveOption = !0;
			}
		}));
	} catch (e) {}

	return supportsPassiveOption;
}();

function addEvent(element, type, handler, eventListenerOptions) {
	if (SUPPORT_ADDEVENTLISTENER) {
		var options = eventListenerOptions || !1;

		isObjectType(eventListenerOptions) && (options = !!SUPPORT_PASSIVE && eventListenerOptions), element.addEventListener(type, handler, options);
	} else element.attachEvent ? element.attachEvent("on" + type, handler) : element["on" + type] = handler;
}

function removeEvent(element, type, handler) {
	element.removeEventListener ? element.removeEventListener(type, handler, !1) : element.detachEvent ? element.detachEvent("on" + type, handler) : element["on" + type] = null;
}

/**
 * Return first letter capitalized
 * @param {String} str
 * @private
 */
var capitalize = function(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
},
	merge = function(target) {
	for (var _len = arguments.length, objectN = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) objectN[_key - 1] = arguments[_key];

	if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;

	var source = objectN.shift();

	return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
		var value = source[key];

		isObject(value) ? (!target[key] && (target[key] = {}), target[key] = merge(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
	}), extend.apply(undefined, [target].concat(objectN));
},
	toArray = function(v) {
	return [].slice.call(v);
},
	getCssRules = function(styleSheets) {
	var rules = [];

	return styleSheets.forEach(function (sheet) {
		try {
			sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
		} catch (e) {
			console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
		}
	}), rules;
};

/**
 * Merge object returning new object
 * @param {Object} target
 * @param {Object} objectN
 * @returns {Object} merged target object
 * @private
 * @example
 *  var target = { a: 1 };
 *  utils.extend(target, { b: 2, c: 3 });
 *  target;  // { a: 1, b: 2, c: 3 };
 */

/**
 * Copy array like object to array
 * @param {Object} v
 * @returns {Array}
 * @private
 */

/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
exports.isValue = isValue;
exports.isDefined = isDefined;
exports.isUndefined = isUndefined;
exports.isBoolean = isBoolean;
exports.isString = isString;
exports.isNumber = isNumber;
exports.isArray = isArray;
exports.isEmpty = isEmpty;
exports.isObject = isObject;
exports.isObjectType = isObjectType;
exports.notEmpty = notEmpty;
exports.ceil10 = ceil10;
exports.isFunction = isFunction;
exports.asHalfPixel = asHalfPixel;
exports.getOption = getOption;
exports.hasValue = hasValue;
exports.sanitise = sanitise;
exports.getPathBox = getPathBox;
exports.diffDomain = diffDomain;
exports.getBrushSelection = getBrushSelection;
exports.brushEmpty = brushEmpty;
exports.extend = extend;
exports.addEvent = addEvent;
exports.removeEvent = removeEvent;
exports.getRectSegList = getRectSegList;
exports.merge = merge;
exports.capitalize = capitalize;
exports.toArray = toArray;
exports.getCssRules = getCssRules;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

exports.default = function(obj) {
return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/**
 * CSS class names definition
 * @private
 */
exports.default = {
	target: "bb-target",
	chart: "bb-chart",
	chartLine: "bb-chart-line",
	chartLines: "bb-chart-lines",
	chartBar: "bb-chart-bar",
	chartBars: "bb-chart-bars",
	chartText: "bb-chart-text",
	chartTexts: "bb-chart-texts",
	chartArc: "bb-chart-arc",
	chartArcs: "bb-chart-arcs",
	chartArcsTitle: "bb-chart-arcs-title",
	chartArcsBackground: "bb-chart-arcs-background",
	chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
	chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
	chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
	selectedCircle: "bb-selected-circle",
	selectedCircles: "bb-selected-circles",
	eventRect: "bb-event-rect",
	eventRects: "bb-event-rects",
	eventRectsSingle: "bb-event-rects-single",
	eventRectsMultiple: "bb-event-rects-multiple",
	zoomRect: "bb-zoom-rect",
	brush: "bb-brush",
	focused: "bb-focused",
	defocused: "bb-defocused",
	region: "bb-region",
	regions: "bb-regions",
	title: "bb-title",
	tooltipContainer: "bb-tooltip-container",
	tooltip: "bb-tooltip",
	tooltipName: "bb-tooltip-name",
	shape: "bb-shape",
	shapes: "bb-shapes",
	line: "bb-line",
	lines: "bb-lines",
	bar: "bb-bar",
	bars: "bb-bars",
	circle: "bb-circle",
	circles: "bb-circles",
	arc: "bb-arc",
	arcs: "bb-arcs",
	area: "bb-area",
	areas: "bb-areas",
	empty: "bb-empty",
	text: "bb-text",
	texts: "bb-texts",
	gaugeValue: "bb-gauge-value",
	grid: "bb-grid",
	gridLines: "bb-grid-lines",
	xgrid: "bb-xgrid",
	xgrids: "bb-xgrids",
	xgridLine: "bb-xgrid-line",
	xgridLines: "bb-xgrid-lines",
	xgridFocus: "bb-xgrid-focus",
	ygrid: "bb-ygrid",
	ygrids: "bb-ygrids",
	ygridLine: "bb-ygrid-line",
	ygridLines: "bb-ygrid-lines",
	axis: "bb-axis",
	axisX: "bb-axis-x",
	axisXLabel: "bb-axis-x-label",
	axisY: "bb-axis-y",
	axisYLabel: "bb-axis-y-label",
	axisY2: "bb-axis-y2",
	axisY2Label: "bb-axis-y2-label",
	legendBackground: "bb-legend-background",
	legendItem: "bb-legend-item",
	legendItemEvent: "bb-legend-item-event",
	legendItemTile: "bb-legend-item-tile",
	legendItemPoint: "bb-legend-item-point",
	legendItemHidden: "bb-legend-item-hidden",
	legendItemFocused: "bb-legend-item-focused",
	dragarea: "bb-dragarea",
	EXPANDED: "_expanded_",
	SELECTED: "_selected_",
	INCLUDED: "_included_"
};
module.exports = exports["default"];

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;
exports.default = undefined;

var _typeof2 = __webpack_require__(7),
	_typeof3 = _interopRequireDefault(_typeof2),
	_d3Scale = __webpack_require__(4),
	_d3Selection = __webpack_require__(4),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Features:
// 1. category axis
// 2. ceil values of translate/x/y to int for half pixel anti-aliasing
// 3. multiline tick text

function _default() {

	function axisX(selection, x) {
		selection.attr("transform", function(d) {
			return "translate(" + Math.ceil(x(d) + tickOffset) + ", 0)";
		});
	}

	function axisY(selection, y) {
		selection.attr("transform", function(d) {
			return "translate(0," + Math.ceil(y(d)) + ")";
		});
	}

	function scaleExtent(domain) {
		var start = domain[0],
			stop = domain[domain.length - 1];

		return start < stop ? [start, stop] : [stop, start];
	}

	function generateTicks(scale) {
		var ticks = [];

		if (scale.ticks) return scale.ticks.apply(scale, tickArguments ? (0, _util.toArray)(tickArguments) : []).map(function (v) {
				return (
					// round the tick value if is number
					/(string|number)/.test(typeof v === "undefined" ? "undefined" : (0, _typeof3.default)(v)) && !isNaN(v) ? Math.round(v * 10) / 10 : v
				);
			});

		for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

		return ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0])), ticks;
	}

	function copyScale() {
		var newScale = scale.copy();

		if (params.isCategory || !newScale.domain().length) {
			var domain = scale.domain();

			newScale.domain([domain[0], domain[1] - 1]);
		}

		return newScale;
	}

	function textFormatted(v) {
		// to round float numbers from 'binary floating point'
		// https://en.wikipedia.org/wiki/Double-precision_floating-point_format
		// https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand
		var value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
			formatted = tickFormat ? tickFormat(value) : value;

		return (0, _util.isDefined)(formatted) ? formatted : "";
	}

	function transitionise(selection) {
		return params.withoutTransition ? selection.interrupt() : selection.transition(transition);
	}

	function axis(g) {
		g.each(function () {

			// this should be called only when category axis
			function splitTickText(d, maxWidthValue) {

				function split(splitted, text) {
					spaceIndex = undefined;

					for (var i = 1; i < text.length; i++)

					// if text width gets over tick width, split by space index or current index
					if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = sizeFor1Char.w * subtext.length, maxWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

					return splitted.concat(text);
				}

				var tickText = textFormatted(d),
					maxWidth = maxWidthValue,
					subtext = void 0,
					spaceIndex = void 0,
					textWidth = void 0;
				return Object.prototype.toString.call(tickText) === "[object Array]" ? tickText : ((!maxWidth || maxWidth <= 0) && (maxWidth = isVertical ? 95 : params.isCategory ? Math.ceil(scale1(ticks[1]) - scale1(ticks[0])) - 12 : 110), split([], tickText + ""));
			}

			function tspanDy(d, i) {
				var dy = sizeFor1Char.h;

				return i === 0 && (dy = orient === "left" || orient === "right" ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : ".71em"), dy;
			}

			function tickSize(d) {
				var tickPosition = scale(d) + (tickCentered ? 0 : tickOffset);

				return range[0] < tickPosition && tickPosition < range[1] ? 6 : 0;
			}

			var g = (0, _d3Selection.select)(this);

			axis.g = g;

			var scale0 = this.__chart__ || scale,
				scale1 = copyScale();
			this.__chart__ = scale1;

			// count of tick data in array
			var ticks = tickValues || generateTicks(scale1),
				tick = g.selectAll(".tick").data(ticks, scale1),
				tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
				tickExit = tick.exit().remove();

			// update selection

			// enter selection

			// MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.
			tick = tickEnter.merge(tick);

			var tickUpdate = transitionise(tick).style("opacity", "1"),
				tickTransform = void 0,
				tickX = void 0,
				tickY = void 0,
				range = scale.rangeExtent ? scale.rangeExtent() : scaleExtent((params.orgXScale || scale).range()),
				path = g.selectAll(".domain").data([0]),
				pathUpdate = path.enter().append("path").attr("class", "domain").merge(transitionise(path));

			// update selection - data join

			// enter + update selection
			tickEnter.append("line"), tickEnter.append("text");

			var lineEnter = tickEnter.select("line"),
				lineUpdate = tickUpdate.select("line"),
				textEnter = tickEnter.select("text"),
				textUpdate = tickUpdate.select("text");
			params.isCategory ? (tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2), tickX = tickCentered ? 0 : tickOffset, tickY = tickCentered ? tickOffset : 0) : (tickX = 0, tickOffset = tickX);

			var tspan = void 0,
				sizeFor1Char = _getSizeFor1Char(g.select(".tick")),
				counts = [],
				tickLength = Math.max(6, 0) + 3,
				isVertical = orient === "left" || orient === "right",
				text = tick.select("text");tspan = text.selectAll("tspan").data(function (d, index) {
				var split = params.tickMultiline ? splitTickText(d, params.tickWidth) : (0, _util.isArray)(textFormatted(d)) ? textFormatted(d).concat() : [textFormatted(d)];

				return counts[index] = split.length, split.map(function (splitted) {
					return {
						index: index,
						splitted: splitted
					};
				});
			}), tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
				return d.splitted;
			});

			var rotate = params.tickTextRotate;

			if (orient === "bottom" ? (tickTransform = axisX, lineEnter.attr("y2", 6), textEnter.attr("y", 9), lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", tickSize), textUpdate.attr("x", 0).attr("y", function(r) {
				return r ? 11.5 - 2.5 * (r / 15) * (r > 0 ? 1 : -1) : 9;
			}(rotate)).style("text-anchor", function(r) {
				return r ? r > 0 ? "start" : "end" : "middle";
			}(rotate)).attr("transform", function(r) {
				return r ? "rotate(" + r + ")" : "";
			}(rotate)), tspan.attr("x", 0).attr("dy", tspanDy).attr("dx", function(r) {
				return r ? 8 * Math.sin(Math.PI * (r / 180)) : 0;
			}(rotate)), pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize)) : orient === "top" ? (tickTransform = axisX, lineEnter.attr("y2", -6), textEnter.attr("y", -9), lineUpdate.attr("x2", 0).attr("y2", -6), textUpdate.attr("x", 0).attr("y", -9), text.style("text-anchor", "middle"), tspan.attr("x", 0).attr("dy", "0em"), pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize)) : orient === "left" ? (tickTransform = axisY, lineEnter.attr("x2", -6), textEnter.attr("x", -9), lineUpdate.attr("x2", -6).attr("y1", tickY).attr("y2", tickY), textUpdate.attr("x", -9).attr("y", tickOffset), text.style("text-anchor", "end"), tspan.attr("x", -9).attr("dy", tspanDy), pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize)) : orient === "right" ? (tickTransform = axisY, lineEnter.attr("x2", 6), textEnter.attr("x", 9), lineUpdate.attr("x2", 6).attr("y2", 0), textUpdate.attr("x", 9).attr("y", 0), text.style("text-anchor", "start"), tspan.attr("x", 9).attr("dy", tspanDy), pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize)) : void 0, params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
				(0, _d3Selection.select)(this).text(params.tickTitle[index]);
			}), scale1.bandwidth) {
				var x = scale1,
					dx = x.bandwidth() / 2;
				scale0 = function(d) {
					return x(d) + dx;
				}, scale1 = scale0;
			} else scale0.bandwidth ? scale0 = scale1 : tickExit.call(tickTransform, scale1);

			tickEnter.call(tickTransform, scale0), tickUpdate.call(tickTransform, scale1);
		});
	}

	var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
		scale = (0, _d3Scale.scaleLinear)(),
		orient = "bottom",
		outerTickSize = params.withOuterTick ? 6 : 0,
		tickValues = null,
		tickFormat = void 0,
		tickArguments = void 0,
		tickOffset = 0,
		tickCulling = !0,
		tickCentered = void 0,
		transition = void 0,
		_getSizeFor1Char = function getSizeFor1Char(tick) {
		// default size for one character
		var size = {
			h: 11.5,
			w: 5.5
		};

		return tick.empty() || tick.select("text").text("0").call(function (el) {
			var box = el.node().getBBox(),
				h = box.height,
				w = box.width;
			h && w && (size.h = h, size.w = w), el.text("");
		}), _getSizeFor1Char = function getSizeFor1Char() {
			return size;
		}, size;
	};

	return axis.scale = function(x) {
		return arguments.length ? (scale = x, axis) : scale;
	}, axis.orient = function(x) {
		return arguments.length ? (orient = x in {
			top: 1,
			right: 1,
			bottom: 1,
			left: 1
		} ? x + "" : "bottom", axis) : orient;
	}, axis.tickFormat = function(format) {
		return arguments.length ? (tickFormat = format, axis) : tickFormat;
	}, axis.tickCentered = function(isCentered) {
		return arguments.length ? (tickCentered = isCentered, axis) : tickCentered;
	}, axis.tickOffset = function() {
		return tickOffset;
	}, axis.tickInterval = function(size) {
		var interval = void 0;

		if (params.isCategory) interval = tickOffset * 2;else {
			var length = axis.g.select("path.domain").node().getTotalLength() - outerTickSize * 2;

			interval = length / (size || axis.g.selectAll("line").size());
		}

		return interval === Infinity ? 0 : interval;
	}, axis.ticks = function() {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

		return args.length ? (tickArguments = (0, _util.toArray)(args), axis) : tickArguments;
	}, axis.tickCulling = function(culling) {
		return arguments.length ? (tickCulling = culling, axis) : tickCulling;
	}, axis.tickValues = function(x) {
		if ((0, _util.isFunction)(x)) tickValues = function() {
				return x(scale.domain());
			};else {
			if (!arguments.length) return tickValues;

			tickValues = x;
		}

		return this;
	}, axis.setTransition = function(t) {
		return transition = t, this;
	}, axis;
} /**
* Copyright (c) 2017 NAVER Corp.
* billboard.js project is licensed under the MIT license
* @ignore
*/
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Options = __webpack_require__(13),
	_Options2 = _interopRequireDefault(_Options),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	getOptions: function getOptions() {
		var config = new _Options2.default();

		return (0, _util.merge)(config.value, this.additionalConfig);
	},

	additionalConfig: {},

	/**
* Load configuration option
* @param {Object} config User's generation config value
* @private
*/
	loadConfig: function loadConfig(config) {
		var thisConfig = this.config,
			target = void 0,
			keys = void 0,
			read = void 0,
			find = function() {
			var key = keys.shift();

			return key && target && (0, _util.isObjectType)(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
		};
		Object.keys(thisConfig).forEach(function (key) {
			target = config, keys = key.split("_"), read = find(), (0, _util.isDefined)(read) && (thisConfig[key] = read);
		});
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;

var _classCallCheck2 = __webpack_require__(2),
	_classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */
var Options = function Options() {
										(0, _classCallCheck3.default)(this, Options), this.value = {
																				/**
					 * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.
					 * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).<br><br>
					 * If this option is not specified, the chart will be generated but not be set. Instead, we can access the element by chart.element and set it by ourselves.<br>
					 * - **NOTE:**
					 *  > When chart is not bound, it'll start observing if `chart.element` is bound by MutationObserver.<br>
					 *  > In this case, polyfill is required in IE9 and IE10 because they do not support MutationObserver.<br>
					 *  > On the other hand, if chart always will be bound, polyfill will not be required because MutationObserver will never be called.
					 * @name bindto
					 * @memberOf Options
					 * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
					 * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
					 * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
					 *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
					 * @default #chart
					 * @example
					 * bindto: "#myContainer"
					 *
					 * // or HTMLElement
					 * bindto: document.getElementById("myContainer")
					 *
					 * // or D3 selection object
					 * bindto: d3.select("#myContainer")
					 *
					 * // or to change default classname
					 * bindto: {
					 *    element: "#chart",
					 *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
					 * }
					 */
																				bindto: "#chart",

																				/**
					 * Set clip-path property of chart element
					 * - **NOTE:**
					 *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
					 *  > Is to make chart element positioned over axis element.
					 * @name clipPath
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * clipPath: false
					 */
																				clipPath: !0,

																				/**
					 * Set svg element's class name
					 * @name svg
					 * @memberOf Options
					 * @type {Object}
					 * @property {String} [svg.classname] class name for svg element
					 * @example
					 * svg: {
							  *   classname: "test_class"
					 * }
					 */
																				svg_classname: undefined,

																				/**
					 * The desired size of the chart element.
					 * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
					 * @name size
					 * @memberOf Options
					 * @type {Object}
					 * @property {Number} [size.width] width of the chart element
					 * @property {Number} [size.height] height of the chart element
					 * @example
					 * size: {
							  *   width: 640,
							  *   height: 480
					 * }
					 */
																				size_width: undefined,
																				size_height: undefined,

																				/**
					 * The padding of the chart element.
					 * @name padding
					 * @memberOf Options
					 * @type {Object}
					 * @property {Number} [padding.top] padding on the top of chart
					 * @property {Number} [padding.right] padding on the right of chart
					 * @property {Number} [padding.bottom] padding on the bottom of chart
					 * @property {Number} [padding.left] padding on the left of chart
					 * @example
					 * padding: {
							  *   top: 20,
							  *   right: 20,
							  *   bottom: 20,
							  *   left: 20
					 * }
					 */
																				padding_left: undefined,
																				padding_right: undefined,
																				padding_top: undefined,
																				padding_bottom: undefined,

																				/**
					 * Set chart resize options
					 * @name resize
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
					 * @example
					 *  resize: {
					 *      auto: false
					 *  }
					 */
																				resize_auto: !0,

																				/**
					 * Set zoom options
					 * @name zoom
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [zoom.enabled=false] Enable zooming.
					 * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
					 *  If true set, y domain will be updated according to the zoomed region.
					 * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
					 * @property {Number} [zoom.x.min] Set x Axis minimum zoom range
					 * @property {Number} [zoom.x.max] Set x Axis maximum zoom range
					 * @property {Function} [zoom.onzoom=function(){}] Set callback that is called when the chart is zooming.<br>
					 *  Specified function receives the zoomed domain.
					 * @property {Function} [zoom.onzoomstart=function(){}] Set callback that is called when zooming starts.<br>
					 *  Specified function receives the zoom event.
					 * @property {Function} [zoom.onzoomend=function(){}] Set callback that is called when zooming ends.<br>
					 *  Specified function receives the zoomed domain.
					 * @example
					 *  zoom: {
					 *      enabled: true,
					 *      rescale: true,
					 *      extent: [1, 100]  // enable more zooming
					 *      x: {
					 *          min: -1,  // set min range
					 *          max: 10  // set max range
					 *      },
					 *      onzoom: function(domain) { ... },
					 *      onzoomstart: function(event) { ... },
					 *      onzoomend: function(domain) { ... }
					 *  }
					 */
																				zoom_enabled: !1,
																				zoom_extent: undefined,
																				zoom_privileged: !1,
																				zoom_rescale: !1,
																				zoom_onzoom: function zoom_onzoom() {},
																				zoom_onzoomstart: function zoom_onzoomstart() {},
																				zoom_onzoomend: function zoom_onzoomend() {},
																				zoom_x_min: undefined,
																				zoom_x_max: undefined,

																				/**
					 * Interaction options
					 * @name interaction
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
					 *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
					 * @property {Boolean} [interaction.brighten=true]
					 * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
					 * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
					 * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
					 * @example
					 * interaction: {
							  *    enabled: false,
							  *    inputType: {
							  *        mouse: true,
							  *        touch: false
							  *
							  *        // or declare preventDefault explicitly.
							  *        // In this case touch inputType is enabled by default
							  *        touch: {
							  *            preventDefault: true
							  *
							  *            // or threshold pixel value (pixel moved from touchstart to touchmove)
							  *            preventDefault: 5
							  *        }
							  *    }
					 * }
					 */
																				interaction_enabled: !0,
																				interaction_brighten: !0,
																				interaction_inputType_mouse: !0,
																				interaction_inputType_touch: {},

																				/**
					 * Set a callback to execute when mouse/touch enters the chart.
					 * @name onover
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onover: function() {
					 *   ...
					 * }
					 */
																				onover: function onover() {},

																				/**
					 * Set a callback to execute when mouse/touch leaves the chart.
					 * @name onout
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onout: function() {
					 *   ...
					 * }
					 */
																				onout: function onout() {},

																				/**
					 * Set a callback to execute when user resizes the screen.
					 * @name onresize
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onresize: function() {
					 *   ...
					 * }
					 */
																				onresize: function onresize() {},

																				/**
					 * SSet a callback to execute when screen resize finished.
					 * @name onresized
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onresized: function() {
					 *   ...
					 * }
					 */
																				onresized: function onresized() {},

																				/**
					 * Set a callback to execute before the chart is initialized
					 * @name onbeforeinit
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onbeforeinit: function() {
					 *   ...
					 * }
					 */
																				onbeforeinit: undefined,

																				/**
					 * Set a callback to execute when the chart is initialized.
					 * @name oninit
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * oninit: function() {
					 *   ...
					 * }
					 */
																				oninit: function oninit() {},

																				/**
					 * Set a callback to execute after the chart is initialized
					 * @name onafterinit
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onafterinit: function() {
					 *   ...
					 * }
					 */
																				onafterinit: undefined,

																				/**
					 * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
					 * @name onrendered
					 * @memberOf Options
					 * @type {Function}
					 * @default function(){}
					 * @example
					 * onrendered: function() {
					 *   ...
					 * }
					 */
																				onrendered: function onrendered() {},

																				/**
					 * Set duration of transition (in milliseconds) for chart animation.<br><br>
					 * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
					 * @name transition
					 * @memberOf Options
					 * @type {Object}
					 * @property {Number} [transition.duration=350] duration in milliseconds
					 * @example
					 * transition: {
					 *    duration: 500
					 * }
					 */
																				transition_duration: 350,

																				/**
					 * Specify the key of x values in the data.<br><br>
					 * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
					 * @name data․x
					 * @memberOf Options
					 * @type {String}
					 * @default undefined
					 * @example
					 * data: {
							  *   x: "date"
					 * }
					 */
																				data_x: undefined,

																				/**
					 * Specify the keys of the x values for each data.<br><br>
					 * This option can be used if we want to show the data that has different x values.
					 * @name data․xs
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
							  *   xs: {
							  *      data1: "x1",
							  *      data2: "x2"
							  *   }
					 * }
					 */
																				data_xs: {},

																				/**
					 * Set a format to parse string specifed as x.
					 * @name data․xFormat
					 * @memberOf Options
					 * @type {String}
					 * @default %Y-%m-%d
					 * @example
					 * data: {
							  *   xFormat: "%Y-%m-%d %H:%M:%S"
					 * }
					 * @see [D3's time specifier](https://npm.runkit.com/d3-time-format)
					 */
																				data_xFormat: "%Y-%m-%d",

																				/**
					 * Set localtime format to parse x axis.
					 * @name data․xLocaltime
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * data: {
							  *   xLocaltime: false
					 * }
					 */
																				data_xLocaltime: !0,

																				/**
					 * Sort on x axis.
					 * @name data․xSort
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * data: {
							  *   xSort: false
					 * }
					 */
																				data_xSort: !0,
																				data_idConverter: function data_idConverter(id) {
																														return id;
																				},

																				/**
					 * Set custom data name.
					 * @name data․names
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
							  *   names: {
							  *     data1: "Data Name 1",
							  *     data2: "Data Name 2"
							  *   }
					 * }
					 */
																				data_names: {},

																				/**
					 * Set custom data class.<br><br>
					 * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
					 * @name data․classes
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
							  *   classes: {
							  *     data1: "additional-data1-class",
							  *     data2: "additional-data2-class"
							  *   }
					 * }
					 */
																				data_classes: {},

																				/**
					 * Set groups for the data for stacking.
					 * @name data․groups
					 * @memberOf Options
					 * @type {Array}
					 * @default []
					 * @example
					 * data: {
							  *   groups: [
							  *     ["data1", "data2"],
							  *     ["data3"]
							  *   ]
					 * }
					 */
																				data_groups: [],

																				/**
					 * Set y axis the data related to. y and y2 can be used.
					 * @name data․axes
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
					 *   axes: {
					 *     data1: "y",
					 *     data2: "y2"
					 *   }
					 * }
					 */
																				data_axes: {},

																				/**
					 * Set chart type at once.<br><br>
					 * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
					 * **Available Values:**
					 * - area
					 * - area-line-range
					 * - area-spline
					 * - area-spline-range
					 * - area-step
					 * - bar
					 * - bubble
					 * - donut
					 * - gauge
					 * - line
					 * - pie
					 * - scatter
					 * - spline
					 * - step
					 * @name data․type
					 * @memberOf Options
					 * @type {String}
					 * @default line
					 * @example
					 * data: {
					 *    type: "bar"
					 * }
					 */
																				data_type: undefined,

																				/**
					 * Set chart type for each data.<br>
					 * This setting overwrites data.type setting.
					 * @name data․types
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
					 *   types: {
					 *     data1: "bar",
					 *     data2: "spline"
					 *   }
					 * }
					 */
																				data_types: {},

																				/**
					 * Set labels options
					 * @name data․labels
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [donut.labels=false] Show or hide labels on each data points
					 * @property {Function} [donut.labels.format={}] Set formatter function for data labels.<br>
					 * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
					 *  - `v` is the value of the data point where the label is shown.
					 *  - `id` is the id of the data where the label is shown.
					 *  - `i` is the index of the data point where the label is shown.
					 *  - `j` is the sub index of the data point where the label is shown.<br><br>
					 * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
					 * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
					 * @property {NUmber} [data.labels.position.y=0] y coordinate position, relative the original.
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
					 *   labels: true,
					 *
					 *   // or set specific options
					 *   labels: {
					 *     format: function(v, id, i, j) { ... },
					 *
					 *     // it's possible to set for each data
					 *     format: {
					 *         data1: function(v, id, i, j) { ... },
					 *         ...
					 *     },
					 *     position: {
					 *        x: -10,
					 *        y: 10
					 *     }
					 *   }
					 * }
					 */
																				data_labels: {},
																				data_labels_position: {},

																				/**
					 *  This option changes the order of stacking data and pieces of pie/donut.
					 *  - If `null` specified, it will be the order the data loaded.
					 *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
					 *
					 *  **Available Values:**
					 *  - `desc`: In descending order
					 *  - `asc`: In ascending order
					 *  - `null`: It keeps the data load order
					 *  - `function(data1, data2) { ... }`: Array.sort compareFunction
					 * @name data․order
					 * @memberOf Options
					 * @type {String|Function|null}
					 * @default desc
					 * @example
					 * data: {
					 *   // in descending order (default)
					 *   order: "desc"
					 *
					 *   // in ascending order
					 *   order: "asc"
					 *
					 *   // keeps data input order
					 *   order: null
					 *
					 *   // specifying sort function
					 *   order: function(a, b) {
					 *       // param data passed format
					 *       {
					 *          id: "data1", id_org: "data1", values: [
					 *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
					 *              ...
					 *          ]
					 *       }
					 *   }
					 * }
					 */
																				data_order: "desc",

																				/**
					 * Define regions for each data.<br><br>
					 * The values must be an array for each data and it should include an object that has start, end, style. If start is not set, the start will be the first data point. If end is not set, the end will be the last data point.<br>
					 * Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
					 * @name data․regions
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
					 *   regions: {
					 *     data1: [{
					 *         "start": 1,
					 *         "end": 2,
					 *         "style": "dashed"
					 *     }, {
					 *         "start":3
					 *     }],
					 *     ...
					 *   }
					 * }
					 */
																				data_regions: {},

																				/**
					 * Set color converter function.<br><br>
					 * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
					 * @name data․color
					 * @memberOf Options
					 * @type {Function}
					 * @default undefined
					 * @example
					 * data: {
					 *   color: function(color, d) { ... }
					 * }
					 */
																				data_color: undefined,

																				/**
					 * Set color for each data.
					 * @name data․colors
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * data: {
					 *   colors: {
					 *     data1: "#ff0000",
					 *     ...
					 *   }
					 * }
					 */
																				data_colors: {},

																				/**
					 * Hide each data when the chart appears.<br><br>
					 * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
					 * @name data․hide
					 * @memberOf Options
					 * @type {Boolean|Array}
					 * @default false
					 * @example
					 * data: {
					 *   // all of data will be hidden
					 *   hide: true
					 *
					 *   // specified data will be hidden
					 *   hide: ["data1", ...]
					 * }
					 */
																				data_hide: !1,
																				data_filter: undefined,

																				/**
					 * Set data selection enabled.<br><br>
					 * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
					 * @name data․selection․enabled
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * data: {
					 *    selection: {
					 *       enabled: true
					 *    }
					 * }
					 */
																				data_selection_enabled: !1,

																				/**
					 * Set grouped selection enabled.<br><br>
					 * If this option set true, multiple data points that have same x value will be selected by one selection.
					 * @name data․selection․grouped
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * data: {
					 *    selection: {
					 *       grouped: true
					 *    }
					 * }
					 */
																				data_selection_grouped: !1,

																				/**
					 * Set a callback for each data point to determine if it's selectable or not.<br><br>
					 * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
					 * @name data․selection․isselectable
					 * @memberOf Options
					 * @type {Function}
					 * @default function() { return true; }
					 * @example
					 * data: {
					 *    selection: {
					 *       isselectable: function(d) { ... }
					 *    }
					 * }
					 */
																				data_selection_isselectable: function data_selection_isselectable() {
																														return !0;
																				},

																				/**
					 * Set multiple data points selection enabled.<br><br>
					 * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
					 * @name data․selection․multiple
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * data: {
					 *    selection: {
					 *       multiple: false
					 *    }
					 * }
					 */
																				data_selection_multiple: !0,

																				/**
					 * Enable to select data points by dragging.<br><br>
					 * If this option set true, data points can be selected by dragging.
					 * **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
					 * @name data․selection․draggable
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * data: {
					 *    selection: {
					 *       draggable: true
					 *   }
					 * }
					 */
																				data_selection_draggable: !1,

																				/**
					 * Set a callback for click event on each data point.<br><br>
					 * This callback will be called when each data point clicked and will receive d and element as the arguments. d is the data clicked and element is the element clicked. In this callback, this will be the Chart object.
					 * @name data․onclick
					 * @memberOf Options
					 * @type {Function}
					 * @default function() {}
					 * @example
					 * data: {
					 *     onclick: function(d, element) { ... }
					 * }
					 */
																				data_onclick: function data_onclick() {},

																				/**
					 * Set a callback for mouse/touch over event on each data point.<br><br>
					 * This callback will be called when mouse cursor or via touch moves onto each data point and will receive d as the argument. d is the data where mouse cursor moves onto. In this callback, this will be the Chart object.
					 * @name data․onover
					 * @memberOf Options
					 * @type {Function}
					 * @default function() {}
					 * @example
					 * data: {
					 *     onover: function(d) { ... }
					 * }
					 */
																				data_onover: function data_onover() {},

																				/**
					 * Set a callback for mouse/touch out event on each data point.<br><br>
					 * This callback will be called when mouse cursor or via touch moves out each data point and will receive d as the argument. d is the data where mouse cursor moves out. In this callback, this will be the Chart object.
					 * @name data․onout
					 * @memberOf Options
					 * @type {Function}
					 * @default function() {}
					 * @example
					 * data: {
					 *     onout: function(d) { ... }
					 * }
					 */
																				data_onout: function data_onout() {},

																				/**
					 * Set a callback for on data selection.
					 * @name data․onselected
					 * @memberOf Options
					 * @type {Function}
					 * @default function() {}
					 * @example
					 * data: {
					 *     onselected: function(d, element) {
					 *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
					 *        // element - <circle>
					 *        ...
					 *    }
					 * }
					 */
																				data_onselected: function data_onselected() {},

																				/**
					 * Set a callback for on data un-selection.
					 * @name data․onunselected
					 * @memberOf Options
					 * @type {Function}
					 * @default function() {}
					 * @example
					 * data: {
					 *     onunselected: function(d, element) {
					 *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
					 *        // element - <circle>
					 *        ...
					 *    }
					 * }
					 */
																				data_onunselected: function data_onunselected() {},

																				/**
					 * Set a callback for minimum data
					 * @name data․onmin
					 * @memberOf Options
					 * @type {Function}
					 * @default undefined
					 * @example
					 *  onmin: function(data) {
					 *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
						*    ...
					 *  }
					 */
																				data_onmin: undefined,

																				/**
					 * Set a callback for maximum data
					 * @name data․onmax
					 * @memberOf Options
					 * @type {Function}
					 * @default undefined
					 * @example
					 *  onmax: function(data) {
					 *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
						*    ...
					 *  }
					 */
																				data_onmax: undefined,

																				/**
					 * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
					 * @name data․url
					 * @memberOf Options
					 * @type {String}
					 * @default undefined
					 * @example
					 * data: {
					 *     url: "/data/test.csv"
					 * }
					 */
																				data_url: undefined,
																				data_headers: undefined,

																				/**
					 * Parse a JSON object for data. See also data.keys.
					 * @name data․json
					 * @memberOf Options
					 * @type {Object}
					 * @default undefined
					 * @see data․keys
					 * @example
					 * data: {
					 *     json: [
					 *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
					 *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
					 *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
					 *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
					 *     ],
					 *     keys: {
					 *       // x: "name", // it's possible to specify 'x' when category axis
					 *       value: ["upload", "download"]
					 *     }
					 * }
					 */
																				data_json: undefined,

																				/**
					 * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
					 * @name data․rows
					 * @memberOf Options
					 * @type {Array}
					 * @default undefined
					 * @example
					 * data: {
					 *   rows: [
					 *     ["A", "B", "C"],
					 *     [90, 120, 300],
					 *     [40, 160, 240],
					 *     [50, 200, 290],
					 *     [120, 160, 230],
					 *     [80, 130, 300],
					 *     [90, 220, 320]
					 *   ]
					 * }
					 *
					 * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
					 * // - an array of [high, mid, low] data following the order
					 * // - or an object with 'high', 'mid' and 'low' key value
					 * data: {
					 *   rows: [
					 *      ["data1", "data2"],
					 *      [
					 *        // or {high:150, mid: 140, low: 110}, 120
					 *        [150, 140, 110], 120
					 *      ],
					 *      [[155, 130, 115], 55],
					 *      [[160, 135, 120], 60]
					 *   ],
					 *   types: {
					 *       data1: "area-line-range",
					 *       data2: "line"
					 *   }
					 * }
					 */
																				data_rows: undefined,

																				/**
					 * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
					 * @name data․columns
					 * @memberOf Options
					 * @type {Array}
					 * @default undefined
					 * @example
					 * data: {
					 *   columns: [
					 *      ["data1", 30, 20, 50, 40, 60, 50],
					 *      ["data2", 200, 130, 90, 240, 130, 220],
					 *      ["data3", 300, 200, 160, 400, 250, 250]
					 *   ]
					 * }
					 *
					 * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
					 * // - an array of [high, mid, low] data following the order
					 * // - or an object with 'high', 'mid' and 'low' key value
					 * data: {
					 *   columns: [
					 *      ["data1",
					 *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
					 *          [150, 140, 110],
					 *          [150, 140, 110]
					 *      ]
					 *   ],
					 *   type: "area-line-range"
					 * }
					 */
																				data_columns: undefined,

																				/**
					 * Used if loading JSON via data.url.
					 * @name data․mimeType
					 * @memberOf Options
					 * @type {String}
					 * @default undefined
					 * @example
					 * data: {
					 *     mimeType: "json"
					 * }
					 */
																				data_mimeType: undefined,

																				/**
					 * Choose which JSON object keys correspond to desired data.
					 * @name data․keys
					 * @memberOf Options
					 * @type {String}
					 * @default undefined
					 * @example
					 * data: {
					 *     json: [
					 *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
					 *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
					 *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
					 *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
					 *     ],
					 *     keys: {
					 *       // x: "name", // it's possible to specify 'x' when category axis
					 *       value: ["upload", "download"]
					 *     }
					 * }
					 */
																				data_keys: undefined,

																				/**
					 * Set text displayed when empty data.
					 * @name data․empty․label․text
					 * @memberOf Options
					 * @type {String}
					 * @default ""
					 * @example
					 * data: {
					 *   empty: {
					 *     label: {
					 *       text: "No Data"
					 *     }
					 *   }
					 * }
					 */
																				data_empty_label_text: "",

																				/**
					 * Set subchart options
					 * @name subchart
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
					 * @property {Boolean} [subchart.size.height] Change the height of the subchart.
					 * @property {Boolean} [subchart.onbrush] Set callback for brush event.<br>
					 *  Specified function receives the current zoomed x domain.
					 * @example
					 *  subchart: {
					 *      show: true,
					 *      size: {
					 *          height: 20
					 *      },
					 *      onbrush: function(domain) { ... }
					 *  }
					 */
																				subchart_show: !1,
																				subchart_size_height: 60,
																				subchart_axis_x_show: !0,
																				subchart_onbrush: function subchart_onbrush() {},

																				/**
					 * Set color of the data values
					 * @name color
					 * @memberOf Options
					 * @type {Object}
					 * @property {Array} [color.pattern] custom color pattern
					 * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
					 *  - **Note:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
					 *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
					 *    - `bb-colorize-pattern-red`
					 *    - `bb-colorize-pattern-fff`
					 * @property {Object} [color.threshold] color threshold
					 * @property {String} [color.threshold.unit] unit
					 * @property {Array} [color.threshold.value] value
					 * @property {Array} [color.threshold.max=100] max value
					 * @example
					 *  color: {
					 *      pattern: ["#1f77b4", "#aec7e8", ...],
					 *
					 *      // Set colors' patterns
					 *      // it should return an array of SVGPatternElement
					 *      tiles: function() {
					 *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
					 *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
					 *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
					 *
					 *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
					 *         pattern.setAttribute("width", "32");
					 *         pattern.setAttribute("height", "32");
					 *
					 *         g.style.fill = "#000";
					 *         g.style.opacity = "0.2";
							  *
					 *         circle1.setAttribute("cx", "3");
					 *         circle1.setAttribute("cy", "3");
					 *         circle1.setAttribute("r", "3");
							  *
					 *         g.appendChild(circle1);
					 *         pattern.appendChild(g);
					 *
					 *         return [pattern];
					 *      }
					 *  }
					 */
																				color_pattern: [],
																				color_tiles: undefined,
																				color_threshold: {},

																				/**
					 * Legend options
					 * @name legend
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [legend.show=true] Show or hide legend.
					 * @property {Boolean} [legend.hide=false] Hide legend
					 *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
					 * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
					 * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
					 *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
					 *    - {=COLOR}: data color value
					 *    - {=TITLE}: data title value
					 *  - If set `function` value, will pass following arguments to the given function:
					 *   - title {String}: data's id value
					 *   - color {String}: color string
					 *   - data {Array}: data array
					 * @property {String} [legend.position=bottom] Change the position of legend.<br>
					 *  Available values are: `bottom`, `right` and `inset` are supported.
					 * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
					 *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
					 *  - **anchor** decides the position of the legend:
					 *   - top-left
					 *   - top-right
					 *   - bottom-left
					 *   - bottom-right
					 *  - **x** and **y**:
					 *   - set the position of the legend based on the anchor.
					 *  - **step**:
					 *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
					 * @property {Boolean} [legend.equally=false] Set to all items have same width size.
					 * @property {Boolean} [legend.padding=0] Set padding value
					 * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
					 * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
					 * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
					 * @property {Number} [legend.item.tile.width=10] Set width of item tile element
					 * @property {Number} [legend.item.tile.height=10] Set height of item tile element
					 * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
					 * @example
					 *  legend: {
					 *      show: true,
					 *      hide: true,
					 *      //or hide: "data1"
							  *      //or hide: ["data1", "data2"]
					 *      contents: {
					 *          bindto: "#legend",   // <ul id='legend'></ul>
					 *
					 *          // will be as: <li style='background-color:#1f77b4'>data1</li>
					 *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
					 *
					 *          // or using function
					 *          template: function(id, color, data) {
					 *               // if you want omit some legend, return falsy value
					 *               if (title !== "data1") {
					 *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
					 *               }
					 *          }
					 *      },
							  *      position: "bottom",  // bottom, right, inset
					 *      inset: {
					 *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
					 *          x: 20,
					 *          y: 10,
					 *          step: 2
					 *      },
							  *      equally: false,
							  *      padding: 10,
							  *      item: {
					 *          onclick: function(id) { ... },
					 *          onover: function(id) { ... },
					 *          onout: function(id) { ... },
					 *
					 *          // set tile's size
					 *          tile: {
					 *              width: 20,
					 *              height: 15
					 *          }
					 *      },
					 *      usePoint: true
					 *  }
					 */
																				legend_show: !0,
																				legend_hide: !1,
																				legend_contents_bindto: undefined,
																				legend_contents_template: undefined,
																				legend_position: "bottom",
																				legend_inset_anchor: "top-left",
																				legend_inset_x: 10,
																				legend_inset_y: 0,
																				legend_inset_step: undefined,
																				legend_item_onclick: undefined,
																				legend_item_onover: undefined,
																				legend_item_onout: undefined,
																				legend_equally: !1,
																				legend_padding: 0,
																				legend_item_tile_width: 10,
																				legend_item_tile_height: 10,
																				legend_usePoint: !1,

																				/**
					 * Switch x and y axis position.
					 * @name axis․rotated
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   rotated: true
					 * }
					 */
																				axis_rotated: !1,

																				/**
					 * Show or hide x axis.
					 * @name axis․x․show
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   x: {
					 *     show: false
					 *   }
					 * }
					 */
																				axis_x_show: !0,

																				/**
					 * Set type of x axis.<br><br>
					 * **Available Values:**
					 * - timeseries
					 * - category
					 * - indexed
					 * @name axis․x․type
					 * @memberOf Options
					 * @type {String}
					 * @default indexed
					 * @example
					 * axis: {
					 *   x: {
					 *     type: "timeseries"
					 *   }
					 * }
					 */
																				axis_x_type: "indexed",

																				/**
					 * Set how to treat the timezone of x values.<br>
					 * If true, treat x value as localtime. If false, convert to UTC internally.
					 * @name axis․x․localtime
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   x: {
					 *     localtime: false
					 *   }
					 * }
					 */
																				axis_x_localtime: !0,

																				/**
					 * Set category names on category axis.
					 * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
					 * @name axis․x․categories
					 * @memberOf Options
					 * @type {Array}
					 * @default []
					 * @example
					 * axis: {
					 *   x: {
					 *     categories: ["Category 1", "Category 2", ...]
					 *   }
					 * }
					 */
																				axis_x_categories: [],

																				/**
					 * Centerise ticks on category axis.
					 * @name axis․x․tick․centered
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       centered: true
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_centered: !1,

																				/**
					 * A function to format tick value. Format string is also available for timeseries data.
					 * @name axis․x․tick․format
					 * @memberOf Options
					 * @type {Function}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *        // for timeseries, a 'datetime' object is given as parameter
					 *       format: function(x) {
					 *           return x.getFullYear();
					 *       }
					 *
					 *       // for category, index(Number) and categoryName(String) are given as parameter
					 *       format: function(index, categoryName) {
					 *           return categoryName.substr(0, 10);
					 *       }
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_format: undefined,

																				/**
					 * Setting for culling ticks.<br><br>
					 * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
					 * We can change the number of ticks to be shown by axis.x.tick.culling.max.
					 * @name axis․x․tick․culling
					 * @memberOf Options
					 * @type {Boolean}
					 * @default
					 * - true for indexed axis and timeseries axis
					 * - false for category axis
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       culling: false
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_culling: {},

																				/**
					 * The number of tick texts will be adjusted to less than this value.
					 * @name axis․x․tick․culling․max
					 * @memberOf Options
					 * @type {Number}
					 * @default 10
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       culling: {
					 *           max: 5
					 *       }
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_culling_max: 10,

																				/**
					 * The number of x axis ticks to show.<br><br>
					 * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
					 * @name axis․x․tick․count
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       count: 5
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_count: undefined,

																				/**
					 * Fit x axis ticks.<br><br>
					 * If true set, the ticks will be positioned nicely. If false set, the ticks will be positioned according to x value of the data points.
					 * @name axis․x․tick․fit
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       fit: false
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_fit: !0,

																				/**
					 * Set the x values of ticks manually.<br><br>
					 * If this option is provided, the position of the ticks will be determined based on those values. This option works with timeseries data and the x values will be parsed accoding to the type of the value and data.xFormat option.
					 * @name axis․x․tick․values
					 * @memberOf Options
					 * @type {Array}
					 * @default null
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       values: [1, 2, 4, 8, 16, 32, ...]
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_values: null,

																				/**
					 * Rotate x axis tick text.<br>
					 * If you set negative value, it will rotate to opposite direction.
					 * @name axis․x․tick․rotate
					 * @memberOf Options
					 * @type {Number}
					 * @default 0
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       rotate: 60
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_rotate: 0,

																				/**
					 * Show x axis outer tick.
					 * @name axis․x․tick․outer
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       outer: false
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_outer: !0,

																				/**
					 * Set tick text to be multiline
					 * @name axis․x․tick․multiline
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       multiline: false
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_multiline: !0,

																				/**
					 * Set tick width
					 * @name axis․x․tick․width
					 * @memberOf Options
					 * @type {Number}
					 * @default null
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       width: 50
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_width: null,

																				/**
					 * Set to display system tooltip for tick text
					 * - **Note:** Only available for category axis type (`axis.x.type='category'`)
					 * @name axis․x․tick․tooltip
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   x: {
					 *     tick: {
					 *       tooltip: true
					 *     }
					 *   }
					 * }
					 */
																				axis_x_tick_tooltip: !1,

																				/**
					 * Set max value of x axis range.
					 * @name axis․x․max
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     max: 100
					 *   }
					 * }
					 */
																				axis_x_max: undefined,

																				/**
					 * Set min value of x axis range.
					 * @name axis․x․min
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     min: -100
					 *   }
					 * }
					 */
																				axis_x_min: undefined,

																				/**
					 * Set padding for x axis.<br><br>
					 * If this option is set, the range of x axis will increase/decrease according to the values.
					 * If no padding is needed in the rage of x axis, 0 should be set.
					 * - **NOTE:**
					 *   The padding values aren't based on pixels. It differs according axis types<br>
					 *   - **category:** The unit of tick value
					 *     ex. the given value `1`, is same as the width of 1 tick width
					 *   - **timeseries:** Numeric time value
					 *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
					 * @name axis․x․padding
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * axis: {
					 *   x: {
					 *     padding: {
					 *       // when axis type is 'category'
					 *       left: 1,  // set left padding width of equivalent value of a tick's width
					 *       right: 0.5  // set right padding width as half of equivalent value of tick's width
					 *
					 *       // when axis type is 'timeseries'
					 *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
					 *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
					 *     }
					 *   }
					 * }
					 */
																				axis_x_padding: {},

																				/**
					 * Set height of x axis.<br><br>
					 * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
					 * @name axis․x․height
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     height: 20
					 *   }
					 * }
					 */
																				axis_x_height: undefined,

																				/**
					 * Set default extent for subchart and zoom. This can be an array or function that returns an array.
					 * @name axis․x․extent
					 * @memberOf Options
					 * @type {Array}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
					 *     // https://github.com/d3/d3-brush/blob/master/src/brush.js#L521
					 *     extent: [
					 *         [0, 0], [200, 60]
					 *     ]
					 *   }
					 * }
					 */
																				axis_x_extent: undefined,

																				/**
					 * Set label on x axis.<br><br>
					 *  You can set x axis label and change its position by this option. string and object can be passed and we can change the poisiton by passing object that has position key. Available position differs according to the axis direction (vertical or horizontal). If string set, the position will be the default.
					 *  - **If it's horizontal axis:**
					 *    - inner-right [default]
					 *    - inner-center
					 *    - inner-left
					 *    - outer-right
					 *    - outer-center
					 *    - outer-left
					 *  - **If it's vertical axis:**
					 *    - inner-top [default]
					 *    - inner-middle
					 *    - inner-bottom
					 *    - outer-top
					 *    - outer-middle
					 *    - outer-bottom
					 * @name axis․x․label
					 * @memberOf Options
					 * @type {String|Object}
					 * @default undefined
					 * @example
					 * axis: {
					 *   x: {
					 *     label: "Your X Axis"
					 *   }
					 * }
					 *
					 * axis: {
					 *   x: {
					 *     label: {
					 *        text: "Your X Axis",
					 *        position: "outer-center"
					 *     }
					 *   }
					 * }
					 */
																				axis_x_label: {},

																				/**
					 * Show or hide y axis.
					 * @name axis․y․show
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   y: {
					 *     show: false
					 *   }
					 * }
					 */
																				axis_y_show: !0,

																				/**
					 * Set type of y axis.<br><br>
					 * **Available Values:**
					 *   - timeseries
					 *   - category
					 *   - indexed
					 * @name axis․y․type
					 * @memberOf Options
					 * @type {String}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     type: "timeseries"
					 *   }
					 * }
					 */
																				axis_y_type: undefined,

																				/**
					 * Set max value of y axis.
					 * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
					 * @name axis․y․max
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     max: 1000
					 *   }
					 * }
					 */
																				axis_y_max: undefined,

																				/**
					 * Set min value of y axis.
					 * - **NOTE:**
					 *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
					 * @name axis․y․min
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     min: 1000
					 *   }
					 * }
					 */
																				axis_y_min: undefined,

																				/**
					 * Change the direction of y axis.<br><br>
					 * If true set, the direction will be from the top to the bottom.
					 * @name axis․y․inverted
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   y: {
					 *     inverted: true
					 *   }
					 * }
					 */
																				axis_y_inverted: !1,

																				/**
					 * Set center value of y axis.
					 * @name axis․y․center
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     center: 0
					 *   }
					 * }
					 */
																				axis_y_center: undefined,

																				/**
					 * Show y axis inside of the chart.
					 * @name axis․y․inner
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   y: {
					 *     inner: true
					 *   }
					 * }
					 */
																				axis_y_inner: !1,

																				/**
					 * Set label on y axis.<br><br>
					 * You can set y axis label and change its position by this option. This option works in the same way as axis.x.label.
					 * @name axis․y․label
					 * @memberOf Options
					 * @type {String|Object}
					 * @default {}
					 * @example
					 * axis: {
					 *   y: {
					 *     label: "Your Y Axis"
					 *   }
					 * }
					 *
					 * axis: {
					 *   y: {
					 *     label: {
					 *        text: "Your Y Axis",
					 *        position: "outer-middle"
					 *     }
					 *   }
					 * }
					 */
																				axis_y_label: {},

																				/**
					 * Set formatter for y axis tick text.<br><br>
					 * This option accepts d3.format object as well as a function you define.
					 * @name axis․y․tick․format
					 * @memberOf Options
					 * @type {Function}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     tick: {
					 *       format: function(x) {
					 *           return x.getFullYear();
					 *       }
					 *     }
					 *   }
					 * }
					 */
																				axis_y_tick_format: undefined,

																				/**
					 * Show y axis outer tick.
					 * @name axis․y․tick․outer
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   y: {
					 *     tick: {
					 *       outer: false
					 *     }
					 *   }
					 * }
					 */
																				axis_y_tick_outer: !0,

																				/**
					 * Set y axis tick values manually.
					 * @name axis․y․tick․values
					 * @memberOf Options
					 * @type {Array}
					 * @default null
					 * @example
					 * axis: {
					 *   y: {
					 *     tick: {
					 *       values: [100, 1000, 10000]
					 *     }
					 *   }
					 * }
					 */
																				axis_y_tick_values: null,
																				axis_y_tick_rotate: 0,

																				/**
					 * Set the number of y axis ticks.<br><br>
					 * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
					 * @name axis․y․tick․count
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     tick: {
					 *       count: 5
					 *     }
					 *   }
					 * }
					 */
																				axis_y_tick_count: undefined,

																				/**
					 * Set the number of y axis ticks.<br><br>
					 * **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
					 * @name axis․y․tick․time
					 * @memberOf Options
					 * @private
					 * @type {Object}
					 * @property {Function} [time.value] D3's time interval function(https://github.com/d3/d3-time#intervals)
					 * @example
					 * axis: {
					 *   y: {
					 *     tick: {
					 *       time: {
					 *          // ticks at 15-minute intervals
					 *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
					 *          value: d3.timeMinute.every(15)
					 *       }
					 *     }
					 *   }
					 * }
					 */
																				// @TODO: not fully implemented yet
																				axis_y_tick_time_value: undefined,

																				/**
					 * Set padding for y axis.<br><br>
					 * You can set padding for y axis to create more space on the edge of the axis.
					 * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
					 *
					 * **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
					 * @name axis․y․padding
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * axis: {
					 *   y: {
					 *     padding: {
					 *       top: 0,
					 *       bottom: 0
					 *     }
					 *   }
					 * }
					 */
																				axis_y_padding: {},

																				/**
					 * Set default range of y axis.<br><br>
					 * This option set the default value for y axis when there is no data on init.
					 * @name axis․y․default
					 * @memberOf Options
					 * @type {Array}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y: {
					 *     default: [0, 1000]
					 *   }
					 * }
					 */
																				axis_y_default: undefined,

																				/**
					 * Show or hide y2 axis.
					 * @name axis․y2․show
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   y2: {
					 *     show: true
					 *   }
					 * }
					 */
																				axis_y2_show: !1,

																				/**
					 * Set max value of y2 axis.
					 * @name axis․y2․max
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y2: {
					 *     max: 1000
					 *   }
					 * }
					 */
																				axis_y2_max: undefined,

																				/**
					 * Set min value of y2 axis.
					 * @name axis․y2․min
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y2: {
					 *     min: -1000
					 *   }
					 * }
					 */
																				axis_y2_min: undefined,

																				/**
					 * Change the direction of y2 axis.<br><br>
					 * If true set, the direction will be from the top to the bottom.
					 * @name axis․y2․inverted
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   y2: {
					 *     inverted: true
					 *   }
					 * }
					 */
																				axis_y2_inverted: !1,

																				/**
					 * Set center value of y2 axis.
					 * @name axis․y2․center
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y2: {
					 *     center: 0
					 *   }
					 * }
					 */
																				axis_y2_center: undefined,

																				/**
					 * Show y2 axis inside of the chart.
					 * @name axis․y2․inner
					 * @memberOf Options
					 * @type {Boolean}
					 * @default false
					 * @example
					 * axis: {
					 *   y2: {
					 *     inner: true
					 *   }
					 * }
					 */
																				axis_y2_inner: !1,

																				/**
					 * Set label on y2 axis.<br><br>
					 * You can set y2 axis label and change its position by this option. This option works in the same way as axis.x.label.
					 * @name axis․y2․label
					 * @memberOf Options
					 * @type {String|Object}
					 * @default {}
					 * @example
					 * axis: {
					 *   y2: {
					 *     label: "Your Y2 Axis"
					 *   }
					 * }
					 *
					 * axis: {
					 *   y2: {
					 *     label: {
					 *        text: "Your Y2 Axis",
					 *        position: "outer-middle"
					 *     }
					 *   }
					 * }
					 */
																				axis_y2_label: {},

																				/**
					 * Set formatter for y2 axis tick text.<br><br>
					 * This option works in the same way as axis.y.format.
					 * @name axis․y2․tick․format
					 * @memberOf Options
					 * @type {Function}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y2: {
					 *     tick: {
					 *       format: d3.format("$,")
					 *       //or format: function(d) { return "$" + d; }
					 *     }
					 *   }
					 * }
					 */
																				axis_y2_tick_format: undefined,

																				/**
					 * Show or hide y2 axis outer tick.
					 * @name axis․y2․tick․outer
					 * @memberOf Options
					 * @type {Boolean}
					 * @default true
					 * @example
					 * axis: {
					 *   y2: {
					 *     tick: {
					 *       outer: false
					 *     }
					 *   }
					 * }
					 */
																				axis_y2_tick_outer: !0,

																				/**
					 * Set y2 axis tick values manually.
					 * @name axis․y2․tick․values
					 * @memberOf Options
					 * @type {Array}
					 * @default null
					 * @example
					 * axis: {
					 *   y2: {
					 *     tick: {
					 *       values: [100, 1000, 10000]
					 *     }
					 *   }
					 * }
					 */
																				axis_y2_tick_values: null,

																				/**
					 * Set the number of y2 axis ticks.
					 * - **NOTE:** This works in the same way as axis.y.tick.count.
					 * @name axis․y2․tick․count
					 * @memberOf Options
					 * @type {Number}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y2: {
					 *     tick: {
					 *       count: 5
					 *     }
					 *   }
					 * }
					 */
																				axis_y2_tick_count: undefined,

																				/**
					 * Set the number of y2 axis ticks.
					 * - **NOTE:** This works in the same way as axis.y.tick.count.
					 * @name axis․y2․padding
					 * @memberOf Options
					 * @type {Object}
					 * @default {}
					 * @example
					 * axis: {
					 *   y2: {
					 *     padding: {
					 *       top: 100,
					 *       bottom: 100
					 *     }
					 *   }
					 * }
					 */
																				axis_y2_padding: {},

																				/**
					 * Set default range of y2 axis.<br><br>
					 * This option set the default value for y2 axis when there is no data on init.
					 * @name axis․y2․default
					 * @memberOf Options
					 * @type {Array}
					 * @default undefined
					 * @example
					 * axis: {
					 *   y2: {
					 *     default: [0, 1000]
					 *   }
					 * }
					 */
																				axis_y2_default: undefined,

																				/**
					 * Set related options
					 * @name grid
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [x.show=false] Show grids along x axis.
					 * @property {Boolean} [x.lines=[]] Show additional grid lines along x axis.<br>
					 *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
					 *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
					 * @property {Boolean} [y.show=false] Show grids along x axis.
					 * @property {Boolean} [y.lines=[]] Show additional grid lines along y axis.<br>
					 *  This option accepts array including object that has value, text, position and class.
					 * @property {Boolean} [y.ticks=10]
					 * @property {Boolean} [focus.show=true] Show grids when focus.
					 * @property {Boolean} [lines.front=true]
					 * @default undefined
					 * @example
					 * grid: {
					 *   x: {
					 *     show: true,
					 *     lines: [
					 *       {value: 2, text: "Label on 2"},
					 *       {value: 5, text: "Label on 5", class: "label-5"}
					 *       {value: 6, text: "Label on 6", position: "start"}
					 *     ]
					 *   },
					 *   y: {
					 *     show: true,
					 *     lines: [
					 *       {value: 100, text: "Label on 100"},
					 *       {value: 200, text: "Label on 200", class: "label-200"}
					 *       {value: 300, text: "Label on 300", position: 'middle'}
					 *     ],
					 *     ticks: 5
					 *   },
					 *   focus: {
					 *      show: false
					 *   },
					 *   lines: {
					 *      front: false
					 *   }
					 * }
					 */
																				grid_x_show: !1,
																				grid_x_type: "tick",
																				grid_x_lines: [],
																				grid_y_show: !1,
																				grid_y_lines: [],
																				grid_y_ticks: 10,
																				grid_focus_show: !0,
																				grid_lines_front: !0,

																				/**
					 * Set point options
					 * @name point
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [point.show=true] Whether to show each point in line.
					 * @property {Number|Function} [point.r=2.5] The radius size of each point.<br>
					 *  - **Note:** Disabled for 'bubble' type
					 * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
					 * @property {Boolean} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.<br>
					 *  - **Note:** For 'bubble' type, the default is `bubbleSize*1.15`
					 * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
					 * @property {String} [point.type="circle"] The type of point to be drawn<br>
					 * - **Note:**
					 *  - If chart has 'bubble' type, only circle can be used.
					 *  - For IE, non circle point expansions are not supported due to lack of transform support.
					 * - **Available Values:**
					 *  - circle
					 *  - rectangle
					 * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line<br>
					 * - **Note:**
					 *  - This is an `experimental` feature and can have some unexpected behaviors.
					 *  - If chart has 'bubble' type, only circle can be used.
					 *  - For IE, non circle point expansions are not supported due to lack of transform support.
					 * - **Available Values:**
					 *  - circle
					 *  - rectangle
					 *  - svg shape tag interpreted as string<br>
					 *    (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
					 * @example
					 *  point: {
					 *      show: false,
					 *      r: 5,
					 *
					 *      // or customize the radius
					 *      r: function(d) {
					 *          ...
					 *          return r;
					 *      },
					 *
					 *      focus: {
					 *          expand: {
					 *              enabled: true,
					 *              r: 1
					 *          }
					 *      },
					 *      select: {
					 *          r: 3
					 *      },
					 *
					 *      // valid values are "circle" or "rectangle"
					 *      type: "rectangle",
					 *
					 *      // or indicate as pattern
						 *      pattern: [
						 *        "circle",
						 *        "rectangle",
						 *        "<polygon points='0 6 4 0 -4 0'></polygon>"
						 *     ],
					 *  }
					 */
																				point_show: !0,
																				point_r: 2.5,
																				point_sensitivity: 10,
																				point_focus_expand_enabled: !0,
																				point_focus_expand_r: undefined,
																				point_pattern: [],
																				point_select_r: undefined,
																				point_type: "circle",

																				/**
					 * Set line options
					 * @name line
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
					 *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
					 * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
					 * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
					 * **Available values:**
					 * - step
					 * - step-before
					 * - step-after
					 * @example
					 *  line: {
					 *      connectNull: true,
					 *      classes: [
					 *          "line-class1",
					 *          "line-class2"
					 *      ],
					 *      step: {
					 *          type: "step-after"
					 *      }
					 *  }
					 */
																				line_connectNull: !1,
																				line_step_type: "step",
																				line_classes: undefined,

																				/**
					 * Set bar options
					 * @name bar
					 * @memberOf Options
					 * @type {Object}
					 * @property {Number} [bar.width] Change the width of bar chart.
					 * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
					 * @property {Number} [bar.width.max] The maximum width value for ratio.
					 * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
					 * @property {Boolean} [bar.padding=0] The padding pixel value between each bar.
					 * @example
					 *  bar: {
					 *      width: 10,
					 *      // or
					 *      width: {
					 *          ratio: 0.2,
					 *          max: 20
					 *      },
					 *      zerobased: false,
					 *      padding: 1
					 *  }
					 */
																				bar_width: undefined,
																				bar_width_ratio: .6,
																				bar_width_max: undefined,
																				bar_zerobased: !0,
																				bar_padding: 0,

																				/**
					 * Set bubble options
					 * @name bubble
					 * @memberOf Options
					 * @type {Object}
					 * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
					 * @example
					 *  bubble: {
					 *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
					 *      // And the lesser will have radius relatively from tha max value.
					 *      maxR: 50,
					 *
					 *      // or set radius callback
					 *      maxR: function(d) {
					 *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
					 *          ...
					 *          return Math.sqrt(d.value * 2);
					 *      }
					 *  }
					 */
																				bubble_maxR: 35,

																				/**
					 * Set area options
					 * @name area
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
					 * @property {Boolean} [area.above=false]
					 * @example
					 *  area: {
					 *      zerobased: false,
					 *      above: true
					 *  }
					 */
																				area_zerobased: !0,
																				area_above: !1,

																				/**
					 * Set pie options
					 * @name pie
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
					 * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
					 * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
					 * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
					 * @property {Boolean} [pie.expand=true] Enable or disable expanding pie pieces.
					 * @property {Number} [pie.innerRadius=0] Sets the inner radius of pie arc.
					 * @property {Number} [pie.padAngle=0] Set padding between data.
					 * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
					 * @example
					 *  pie: {
					 *      label: {
					 *          show: false,
					 *          format: function(value, ratio, id) {
					 *              return d3.format("$")(value);
					 *          },
					 *          threshold: 0.1,
					 *
					 *          // set ratio callback. Should return ratio value
					 *          ratio: function(d, radius, h) {
					 *              ...
					 *              return ratio;
					 *          },
					 *          // or set ratio number
					 *          ratio: 0.5
					 *      },
					 *      expand: false,
					 *      innerRadius: 0,
					 *      padAngle: 0.1,
					 *      padding: 0
					 *  }
					 */
																				pie_label_show: !0,
																				pie_label_format: undefined,
																				pie_label_threshold: .05,
																				pie_label_ratio: undefined,
																				pie_expand: {},
																				pie_expand_duration: 50,
																				pie_innerRadius: 0,
																				pie_padAngle: 0,
																				pie_padding: 0,

																				/**
					 * Set gauge options
					 * @name gauge
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
					 * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
					 * @property {Function} [gauge.label.format] Set formatter for the label on gauge.
					 * @property {Function} [gauge.label.extents] Set customized min/max label text.
					 * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
					 * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
					 * @property {Number} [gauge.min=0] Set min value of the gauge.
					 * @property {Number} [gauge.max=100] Set max value of the gauge.
					 * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2]
					 * @property {String} [gauge.units] Set units of the gauge.
					 * @property {Number} [gauge.width] Set width of gauge chart.
					 * @example
					 *  gauge: {
					 *      fullCircle: false,
					 *      label: {
					 *          show: false,
					 *          format: function(value, ratio) {
					 *              return value;
					 *          },
					 *          extents: function(value, isMax) {
						 *              return (isMax ? "Max:" : "Min:") + value;
					 *          }
					 *      },
					 *      expand: false,
					 *
					 *      // or set duration
					 *      expand: {
					 *          duration: 20
					 *      },
					 *      min: -100,
					 *      max: 200,
					 *      units: "%",
					 *      width: 10
					 *  }
					 */
																				gauge_fullCircle: !1,
																				gauge_label_show: !0,
																				gauge_label_format: undefined,
																				gauge_min: 0,
																				gauge_max: 100,
																				gauge_startingAngle: -1 * Math.PI / 2,
																				gauge_label_extents: undefined,
																				gauge_units: undefined,
																				gauge_width: undefined,
																				gauge_expand: {},
																				gauge_expand_duration: 50,

																				/**
					 * Set donut options
					 * @name donut
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
					 * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
					 * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
					 * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
					 * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
					 * @property {Number} [donut.width] Set width of donut chart.
					 * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
					 * @property {Number} [donut.padAngle=0] Set padding between data.
					 * @example
					 *  donut: {
					 *      label: {
					 *          show: false,
					 *          format: function(value, ratio, id) {
					 *              return d3.format("$")(value);
					 *          },
					 *          threshold: 0.1,
					 *
					 *          // set ratio callback. Should return ratio value
					 *          ratio: function(d, radius, h) {
					 *          	...
					 *          	return ratio;
					 *          },
					 *          // or set ratio number
					 *          ratio: 0.5
					 *      },
					 *      expand: false,
					 *      width: 10,
					 *      padAngle: 0.2,
					 *      title: "Donut Title"
					 *
					 *      // title with line break
					 *      title: "Title1\nTitle2"
					 *  }
					 */
																				donut_label_show: !0,
																				donut_label_format: undefined,
																				donut_label_threshold: .05,
																				donut_label_ratio: undefined,
																				donut_width: undefined,
																				donut_title: "",
																				donut_expand: {},
																				donut_expand_duration: 50,
																				donut_padAngle: 0,

																				/**
					 * Set spline options
					 * @name spline
					 * @memberOf Options
					 * @type {Object}
					 * @property {String} [spline.interpolation.type=cardinal]
					 * @example
					 *  spline: {
					 *      interpolation: {
					 *          type: "cardinal"
					 *      }
					 *  }
					 */
																				spline_interpolation_type: "cardinal",

																				/**
					 * Show rectangles inside the chart.<br><br>
					 * This option accepts array including object that has axis, start, end and class. The keys start, end and class are optional.
					 * axis must be x, y or y2. start and end should be the value where regions start and end. If not specified, the edge values will be used. If timeseries x axis, date string, Date object and unixtime integer can be used. If class is set, the region element will have it as class.
					 * @name regions
					 * @memberOf Options
					 * @type {Array}
					 * @default []
					 * @example
					 *  regions: [
					 *    {
					 *      axis: "x",
					 *      start: 1,
					 *      end: 4,
					 *      class: "region-1-4"
					 *    }
					 *  ]
					 */
																				regions: [],

																				/**
					 * Tooltip options
					 * @name tooltip
					 * @memberOf Options
					 * @type {Object}
					 * @property {Boolean} [tooltip.show=true] Show or hide tooltip.<br>
					 * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
					 * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.<br>
					 * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
					 *  Specified function receives x of the data point to show.
					 * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
					 *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
					 * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
					 *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
					 *  If undefined returned, the row of that value will be skipped.
					 * @property {Function} [tooltip.position] Set custom position for the tooltip.<br>
					 *  This option can be used to modify the tooltip position by returning object that has top and left.
					 * @property {Function} [tooltip.contents] Set custom HTML for the tooltip.<br>
					 *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
					 * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
					 * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
					 * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
					 * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
					 * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
					 * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
					 * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
					 * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
					 *  **Available Values:**
					 *  - `desc`: In descending data value order
					 *  - `asc`: In ascending data value order
					 *  - `null`: It keeps the data display order<br>
					 *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
					 *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
					 *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
					 * @example
					 *  tooltip: {
					 *      show: true,
					 *      grouped: false,
					 *      format: {
					 *          title: function(x) { return "Data " + x; },
					 *          name: function(name, ratio, id, index) { return name; },
					 *          value: function(value, ratio, id, index) { return ratio; }
					 *      },
					 *      position: function(data, width, height, element) {
					 *          return {top: 0, left: 0}
							 *      },
							 *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
							 *          return ... // formatted html as you want
					 		 *      },
					 		 *
					 		 *      // sort tooltip data value display in ascending order
					 		 *      order: "asc",
					 		 *
					 *      // specifying sort function
					 *      order: function(a, b) {
					 *         // param data passed format
					 *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
					 *           ...
					 *      },
					 *
					 *      // show at the initialization
					 *      init: {
					 *          show: true,
					 *          x: 2,
					 *          position: {
					 *              top: "150px",
					 *              left: "250px"
					 *          }
					 *      },
					 *
					 *      // fires prior tooltip is shown
					 *      onshow: function() { ...},
					 *      // fires prior tooltip is hidden
					 *      onhide: function() { ... },
					 *      // fires after tooltip is shown
					 *      onshown: function() { ... },
					 *      // fires after tooltip is hidden
					 *      onhidden: function() { ... },
					 *
					 *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
					 *      // Useful for timeseries correlation
					 *      linked: true
					 *  }
					 */
																				tooltip_show: !0,
																				tooltip_grouped: !0,
																				tooltip_format_title: undefined,
																				tooltip_format_name: undefined,
																				tooltip_format_value: undefined,
																				tooltip_position: undefined,
																				tooltip_contents: function tooltip_contents(d, defaultTitleFormat, defaultValueFormat, color) {
																														return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : "";
																				},
																				tooltip_init_show: !1,
																				tooltip_init_x: 0,
																				tooltip_init_position: {
																														top: "0px",
																														left: "50px"
																				},
																				tooltip_linked: !1,
																				tooltip_onshow: function tooltip_onshow() {},
																				tooltip_onhide: function tooltip_onhide() {},
																				tooltip_onshown: function tooltip_onshown() {},
																				tooltip_onhidden: function tooltip_onhidden() {},
																				tooltip_order: null,

																				/**
					 * Set title options
					 * @name title
					 * @memberOf Options
					 * @type {Object}
					 * @property {String} [title.text]
					 * @property {Number} [title.padding.top=0]
					 * @property {Number} [title.padding.right=0]
					 * @property {Number} [title.padding.bottom=0]
					 * @property {Number} [title.padding.left=0]
					 * @property {String} [title.position=top-center]
					 * @example
					 *  title: {
					 *      text: "Title Text",
					 *      padding: {
					 *          top: 10,
					 *          right: 10,
					 *          bottom: 10,
					 *          left: 10
					 *      },
					 *      position: "top-center"
					 *  }
					 */
																				title_text: undefined,
																				title_padding: {
																														top: 0,
																														right: 0,
																														bottom: 0,
																														left: 0
																				},
																				title_position: "top-center"
										};
};

exports.default = Options;
module.exports = exports["default"];

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Scale = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	getScale: function getScale(min, max, forTimeseries) {
		return (forTimeseries ? (0, _d3Scale.scaleTime)() : (0, _d3Scale.scaleLinear)()).range([min, max]);
	},
	getX: function getX(min, max, domain, offsetValue) {
		var $$ = this,
			scale = $$.getScale(min, max, $$.isTimeSeries()),
			_scale = domain ? scale.domain(domain) : scale,
			key = void 0,
			offset = void 0;

		// Define customized scale if categorized axis

		// define functions
		for (key in $$.isCategorized() ? (offset = offsetValue || function() {
			return 0;
		}, scale = function(d, raw) {
			var v = _scale(d) + offset(d);

			return raw ? v : Math.ceil(v);
		}) : scale = function(d, raw) {
			var v = _scale(d);

			return raw ? v : Math.ceil(v);
		}, _scale) scale[key] = _scale[key];

		return scale.orgDomain = function() {
			return _scale.domain();
		}, $$.isCategorized() && (scale.domain = function(domainValue) {
			var domain = domainValue;

			return arguments.length ? (_scale.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
		}), scale;
	},
	getY: function getY(min, max, domain) {
		var scale = this.getScale(min, max, this.isTimeSeriesY());

		return domain && scale.domain(domain), scale;
	},
	getYScale: function getYScale(id) {
		return this.axis.getId(id) === "y2" ? this.y2 : this.y;
	},
	getSubYScale: function getSubYScale(id) {
		return this.axis.getId(id) === "y2" ? this.subY2 : this.subY;
	},

	/**
* Update scale
* @private
* @param {Boolean} withoutTransitionAtInit - param is given at the init rendering
*/
	updateScales: function updateScales(withoutTransitionAtInit) {
		var $$ = this,
			config = $$.config,
			forInit = !$$.x;

		// update edges
		$$.xMin = config.axis_rotated ? 1 : 0, $$.xMax = config.axis_rotated ? $$.height : $$.width, $$.yMin = config.axis_rotated ? 0 : $$.height, $$.yMax = config.axis_rotated ? $$.width : 1, $$.subXMin = $$.xMin, $$.subXMax = $$.xMax, $$.subYMin = config.axis_rotated ? 0 : $$.height2, $$.subYMax = config.axis_rotated ? $$.width2 : 1, $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function() {
			return $$.xAxis.tickOffset();
		}), $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain()), $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain()), $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function(d) {
			return d % 1 ? 0 : $$.subXAxis.tickOffset();
		}), $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain()), $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain()), $$.xAxisTickFormat = $$.axis.getXAxisTickFormat(), $$.xAxisTickValues = $$.axis.getXAxisTickValues(), $$.yAxisTickValues = $$.axis.getYAxisTickValues(), $$.y2AxisTickValues = $$.axis.getY2AxisTickValues(), $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer, withoutTransitionAtInit), $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer), $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer), $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer), $$.updateArc && $$.updateArc();
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Array = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// selection
(0, _util.extend)(_ChartInternal2.default.prototype, {
	getYDomainMinMax: function getYDomainMinMax(targets, type) {
		var $$ = this,
			config = $$.config,
			isMin = type === "min",
			dataGroups = config.data_groups,
			ids = $$.mapToIds(targets),
			ys = $$.getValuesAsIdKeyed(targets),
			f = isMin ? _d3Array.min : _d3Array.max;

		return dataGroups.length > 0 && function() {

			for (var hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), baseId = void 0, idsInGroup = void 0, j = 0; idsInGroup = dataGroups[j]; j++) if (idsInGroup = idsInGroup.filter(function (v) {
				return ids.indexOf(v) >= 0;
			}), idsInGroup.length !== 0) {

					// Consider values
					if (baseId = idsInGroup[0], hasValue && ys[baseId]) {
						var setter = isMin ? function(v, i) {
							ys[baseId][i] = v < 0 ? v : 0;
						} : function(v, i) {
							ys[baseId][i] = v > 0 ? v : 0;
						};

						ys[baseId].forEach(setter);
					}

					// Compute min
					for (var id, _ret2, _loop = function(k, id) {
						return ys[id] ? void ys[id].forEach(function (v, i) {
							var val = +v,
								meetCondition = isMin ? val > 0 : val < 0;
							$$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasValue && meetCondition) && (ys[baseId][i] += val);
						}) : "continue";
					}, k = 1; id = idsInGroup[k]; k++) _ret2 = _loop(k, id), _ret2 === "continue";
				}
		}(), f(Object.keys(ys).map(function (key) {
			return f(ys[key]);
		}));
	},
	getYDomainMin: function getYDomainMin(targets) {
		return this.getYDomainMinMax(targets, "min");
	},
	getYDomainMax: function getYDomainMax(targets) {
		return this.getYDomainMinMax(targets, "max");
	},
	getYDomain: function getYDomain(targets, axisId, xDomain) {
		var $$ = this,
			config = $$.config,
			targetsByAxisId = targets.filter(function (t) {
			return $$.axis.getId(t.id) === axisId;
		}),
			yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
			yMin = axisId === "y2" ? config.axis_y2_min : config.axis_y_min,
			yMax = axisId === "y2" ? config.axis_y2_max : config.axis_y_max,
			yDomainMin = $$.getYDomainMin(yTargets),
			yDomainMax = $$.getYDomainMax(yTargets),
			center = axisId === "y2" ? config.axis_y2_center : config.axis_y_center,
			isZeroBased = $$.hasType("bar", yTargets) && config.bar_zerobased || $$.hasType("area", yTargets) && config.area_zerobased,
			isInverted = axisId === "y2" ? config.axis_y2_inverted : config.axis_y_inverted,
			showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
			showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated,
			lengths = void 0;

		// MEMO: avoid inverting domain unexpectedly

		if (yDomainMin = (0, _util.isValue)(yMin) ? yMin : (0, _util.isValue)(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = (0, _util.isValue)(yMax) ? yMax : (0, _util.isValue)(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, yTargets.length === 0) // use current domain if target of axisId is none
			return axisId === "y2" ? $$.y2.domain() : $$.y.domain();

		isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);

		var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
			isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
		((0, _util.isValue)(yMin) && isAllPositive || (0, _util.isValue)(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));

		var domainLength = Math.abs(yDomainMax - yDomainMin),
			paddingTop = domainLength * .1,
			paddingBottom = domainLength * .1;

		if ((0, _util.isDefined)(center)) {
			var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));

			yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
		}

		// add padding for data label
		if (showHorizontalDataLabel) {
			lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "width");

			var diff = (0, _util.diffDomain)($$.y.range()),
				ratio = [lengths[0] / diff, lengths[1] / diff];
			paddingTop += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1])), paddingBottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
		} else showVerticalDataLabel && (lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height"), paddingTop += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength), paddingBottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength));

		axisId === "y" && (0, _util.notEmpty)(config.axis_y_padding) && (paddingTop = $$.axis.getPadding(config.axis_y_padding, "top", paddingTop, domainLength), paddingBottom = $$.axis.getPadding(config.axis_y_padding, "bottom", paddingBottom, domainLength)), axisId === "y2" && (0, _util.notEmpty)(config.axis_y2_padding) && (paddingTop = $$.axis.getPadding(config.axis_y2_padding, "top", paddingTop, domainLength), paddingBottom = $$.axis.getPadding(config.axis_y2_padding, "bottom", paddingBottom, domainLength)), isZeroBased && (isAllPositive && (paddingBottom = yDomainMin), isAllNegative && (paddingTop = -yDomainMax));

		var domain = [yDomainMin - paddingBottom, yDomainMax + paddingTop];

		return isInverted ? domain.reverse() : domain;
	},
	getXDomainMinMax: function getXDomainMinMax(targets, type) {
		var $$ = this,
			value = $$.config["axis_x_" + type],
			f = type === "min" ? _d3Array.min : _d3Array.max;

		return (0, _util.isDefined)(value) ? $$.isTimeSeries() ? $$.parseDate(value) : value : f(targets, function(t) {
			return f(t.values, function(v) {
				return v.x;
			});
		});
	},
	getXDomainMin: function getXDomainMin(targets) {
		return this.getXDomainMinMax(targets, "min");
	},
	getXDomainMax: function getXDomainMax(targets) {
		return this.getXDomainMinMax(targets, "max");
	},
	getXDomainPadding: function getXDomainPadding(domain) {
		var $$ = this,
			config = $$.config,
			diff = domain[1] - domain[0],
			xPadding = config.axis_x_padding,
			maxDataCount = void 0,
			padding = void 0,
			paddingLeft = void 0,
			paddingRight = void 0;

		return $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01, (0, _util.isObject)(xPadding) && (0, _util.notEmpty)(xPadding) ? (paddingLeft = (0, _util.isValue)(xPadding.left) ? xPadding.left : padding, paddingRight = (0, _util.isValue)(xPadding.right) ? xPadding.right : padding) : (0, _util.isNumber)(config.axis_x_padding) ? (paddingLeft = xPadding, paddingRight = xPadding) : (paddingLeft = padding, paddingRight = padding), {
			left: paddingLeft,
			right: paddingRight
		};
	},
	getXDomain: function getXDomain(targets) {
		var $$ = this,
			xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
			firstX = xDomain[0],
			lastX = xDomain[1],
			padding = $$.getXDomainPadding(xDomain),
			min = 0,
			max = 0;
		// show center of x domain if min and max are the same

		return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
	},
	updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
		var $$ = this,
			config = $$.config,
			zoomEnabled = config.zoom_enabled;

		if (withUpdateOrgXDomain && ($$.x.domain(domain || (0, _d3Array.extent)($$.getXDomain(targets))), $$.orgXDomain = $$.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), $$.subX.domain($$.x.domain()), $$.brush && $$.brush.scale($$.subX)), withUpdateXDomain) {
			var domainValue = domain || !$$.brush || $$.brushEmpty() ? $$.orgXDomain : $$.getBrushSelection().map(function (v) {
				return $$.subX.invert(v);
			});

			$$.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
		}

		// Trim domain when too big by zoom mousemove event

		return withTrim && $$.x.domain($$.trimXDomain($$.x.orgDomain())), $$.x.domain();
	},
	trimXDomain: function trimXDomain(domain) {
		var zoomDomain = this.getZoomDomain(),
			min = zoomDomain[0],
			max = zoomDomain[1];

		return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Array = __webpack_require__(4),
	_d3Collection = __webpack_require__(4),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	isX: function isX(key) {
		var $$ = this,
			config = $$.config,
			dataKey = config.data_x && key === config.data_x,
			existValue = (0, _util.notEmpty)(config.data_xs) && (0, _util.hasValue)(config.data_xs, key);

		return dataKey || existValue;
	},
	isNotX: function isNotX(key) {
		return !this.isX(key);
	},
	getXKey: function getXKey(id) {
		var $$ = this,
			config = $$.config;

		return config.data_x ? config.data_x : (0, _util.notEmpty)(config.data_xs) ? config.data_xs[id] : null;
	},
	getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
		var $$ = this,
			ids = targets && (0, _util.notEmpty)(targets) ? $$.mapToIds(targets) : [],
			xValues = void 0;

		return ids.forEach(function (id) {
			$$.getXKey(id) === key && (xValues = $$.data.xs[id]);
		}), xValues;
	},
	getIndexByX: function getIndexByX(x) {
		var $$ = this,
			data = $$.filterByX($$.data.targets, x);

		return data.length ? data[0].index : null;
	},
	getXValue: function getXValue(id, i) {
		var $$ = this;

		return id in $$.data.xs && $$.data.xs[id] && (0, _util.isValue)($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
	},
	getOtherTargetXs: function getOtherTargetXs() {
		var $$ = this,
			idsForX = Object.keys($$.data.xs);

		return idsForX.length ? $$.data.xs[idsForX[0]] : null;
	},
	getOtherTargetX: function getOtherTargetX(index) {
		var xs = this.getOtherTargetXs();

		return xs && index < xs.length ? xs[index] : null;
	},
	addXs: function addXs(xs) {
		var $$ = this;

		Object.keys(xs).forEach(function (id) {
			$$.config.data_xs[id] = xs[id];
		});
	},
	hasMultipleX: function hasMultipleX(xs) {
		// https://github.com/d3/d3-collection
		return (0, _d3Collection.set)(Object.keys(xs).map(function (id) {
			return xs[id];
		})).size() > 1;
	},
	isMultipleX: function isMultipleX() {
		return (0, _util.notEmpty)(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
	},
	addName: function addName(data) {
		var $$ = this,
			name = void 0;

		return data && (name = $$.config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
	},
	getValueOnIndex: function getValueOnIndex(values, index) {
		var valueOnIndex = values.filter(function (v) {
			return v.index === index;
		});

		return valueOnIndex.length ? valueOnIndex[0] : null;
	},
	updateTargetX: function updateTargetX(targets, x) {
		var $$ = this;

		targets.forEach(function (t) {
			t.values.forEach(function (v, i) {
				v.x = $$.generateTargetX(x[i], t.id, i);
			}), $$.data.xs[t.id] = x;
		});
	},
	updateTargetXs: function updateTargetXs(targets, xs) {
		var $$ = this;

		targets.forEach(function (t) {
			xs[t.id] && $$.updateTargetX([t], xs[t.id]);
		});
	},
	generateTargetX: function generateTargetX(rawX, id, index) {
		var $$ = this,
			x = void 0;

		return x = $$.isTimeSeries() ? rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() ? (0, _util.isValue)(rawX) ? +rawX : $$.getXValue(id, index) : index, x;
	},
	cloneTarget: function cloneTarget(target) {
		return {
			id: target.id,
			id_org: target.id_org,
			values: target.values.map(function (d) {
				return { x: d.x, value: d.value, id: d.id };
			})
		};
	},
	updateXs: function updateXs() {
		var $$ = this;

		$$.data.targets.length && ($$.xs = [], $$.data.targets[0].values.forEach(function (v) {
			$$.xs[v.index] = v.x;
		}));
	},
	getPrevX: function getPrevX(i) {
		var x = this.xs[i - 1];

		return (0, _util.isDefined)(x) ? x : null;
	},
	getNextX: function getNextX(i) {
		var x = this.xs[i + 1];

		return (0, _util.isDefined)(x) ? x : null;
	},

	/**
* Get min/max value from the data
* @private
* @param {Array} data array data to be evaluated
* @return {{min: {Number}, max: {Number}}}
*/
	getMinMaxValue: function getMinMaxValue(data) {
		var min = void 0,
			max = void 0;

		return (data || this.data.targets.map(function (t) {
			return t.values;
		})).forEach(function (v) {
			min = (0, _d3Array.min)([min, (0, _d3Array.min)(v, function(t) {
				return t.value;
			})]), max = (0, _d3Array.max)([max, (0, _d3Array.max)(v, function(t) {
				return t.value;
			})]);
		}), { min: min, max: max };
	},

	/**
* Get the min/max data
* @private
* @return {{min: Array, max: Array}}
*/
	getMinMaxData: function getMinMaxData() {
		var $$ = this;

		if (!$$.cache.$minMaxData) {
			var data = $$.data.targets.map(function (t) {
				return t.values;
			}),
				minMax = $$.getMinMaxValue(data),
				min = [],
				max = [];
			data.forEach(function (v) {
				var minData = $$.getFilteredDataByValue(v, minMax.min),
					maxData = $$.getFilteredDataByValue(v, minMax.max);
				minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
			}), $$.cache.$minMaxData = { min: min, max: max };
		}

		return $$.cache.$minMaxData;
	},

	/**
* Get total data sum
* @private
* @return {Number}
*/
	getTotalDataSum: function getTotalDataSum() {
		var $$ = this;

		if (!$$.cache.$totalDataSum) {
			var total = 0;

			$$.data.targets.map(function (t) {
				return t.values;
			}).forEach(function (v) {
				total += (0, _d3Array.sum)(v, function(t) {
					return t.value;
				});
			}), $$.cache.$totalDataSum = total;
		}

		return $$.cache.$totalDataSum;
	},

	/**
* Get filtered data by value
* @param {Object} data
* @param {Number} value
* @return {Array} filtered array data
* @private
*/
	getFilteredDataByValue: function getFilteredDataByValue(data, value) {
		return data.filter(function (t) {
			return t.value === value;
		});
	},

	/**
* Return the max length of the data
* @return {Number} max data length
* @private
*/
	getMaxDataCount: function getMaxDataCount() {
		return (0, _d3Array.max)(this.data.targets, function(t) {
			return t.values.length;
		});
	},
	getMaxDataCountTarget: function getMaxDataCountTarget(targets) {
		var length = targets.length,
			max = 0,
			maxTarget = void 0;

		return length > 1 ? targets.forEach(function (t) {
			t.values.length > max && (maxTarget = t, max = t.values.length);
		}) : maxTarget = length ? targets[0] : null, maxTarget;
	},
	mapToIds: function mapToIds(targets) {
		return targets.map(function (d) {
			return d.id;
		});
	},
	mapToTargetIds: function mapToTargetIds(ids) {
		var $$ = this;

		return ids ? (0, _util.isArray)(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
	},
	hasTarget: function hasTarget(targets, id) {
		var ids = this.mapToIds(targets);

		for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

		return !1;
	},
	isTargetToShow: function isTargetToShow(targetId) {
		return this.hiddenTargetIds.indexOf(targetId) < 0;
	},
	isLegendToShow: function isLegendToShow(targetId) {
		return this.hiddenLegendIds.indexOf(targetId) < 0;
	},
	filterTargetsToShow: function filterTargetsToShow(targets) {
		var $$ = this;

		return targets.filter(function (t) {
			return $$.isTargetToShow(t.id);
		});
	},
	mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
		var $$ = this,
			xs = (0, _d3Collection.set)((0, _d3Array.merge)(targets.map(function (t) {
			return t.values.map(function (v) {
				return +v.x;
			});
		}))).values();

		return xs = $$.isTimeSeries() ? xs.map(function (x) {
			return new Date(+x);
		}) : xs.map(function (x) {
			return +x;
		}), xs.sort(function (a, b) {
			return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
		});
	},
	addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
		this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
	},
	removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
		this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
			return targetIds.indexOf(id) < 0;
		});
	},
	addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
		this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
	},
	removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
		this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
			return targetIds.indexOf(id) < 0;
		});
	},
	getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
		var $$ = this,
			ys = {};

		return targets.forEach(function (t) {
			var data = [];

			t.values.forEach(function (v) {
				var value = v.value;

				(0, _util.isArray)(value) ? data.push.apply(data, value) : $$.isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : data.push(value);
			}), ys[t.id] = data;
		}), ys;
	},
	checkValueInTargets: function checkValueInTargets(targets, checker) {
		var ids = Object.keys(targets),
			values = void 0;

		for (var i = 0; i < ids.length; i++) {
			values = targets[ids[i]].values;

			for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
		}

		return !1;
	},
	hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
		return this.checkValueInTargets(targets, function(v) {
			return v < 0;
		});
	},
	hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
		return this.checkValueInTargets(targets, function(v) {
			return v > 0;
		});
	},
	_checkOrder: function _checkOrder(type) {
		var config = this.config;

		return (0, _util.isString)(config.data_order) && config.data_order.toLowerCase() === type;
	},
	isOrderDesc: function isOrderDesc() {
		return this._checkOrder("desc");
	},
	isOrderAsc: function isOrderAsc() {
		return this._checkOrder("asc");
	},
	orderTargets: function orderTargets(targets) {
		var $$ = this,
			config = $$.config,
			orderAsc = $$.isOrderAsc(),
			orderDesc = $$.isOrderDesc();
		// TODO: accept name array for order

		return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
			var reducer = function(p, c) {
				return p + Math.abs(c.value);
			},
				t1Sum = t1.values.reduce(reducer, 0),
				t2Sum = t2.values.reduce(reducer, 0);

			return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
		}) : (0, _util.isFunction)(config.data_order) && targets.sort(config.data_order), targets;
	},
	filterByX: function filterByX(targets, x) {
		return (0, _d3Array.merge)(targets.map(function (t) {
			return t.values;
		})).filter(function (v) {
			return v.x - x === 0;
		});
	},
	filterRemoveNull: function filterRemoveNull(data) {
		return data.filter(function (d) {
			return (0, _util.isValue)(d.value);
		});
	},
	filterByXDomain: function filterByXDomain(targets, xDomain) {
		return targets.map(function (t) {
			return {
				id: t.id,
				id_org: t.id_org,
				values: t.values.filter(function (v) {
					return xDomain[0] <= v.x && v.x <= xDomain[1];
				})
			};
		});
	},
	hasDataLabel: function hasDataLabel() {
		var dataLabels = this.config.data_labels;

		return (0, _util.isBoolean)(dataLabels) && dataLabels || (0, _util.isObjectType)(dataLabels) && (0, _util.notEmpty)(dataLabels);
	},
	getDataLabelLength: function getDataLabelLength(min, max, key) {
		var $$ = this,
			lengths = [0, 0];

		return $$.selectChart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
			return $$.dataLabelFormat(d.id)(d);
		}).each(function (d, i) {
			lengths[i] = this.getBoundingClientRect()[key] * 1.3;
		}).remove(), lengths;
	},
	isNoneArc: function isNoneArc(d) {
		return this.hasTarget(this.data.targets, d.id);
	},
	isArc: function isArc(d) {
		return "data" in d && this.hasTarget(this.data.targets, d.data.id);
	},
	findSameXOfValues: function findSameXOfValues(values, index) {
		var targetX = values[index].x,
			sames = [],
			i = void 0;

		for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);
		for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);
		return sames;
	},
	findClosestFromTargets: function findClosestFromTargets(targets, pos) {
		var $$ = this,
			candidates = targets.map(function (target) {
			return $$.findClosest(target.values, pos);
		});
		// map to array of closest points of each target

		// decide closest point and return
		return $$.findClosest(candidates, pos);
	},
	findClosest: function findClosest(values, pos) {
		var $$ = this,
			minDist = $$.config.point_sensitivity,
			closest = void 0;

		// find mouseovering bar

		return values.filter(function (v) {
			return v && $$.isBarType(v.id);
		}).forEach(function (v) {
			var shape = $$.main.select("." + _classes2.default.bars + $$.getTargetSelectorSuffix(v.id) + " ." + _classes2.default.bar + "-" + v.index).node();

			!closest && $$.isWithinBar(shape) && (closest = v);
		}), values.filter(function (v) {
			return v && !$$.isBarType(v.id);
		}).forEach(function (v) {
			var d = $$.dist(v, pos);

			d < minDist && (minDist = d, closest = v);
		}), closest;
	},
	dist: function dist(data, pos) {
		var $$ = this,
			config = $$.config,
			xIndex = config.axis_rotated ? 1 : 0,
			yIndex = config.axis_rotated ? 0 : 1,
			y = $$.circleY(data, data.index),
			x = $$.x(data.x);

		return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
	},
	convertValuesToStep: function convertValuesToStep(values) {
		var converted = (0, _util.isArray)(values) ? values.concat() : [values];

		if (!this.isCategorized()) return values;

		for (var i = values.length + 1; i > 0; i--) converted[i] = converted[i - 1];

		return converted[0] = {
			x: converted[0].x - 1,
			value: converted[0].value,
			id: converted[0].id
		}, converted[values.length + 1] = {
			x: converted[values.length].x + 1,
			value: converted[values.length].value,
			id: converted[values.length].id
		}, converted;
	},
	convertValuesToRange: function convertValuesToRange(values) {
		var converted = (0, _util.isArray)(values) ? values.concat() : [values],
			ranges = [];

		return converted.forEach(function (range) {
			var x = range.x,
				id = range.id;
			ranges.push({
				x: x,
				id: id,
				value: range.value[0]
			}), ranges.push({
				x: x,
				id: id,
				value: range.value[2]
			});
		}), ranges;
	},
	updateDataAttributes: function updateDataAttributes(name, attrs) {
		var $$ = this,
			config = $$.config,
			current = config["data_" + name];
		return (0, _util.isUndefined)(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
			current[id] = attrs[id];
		}), $$.redraw({ withLegend: !0 }), current);
	},
	getAreaRangeData: function getAreaRangeData(d, type) {
		if ((0, _util.isArray)(d.value)) {
			var index = ["high", "mid", "low"].indexOf(type);

			return index === -1 ? 0 : d.value[index];
		}

		return d.value[type];
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Dsv = __webpack_require__(4),
	_d3Collection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	convertUrlToData: function convertUrlToData(url) {
		var _this = this,
			mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "csv",
			headers = arguments[2],
			keys = arguments[3],
			done = arguments[4],
			req = new XMLHttpRequest();

		if (headers) for (var _iterator = Object.keys(headers), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
				var _ref;

				if (_isArray) {
					if (_i >= _iterator.length) break;
					_ref = _iterator[_i++];
				} else {
					if (_i = _iterator.next(), _i.done) break;
					_ref = _i.value;
				}

				var header = _ref;
				req.setRequestHeader(header, headers[header]);
			}

		req.open("GET", url), req.onreadystatechange = function() {
			if (req.readyState === 4) if (req.status === 200) {
					var response = req.responseText;

					response && done.call(_this, _this["convert" + (0, _util.capitalize)(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
				} else throw new Error(url + ": Something went wrong loading!");
		}, req.send();
	},
	_convertCsvTsvToData: function _convertCsvTsvToData(parser, xsv) {
		var rows = parser.rows(xsv),
			d = void 0;

		return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
			d[0][id] = null;
		})) : d = parser.parse(xsv), d;
	},
	convertCsvToData: function convertCsvToData(xsv) {
		return this._convertCsvTsvToData({
			rows: _d3Dsv.csvParseRows,
			parse: _d3Dsv.csvParse
		}, xsv);
	},
	convertTsvToData: function convertTsvToData(tsv) {
		return this._convertCsvTsvToData({
			rows: _d3Dsv.tsvParseRows,
			parse: _d3Dsv.tsvParse
		}, tsv);
	},
	convertJsonToData: function convertJsonToData(json, keys) {
		var _this2 = this,
			newRows = [],
			targetKeys = void 0,
			data = void 0;

		return keys ? (keys.x ? (targetKeys = keys.value.concat(keys.x), this.config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {

			for (var newRow = [], v = void 0, _iterator2 = targetKeys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
				var _ref2;

				if (_isArray2) {
					if (_i2 >= _iterator2.length) break;
					_ref2 = _iterator2[_i2++];
				} else {
					if (_i2 = _iterator2.next(), _i2.done) break;
					_ref2 = _i2.value;
				}

				var key = _ref2;
				v = _this2.findValueInJson(o, key), (0, _util.isUndefined)(v) && (v = null), newRow.push(v);
			}
			newRows.push(newRow);
		}), data = this.convertRowsToData(newRows)) : (Object.keys(json).forEach(function (key) {
			var tmp = json[key].concat();

			tmp.unshift(key), newRows.push(tmp);
		}), data = this.convertColumnsToData(newRows)), data;
	},
	findValueInJson: function findValueInJson(object, path) {
		if (object[path] !== undefined) return object[path];

		var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
			pathArray = convertedPath.replace(/^\./, "").split("."),
			target = object; // convert indexes to properties (replace [] with .)
		// strip a leading dot

		for (var _iterator3 = pathArray, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
			var _ref3;

			if (_isArray3) {
				if (_i3 >= _iterator3.length) break;
				_ref3 = _iterator3[_i3++];
			} else {
				if (_i3 = _iterator3.next(), _i3.done) break;
				_ref3 = _i3.value;
			}

			var k = _ref3;

			if (k in target) target = target[k];else {
				target = undefined;

				break;
			}
		}

		return target;
	},
	convertRowsToData: function convertRowsToData(rows) {
		var keys = rows[0],
			newRows = [];

		for (var i = 1, len1 = rows.length; i < len1; i++) {
			var newRow = {};

			for (var j = 0, len2 = rows[i].length; j < len2; j++) {
				if ((0, _util.isUndefined)(rows[i][j])) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");

				newRow[keys[j]] = rows[i][j];
			}

			newRows.push(newRow);
		}

		return newRows;
	},
	convertColumnsToData: function convertColumnsToData(columns) {
		var newRows = [];

		for (var i = 0, len1 = columns.length; i < len1; i++) {
			var key = columns[i][0];

			for (var j = 1, len2 = columns[i].length; j < len2; j++) {

				if ((0, _util.isUndefined)(newRows[j - 1]) && (newRows[j - 1] = {}), (0, _util.isUndefined)(columns[i][j])) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");

				newRows[j - 1][key] = columns[i][j];
			}
		}

		return newRows;
	},
	convertDataToTargets: function convertDataToTargets(data, appendXs) {
		var _this3 = this,
			$$ = this,
			config = $$.config,
			ids = (0, _d3Collection.keys)(data[0]).filter($$.isNotX, $$),
			xs = (0, _d3Collection.keys)(data[0]).filter($$.isX, $$);

		ids.forEach(function (id) {
			var xKey = _this3.getXKey(id);

			_this3.isCustomX() || _this3.isTimeSeries() ? xs.indexOf(xKey) >= 0 ? _this3.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function (d) {
				return d[xKey];
			}).filter(_util.isValue).map(function (rawX, i) {
				return $$.generateTargetX(rawX, id, i);
			})) : config.data_x ? _this3.data.xs[id] = _this3.getOtherTargetXs() : (0, _util.notEmpty)(config.data_xs) && ($$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets)) : $$.data.xs[id] = data.map(function (d, i) {
				return i;
			});
		}), ids.forEach(function (id) {
			if (!$$.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
		});

		// convert to target
		var targets = ids.map(function (id, index) {
			var convertedId = config.data_idConverter(id);

			return {
				id: convertedId,
				id_org: id,
				values: data.map(function (d, i) {
					var xKey = $$.getXKey(id),
						rawX = d[xKey],
						value = d[id] === null || isNaN(d[id]) ? (0, _util.isArray)(d[id]) || $$.isObject(d[id]) && d[id].high ? d[id] : null : +d[id],
						x = void 0;

					// use x as categories if custom x and categorized

					return $$.isCustomX() && $$.isCategorized() && index === 0 && !(0, _util.isUndefined)(rawX) ? (index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), ((0, _util.isUndefined)(d[id]) || $$.data.xs[id].length <= i) && (x = undefined), { x: x, value: value, id: convertedId };
				}).filter(function (v) {
					return (0, _util.isDefined)(v.x);
				})
			};
		});

		// finish targets

		return targets.forEach(function (t) {
			var i = void 0;

			// sort values by its x
			config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
				var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
					x2 = v2.x || v2.x === 0 ? v2.x : Infinity;

				return x1 - x2;
			})), i = 0, t.values.forEach(function (v) {
				v.index = i++;
			}), $$.data.xs[t.id].sort(function (v1, v2) {
				return v1 - v2;
			});
		}), $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets), $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
			return !(id in config.data_types);
		}), config.data_type), targets.forEach(function (d) {
			return $$.addCache(d.id_org, d);
		}), targets;
	}
});

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	load: function load(rawTargets, args) {
		var $$ = this,
			targets = rawTargets;
		targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
			var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;

			$$.setTargetType(t.id, type);
		}), $$.data.targets.forEach(function (d) {
			for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
				d.values = targets[i].values, targets.splice(i, 1);

				break;
			}
		}), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
			withUpdateOrgXDomain: !0,
			withUpdateXDomain: !0,
			withLegend: !0
		}), args.done && args.done();
	},
	loadFromArgs: function loadFromArgs(args) {
		var $$ = this;

		// reset internally cached data
		$$.resetCache(), args.data ? $$.load($$.convertDataToTargets(args.data), args) : args.url ? $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function(data) {
			$$.load($$.convertDataToTargets(data), args);
		}) : args.json ? $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args) : args.rows ? $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args) : args.columns ? $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args) : $$.load(null, args);
	},
	unload: function unload(rawTargetIds, customDoneCb) {
		var $$ = this,
			done = customDoneCb,
			targetIds = rawTargetIds;

		// reset internally cached data

		// If no target, call done and return
		return $$.resetCache(), done || (done = function() {}), targetIds = targetIds.filter(function (id) {
			return $$.hasTarget($$.data.targets, id);
		}), targetIds && targetIds.length !== 0 ? void ($$.svg.selectAll(targetIds.map(function (id) {
			return $$.selectorTarget(id);
		})).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
			$$.withoutFadeIn[id] = !1, $$.legend && $$.legend.selectAll("." + _classes2.default.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
				return t.id !== id;
			});
		})) : void done();
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Category Name
* @private
* @param {Number} index
* @returns {String} gategory Name
*/
	categoryName: function categoryName(i) {
		var config = this.config;

		return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
	}
});

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_d3Drag = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Get mouse event
var _getMouseEvent = function getMouseEvent() {
	var getParams = function() {
		return {
			bubbles: !1, cancelable: !1, screenX: 0, screenY: 0, clientX: 0, clientY: 0
		};
	};

	try {
		new MouseEvent("t"), _getMouseEvent = function getMouseEvent() {
			return function(eventType) {
				var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getParams();
				return new MouseEvent(eventType, params);
			};
		};
	} catch (e) {
		_getMouseEvent = function getMouseEvent() {
			return function(eventType) {
				var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getParams(),
					mouseEvent = document.createEvent("MouseEvent");

				// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

				return mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, // the event's mouse click count
				params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), mouseEvent;
			};
		};
	}

	return _getMouseEvent();
}; /**
	* Copyright (c) 2017 NAVER Corp.
	* billboard.js project is licensed under the MIT license
	*/
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initialize the area that detects the event.
* Add a container for the zone that detects the event.
* @private
*/
	initEventRect: function initEventRect() {
		var $$ = this;

		$$.main.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.eventRects).style("fill-opacity", "0");
	},

	/**
* Redraws the area that detects the event.
* @private
*/
	redrawEventRect: function redrawEventRect() {
		var $$ = this,
			config = $$.config,
			isMultipleX = $$.isMultipleX(),
			eventRects = $$.main.select("." + _classes2.default.eventRects).style("cursor", config.zoom_enabled ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(_classes2.default.eventRectsMultiple, isMultipleX).classed(_classes2.default.eventRectsSingle, !isMultipleX),
			eventRectUpdate = void 0,
			maxDataCountTarget = void 0;

		// rects for mouseover

		// clear old rects

		if (eventRects.selectAll("." + _classes2.default.eventRect).remove(), $$.eventRect = eventRects.selectAll("." + _classes2.default.eventRect), isMultipleX ? (eventRectUpdate = $$.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate), $$.updateEventRect(eventRectUpdate)) : (maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets), eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []), $$.eventRect = eventRects.selectAll("." + _classes2.default.eventRect), eventRectUpdate = $$.eventRect.data(function (d) {
			return d;
		}), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate), $$.updateEventRect(eventRectUpdate)), $$.inputType === "touch" && !$$.hasArcType()) {
			var getEventRect = function() {
				var touch = _d3Selection.event.changedTouches[0];

				return (0, _d3Selection.select)(document.elementFromPoint(touch.clientX, touch.clientY));
			},
				getIndex = function(eventRect) {
				var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + _classes2.default.eventRect + "-?|s)", "g"), "") * 1;

				return (isNaN(index) || index === null) && (index = -1), index;
			},
				selectRect = function(context) {
				if (isMultipleX) $$.selectRectForMultipleXs(context);else {
					var eventRect = getEventRect(),
						index = getIndex(eventRect);
					index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
				}
			},
				preventDefault = config.interaction_inputType_touch.preventDefault,
				isPrevented = (0, _util.isBoolean)(preventDefault) && preventDefault || !1,
				preventThreshold = !isNaN(preventDefault) && preventDefault || null,
				startPx = void 0,
				preventEvent = function(event) {
				var eventType = event.type,
					touch = event.changedTouches[0],
					currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
				eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
			};

			// call event.prenvetDefault()
			// according 'interaction.inputType.touch.preventDefault' option
			$$.svg.on("touchstart touchmove", function() {
				var eventRect = getEventRect();

				if (!eventRect.empty() && eventRect.classed(_classes2.default.eventRect)) {
					if ($$.dragging || $$.flowing || $$.hasArcType()) return;

					preventEvent(_d3Selection.event), selectRect(this);
				} else $$.unselectRect();
			}).on("touchend", function() {
				var eventRect = getEventRect();

				if (!eventRect.empty() && eventRect.classed(_classes2.default.eventRect)) {
					if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));

					// Call event handler
					var index = getIndex(eventRect);

					isMultipleX || index === -1 || $$.main.selectAll("." + _classes2.default.shape + "-" + index).each(function (d2) {
						return config.data_onout.call($$.api, d2);
					});
				}
			});
		}
	},

	/**
* Updates the location and size of the eventRect.
* @private
* @param {Object} d3.select(CLASS.eventRects) object.
*/
	updateEventRect: function updateEventRect(eventRectUpdate) {
		var $$ = this,
			config = $$.config,
			xScale = $$.zoomScale || $$.x,
			eventRectData = eventRectUpdate || $$.eventRect.data(),
			x = void 0,
			y = void 0,
			w = void 0,
			h = void 0; // set update selection if null

		if ($$.isMultipleX()) x = 0, y = 0, w = $$.width, h = $$.height;else {
			var rectW = void 0,
				rectX = void 0;
			($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized() ? ($$.updateXs(), rectW = function(d) {
				var prevX = $$.getPrevX(d.index),
					nextX = $$.getNextX(d.index);

				// if there this is a single data point make the eventRect full width (or height)
				return prevX === null && nextX === null ? config.axis_rotated ? $$.height : $$.width : (prevX === null && (prevX = xScale.domain()[0]), nextX === null && (nextX = xScale.domain()[1]), Math.max(0, (xScale(nextX) - xScale(prevX)) / 2));
			}, rectX = function(d) {
				var nextX = $$.getNextX(d.index),
					thisX = $$.data.xs[d.id][d.index],
					prevX = $$.getPrevX(d.index);

				// if there this is a single data point position the eventRect at 0
				return prevX === null && nextX === null ? 0 : (prevX === null && (prevX = xScale.domain()[0]), (xScale(thisX) + xScale(prevX)) / 2);
			}) : (rectW = $$.getEventRectWidth(), rectX = function(d) {
				return xScale(d.x) - rectW / 2;
			}), x = config.axis_rotated ? 0 : rectX, y = config.axis_rotated ? rectX : 0, w = config.axis_rotated ? $$.width : rectW, h = config.axis_rotated ? rectW : $$.height;
		}

		eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
	},
	selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
		var $$ = this,
			config = $$.config,
			selectedData = $$.filterTargetsToShow($$.data.targets).map(function (t) {
			return $$.addName($$.getValueOnIndex(t.values, index));
		});
		// Show tooltip
		config.tooltip_grouped && ($$.showTooltip(selectedData, context), $$.showXGridFocus(selectedData), !config.data_selection_enabled || config.data_selection_grouped) || $$.main.selectAll("." + _classes2.default.shape + "-" + index).each(function () {
			(0, _d3Selection.select)(this).classed(_classes2.default.EXPANDED, !0), config.data_selection_enabled && eventRect.style("cursor", config.data_selection_grouped ? "pointer" : null), config.tooltip_grouped || ($$.hideXGridFocus(), $$.hideTooltip(), !config.data_selection_grouped && ($$.unexpandCircles(index), $$.unexpandBars(index)));
		}).filter(function (d) {
			return $$.isWithinShape(this, d);
		}).each(function (d) {
			config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), config.tooltip_grouped || ($$.showTooltip([d], this), $$.showXGridFocus([d]), config.point_focus_expand_enabled && $$.expandCircles(index, d.id, !0), $$.expandBars(index, d.id, !0));
		});
	},
	selectRectForMultipleXs: function selectRectForMultipleXs(context) {
		var $$ = this,
			config = $$.config,
			targetsToShow = $$.filterTargetsToShow($$.data.targets);

		// do nothing when dragging
		if (!($$.dragging || $$.hasArcType(targetsToShow))) {

				var mouse = (0, _d3Selection.mouse)(context),
					closest = $$.findClosestFromTargets(targetsToShow, mouse),
					sameXData = void 0;

				if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id) && (config.data_onout.call($$.api, $$.mouseover), $$.mouseover = undefined), !closest) return void $$.unselectRect();

				sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x);

				// show tooltip when cursor is close to some point
				var selectedData = sameXData.map(function (d) {
					return $$.addName(d);
				});

				$$.showTooltip(selectedData, context), config.point_focus_expand_enabled && $$.expandCircles(closest.index, closest.id, !0), $$.expandBars(closest.index, closest.id, !0), $$.showXGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.svg.select("." + _classes2.default.eventRect).style("cursor", "pointer"), !$$.mouseover && (config.data_onover.call($$.api, closest), $$.mouseover = closest));
			}
	},

	/**
* Unselect EventRect.
* @private
*/
	unselectRect: function unselectRect() {
		var $$ = this;

		$$.svg.select("." + _classes2.default.eventRect).style("cursor", null), $$.hideXGridFocus(), $$.hideTooltip(), $$.unexpandCircles(), $$.unexpandBars();
	},

	/**
* Create eventRect for each data on the x-axis.
* Register touch and drag events.
* @private
* @param {Object} d3.select(CLASS.eventRects) object.
* @returns {Object} d3.select(CLASS.eventRects) object.
*/
	generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
		var $$ = this,
			config = $$.config,
			rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function(d) {
			if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));

			var index = d.index;

			$$.main.selectAll("." + _classes2.default.shape + "-" + index).each(function (d2) {
				(config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), $$.config.data_onclick.call($$.api, d2, this));
			});
		}).call(config.data_selection_draggable && $$.drag ? (0, _d3Drag.drag)().origin(Object).on("drag", function() {
			$$.drag((0, _d3Selection.mouse)(this));
		}).on("dragstart", function() {
			$$.dragstart((0, _d3Selection.mouse)(this));
		}).on("dragend", function() {
			$$.dragend();
		}) : function() {});

		return $$.inputType === "mouse" && rect.on("mouseover", function(d) {
			// do nothing while dragging/flowing
			if (!($$.dragging || $$.flowing || $$.hasArcType())) {

					var index = d.index;

					// Expand shapes for selection
					config.point_focus_expand_enabled && $$.expandCircles(index, null, !0), $$.expandBars(index, null, !0), index !== -1 && $$.main.selectAll("." + _classes2.default.shape + "-" + index).each(function (d2) {
						return config.data_onover.call($$.api, d2);
					});
				}
		}).on("mousemove", function(d) {
			// do nothing while dragging/flowing
			if (!($$.dragging || $$.flowing || $$.hasArcType())) {

					var index = d.index,
						eventRect = $$.svg.select("." + _classes2.default.eventRect + "-" + index);
					$$.isStepType(d) && $$.config.line_step_type === "step-after" && (0, _d3Selection.mouse)(this)[0] < $$.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index);
				}
		}).on("mouseout", function(d) {
			// chart is destroyed
			if ($$.config && !$$.hasArcType()) {

					var index = d.index;

					$$.unselectRect(), $$.main.selectAll("." + _classes2.default.shape + "-" + index).each(function (d2) {
						return config.data_onout.call($$.api, d2);
					});
				}
		}), rect;
	},

	/**
* Create an eventRect,
* Register touch and drag events.
* @private
* @param {Object} d3.select(CLASS.eventRects) object.
* @returns {Object} d3.select(CLASS.eventRects) object.
*/
	generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
		var $$ = this,
			config = $$.config,
			rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", $$.width).attr("height", $$.height).attr("class", _classes2.default.eventRect).on("click", function() {
			var targetsToShow = $$.filterTargetsToShow($$.data.targets);

			// select if selection enabled
			if (!$$.hasArcType(targetsToShow)) {

					var mouse = (0, _d3Selection.mouse)(this),
						closest = $$.findClosestFromTargets(targetsToShow, mouse);
					!closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.main.selectAll("." + _classes2.default.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + _classes2.default.shape + "-" + closest.index).each(function () {
						(config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), $$.config.data_onclick.call($$.api, closest, this));
					});
				}
		}).call(config.data_selection_draggable && $$.drag ? (0, _d3Drag.drag)().origin(Object).on("drag", function() {
			$$.drag((0, _d3Selection.mouse)(this));
		}).on("dragstart", function() {
			$$.dragstart((0, _d3Selection.mouse)(this));
		}).on("dragend", function() {
			$$.dragend();
		}) : function() {});

		return $$.inputType === "mouse" && rect.on("mouseover", function() {
			$$.selectRectForMultipleXs(this);
		}).on("mouseout", function() {
			!$$.config || $$.hasArcType() || $$.unselectRect();
		}).on("mousemove", function() {
			$$.selectRectForMultipleXs(this);
		}), rect;
	},

	/**
* Dispatch a mouse event.
* @private
* @param {String} type event type
* @param {Number} index Index of eventRect
* @param {Array} mouse x and y coordinate value
*/
	dispatchEvent: function dispatchEvent(type, index, mouse) {
		var $$ = this,
			selector = "." + ($$.isMultipleX() ? _classes2.default.eventRect : _classes2.default.eventRect + "-" + index),
			eventRect = $$.main.select(selector).node(),
			box = eventRect.getBoundingClientRect(),
			x = box.left + (mouse ? mouse[0] : 0),
			y = box.top + (mouse ? mouse[1] : 0),
			mouseEvent = _getMouseEvent();
		eventRect.dispatchEvent(mouseEvent(type, {
			screenX: x,
			screenY: y,
			clientX: x,
			clientY: y
		}));
	}
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	getCurrentWidth: function getCurrentWidth() {
		var $$ = this,
			config = $$.config;

		return config.size_width ? config.size_width : $$.getParentWidth();
	},
	getCurrentHeight: function getCurrentHeight() {
		var $$ = this,
			config = $$.config,
			h = config.size_height ? config.size_height : $$.getParentHeight();

		return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
	},
	getCurrentPaddingTop: function getCurrentPaddingTop() {
		var $$ = this,
			config = $$.config,
			padding = (0, _util.isValue)(config.padding_top) ? config.padding_top : 0;

		return $$.title && $$.title.node() && (padding += $$.getTitlePadding()), padding;
	},
	getCurrentPaddingBottom: function getCurrentPaddingBottom() {
		var config = this.config;

		return (0, _util.isValue)(config.padding_bottom) ? config.padding_bottom : 0;
	},
	getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
		var $$ = this,
			config = $$.config,
			paddingLeft = void 0;

		return paddingLeft = (0, _util.isValue)(config.padding_left) ? config.padding_left : config.axis_rotated ? config.axis_x_show ? Math.max((0, _util.ceil10)($$.getAxisWidthByAxisId("x", withoutRecompute)), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : (0, _util.ceil10)($$.getAxisWidthByAxisId("y", withoutRecompute)), paddingLeft;
	},
	getCurrentPaddingRight: function getCurrentPaddingRight() {
		var $$ = this,
			config = $$.config,
			legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0,
			paddingRight = void 0;

		return paddingRight = (0, _util.isValue)(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? 10 + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : (0, _util.ceil10)($$.getAxisWidthByAxisId("y2")) + legendWidthOnRight, paddingRight;
	},

	/**
* Get the parent rect element's size
* @param {String} key property/attribute name
* @private
*/
	getParentRectValue: function getParentRectValue(key) {
		for (var offsetName = "offset" + (0, _util.capitalize)(key), parent = this.selectChart.node(), v = void 0; !v && parent && parent.tagName !== "BODY";) {
			try {
				v = parent.getBoundingClientRect()[key];
			} catch (e) {
				offsetName in parent && (v = parent[offsetName]);
			}

			parent = parent.parentNode;
		}

		if (key === "width") {
			// Sometimes element's width value is incorrect(ex. flex container)
			// In this case, use body's offsetWidth instead.
			var bodyWidth = document.body.offsetWidth;

			v > bodyWidth && (v = bodyWidth);
		}

		return v;
	},
	getParentWidth: function getParentWidth() {
		return this.getParentRectValue("width");
	},
	getParentHeight: function getParentHeight() {
		var h = this.selectChart.style("height");

		return h.indexOf("px") > 0 ? +h.replace("px", "") : 0;
	},
	getSvgLeft: function getSvgLeft(withoutRecompute) {
		var $$ = this,
			config = $$.config,
			hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
			leftAxisClass = config.axis_rotated ? _classes2.default.axisX : _classes2.default.axisY,
			leftAxis = $$.main.select("." + leftAxisClass).node(),
			svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : { right: 0 },
			chartRect = $$.selectChart.node().getBoundingClientRect(),
			hasArc = $$.hasArcType(),
			svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));

		return svgLeft > 0 ? svgLeft : 0;
	},
	getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
		var $$ = this,
			position = $$.axis.getLabelPositionById(id);

		return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
	},
	getHorizontalAxisHeight: function getHorizontalAxisHeight(axisId) {
		var $$ = this,
			config = $$.config,
			h = 30;

		// Calculate x axis height when tick rotated
		return axisId !== "x" || config.axis_x_show ? axisId === "x" && config.axis_x_height ? config.axis_x_height : axisId !== "y" || config.axis_y_show ? axisId !== "y2" || config.axis_y2_show ? (axisId === "x" && !config.axis_rotated && config.axis_x_tick_rotate && (h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180)), axisId === "y" && config.axis_rotated && config.axis_y_tick_rotate && (h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_y_tick_rotate) / 180)), h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === "y2" ? -10 : 0)) : $$.rotated_padding_top : !config.legend_show || $$.isLegendRight || $$.isLegendInset ? 1 : 10 : 8;
	},
	getEventRectWidth: function getEventRectWidth() {
		return Math.max(0, this.xAxis.tickInterval());
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Shape = __webpack_require__(4),
	_d3Selection = __webpack_require__(4),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	getShapeIndices: function getShapeIndices(typeFilter) {
		var $$ = this,
			config = $$.config,
			indices = {},
			i = 0;

		return $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
			for (var j = 0; j < config.data_groups.length; j++) if (!(config.data_groups[j].indexOf(d.id) < 0)) for (var _k5 = 0; _k5 < config.data_groups[j].length; _k5++) if (config.data_groups[j][_k5] in indices) {
					indices[d.id] = indices[config.data_groups[j][_k5]];

					break;
				}

			(0, _util.isUndefined)(indices[d.id]) && (indices[d.id] = i++);
		}), indices.__max__ = i - 1, indices;
	},
	getShapeX: function getShapeX(offset, targetsNum, indices, isSub) {
		var $$ = this,
			scale = isSub ? $$.subX : $$.zoomScale ? $$.zoomScale : $$.x,
			barPadding = $$.config.bar_padding;

		return function(d) {
			var index = d.id in indices ? indices[d.id] : 0,
				x = d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;

			// adjust x position for bar.padding option

			return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
		};
	},
	getShapeY: function getShapeY(isSub) {
		var $$ = this;

		return function(d) {
			var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);

			return scale(d.value);
		};
	},
	getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
		var $$ = this,
			targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
			targetIds = targets.map(function (t) {
			return t.id;
		});

		return function(d, idx) {
			var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
				y0 = scale(0),
				offset = y0,
				i = idx;

			return targets.forEach(function (t) {
				var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;

				t.id === d.id || indices[t.id] !== indices[d.id] || targetIds.indexOf(t.id) < targetIds.indexOf(d.id) && (((0, _util.isUndefined)(values[i]) || +values[i].x !== +d.x) && (i = -1, values.forEach(function (v, j) {
					var x1 = v.x.constructor === Date ? +v.x : v.x,
						x2 = d.x.constructor === Date ? +d.x : d.x;
					x1 === x2 && (i = j);
				})), i in values && values[i].value * d.value >= 0 && (offset += scale(values[i].value) - y0));
			}), offset;
		};
	},
	isWithinShape: function isWithinShape(that, d) {
		var $$ = this,
			shape = (0, _d3Selection.select)(that),
			isWithin = void 0;

		return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5) : that.nodeName === "path" && (isWithin = !shape.classed(_classes2.default.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
	},
	getInterpolate: function getInterpolate(d) {
		var $$ = this,
			interpolation = $$.getInterpolateType(d);

		return {
			"basis": _d3Shape.curveBasis,
			"basis-closed": _d3Shape.curveBasisClosed,
			"basis-open": _d3Shape.curveBasisOpen,
			"bundle": _d3Shape.curveBundle,
			"cardinal": _d3Shape.curveCardinal,
			"cardinal-closed": _d3Shape.curveCardinalClosed,
			"cardinal-open": _d3Shape.curveCardinalOpen,
			"catmull-rom": _d3Shape.curveCatmullRom,
			"catmull-rom-closed": _d3Shape.curveCatmullRomClosed,
			"catmull-rom-open": _d3Shape.curveCatmullRomOpen,
			"monotone-x": _d3Shape.curveMonotoneX,
			"monotone-y": _d3Shape.curveMonotoneY,
			"natural": _d3Shape.curveNatural,
			"linear-closed": _d3Shape.curveLinearClosed,
			"linear": _d3Shape.curveLinear,
			"step": _d3Shape.curveStep,
			"step-after": _d3Shape.curveStepAfter,
			"step-before": _d3Shape.curveStepBefore
		}[interpolation];
	},
	getInterpolateType: function getInterpolateType(d) {
		var $$ = this,
			interpolation = $$.isInterpolationType($$.config.spline_interpolation_type) ? $$.config.spline_interpolation_type : "cardinal";

		return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_d3Shape = __webpack_require__(4),
	_d3Array = __webpack_require__(4),
	_d3Interpolate = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	initPie: function initPie() {
		var $$ = this,
			config = $$.config,
			padAngle = $$.hasType("pie") && config.pie_padding ? config.pie_padding * .01 : config[config.data_type + "_padAngle"] ? config[config.data_type + "_padAngle"] : 0;
		$$.pie = (0, _d3Shape.pie)().padAngle(padAngle).value(function (d) {
			return d.values.reduce(function (a, b) {
				return a + b.value;
			}, 0);
		}), config.data_order || $$.pie.sort(null);
	},
	updateRadius: function updateRadius() {
		var $$ = this,
			config = $$.config,
			w = config.gauge_width || config.donut_width;
		$$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2, $$.radius = $$.radiusExpanded * .95, $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : .6;

		var innerRadius = config.pie_innerRadius ? config.pie_innerRadius : config.pie_padding ? config.pie_padding * ($$.innerRadiusRatio + .1) : 0;

		$$.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? $$.radius * $$.innerRadiusRatio : innerRadius;
	},
	updateArc: function updateArc() {
		var $$ = this;

		$$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded(), $$.svgArcExpandedSub = $$.getSvgArcExpanded(.98);
	},
	updateAngle: function updateAngle(dValue) {
		var $$ = this,
			config = $$.config,
			d = dValue,
			found = !1,
			index = 0,
			gMin = void 0,
			gMax = void 0,
			gTic = void 0,
			gValue = void 0;
		return config ? ($$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {
			found || t.data.id !== d.data.id || (found = !0, d = t, d.index = index), index++;
		}), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), $$.isGaugeType(d.data) && (gMin = config.gauge_min, gMax = config.gauge_max, gTic = Math.PI * (config.gauge_fullCircle ? 2 : 1) / (gMax - gMin), gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin, d.startAngle = config.gauge_startingAngle, d.endAngle = d.startAngle + gTic * gValue), found ? d : null) : null;
	},
	getSvgArc: function getSvgArc() {
		var $$ = this,
			arc = (0, _d3Shape.arc)().outerRadius($$.radius).innerRadius($$.innerRadius),
			newArc = function(d, withoutUpdate) {
			if (withoutUpdate) return arc(d); // for interpolate

			var updated = $$.updateAngle(d);

			return updated ? arc(updated) : "M 0 0";
		};

		// TODO: extends all function

		return newArc.centroid = arc.centroid, newArc;
	},
	getSvgArcExpanded: function getSvgArcExpanded(rate) {
		var $$ = this,
			arc = (0, _d3Shape.arc)().outerRadius($$.radiusExpanded * (rate || 1)).innerRadius($$.innerRadius);

		return function(d) {
			var updated = $$.updateAngle(d);

			return updated ? arc(updated) : "M 0 0";
		};
	},
	getArc: function getArc(d, withoutUpdate, force) {
		return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
	},
	transformForArcLabel: function transformForArcLabel(d) {
		var $$ = this,
			config = $$.config,
			updated = $$.updateAngle(d),
			c = void 0,
			x = void 0,
			y = void 0,
			h = void 0,
			ratio = void 0,
			translate = "";

		return updated && !$$.hasType("gauge") && (c = this.svgArc.centroid(updated), x = isNaN(c[0]) ? 0 : c[0], y = isNaN(c[1]) ? 0 : c[1], h = Math.sqrt(x * x + y * y), ratio = $$.hasType("donut") && config.donut_label_ratio ? (0, _util.isFunction)(config.donut_label_ratio) ? config.donut_label_ratio(d, $$.radius, h) : config.donut_label_ratio : $$.hasType("pie") && config.pie_label_ratio ? (0, _util.isFunction)(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio : $$.radius && (h ? (36 / $$.radius > .375 ? 1.175 - 36 / $$.radius : .8) * $$.radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")"), translate;
	},
	getArcRatio: function getArcRatio(d) {
		var $$ = this,
			config = $$.config,
			val = null;

		if (d)
			// if has padAngle set, calculate rate based on value
			if ($$.pie.padAngle()()) {
				var total = $$.getTotalDataSum();

				$$.hiddenTargetIds.length && (total -= (0, _d3Array.sum)($$.api.data.values.call($$.api, $$.hiddenTargetIds))), val = d.value / total;
			} else val = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));

		return val;
	},
	convertToArcData: function convertToArcData(d) {
		return this.addName({
			id: d.data.id,
			value: d.value,
			ratio: this.getArcRatio(d),
			index: d.index
		});
	},
	textForArcLabel: function textForArcLabel(d) {
		var $$ = this;

		if (!$$.shouldShowArcLabel()) return "";

		var updated = $$.updateAngle(d),
			value = updated ? updated.value : null,
			ratio = $$.getArcRatio(updated),
			id = d.data.id;

		if (!$$.hasType("gauge") && !$$.meetsArcLabelThreshold(ratio)) return "";

		var format = $$.getArcLabelFormat();

		return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);
	},
	textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
		var format = this.getGaugeLabelExtents();

		return format ? format(value, isMax) : value;
	},
	expandArc: function expandArc(targetIds) {
		var $$ = this,
			interval = void 0;

		// MEMO: avoid to cancel transition
		if ($$.transiting) return void (interval = window.setInterval(function () {
				$$.transiting || (window.clearInterval(interval), $$.legend.selectAll("." + _classes2.default.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
			}, 10));

		var newTargetIds = $$.mapToTargetIds(targetIds);

		$$.svg.selectAll($$.selectorTargets(newTargetIds, "." + _classes2.default.chartArc)).each(function (d) {
			$$.shouldExpand(d.data.id) && (0, _d3Selection.select)(this).selectAll("path").transition().duration($$.expandDuration(d.data.id)).attr("d", $$.svgArcExpanded).transition().duration($$.expandDuration(d.data.id) * 2).attr("d", $$.svgArcExpandedSub);
		});
	},
	unexpandArc: function unexpandArc(targetIds) {
		var $$ = this;

		if (!$$.transiting) {

				var newTargetIds = $$.mapToTargetIds(targetIds);

				$$.svg.selectAll($$.selectorTargets(newTargetIds, "." + _classes2.default.chartArc)).selectAll("path").transition().duration(function (d) {
					return $$.expandDuration(d.data.id);
				}).attr("d", $$.svgArc), $$.svg.selectAll("" + _classes2.default.arc).style("opacity", "1");
			}
	},
	expandDuration: function expandDuration(id) {
		var $$ = this,
			config = $$.config;
		return $$.isDonutType(id) ? config.donut_expand_duration : $$.isGaugeType(id) ? config.gauge_expand_duration : $$.isPieType(id) ? config.pie_expand_duration : 50;
	},
	shouldExpand: function shouldExpand(id) {
		var $$ = this,
			config = $$.config;

		return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
	},
	shouldShowArcLabel: function shouldShowArcLabel() {
		var $$ = this,
			config = $$.config,
			shouldShow = !0;

		// when gauge, always true
		return $$.hasType("donut") ? shouldShow = config.donut_label_show : $$.hasType("pie") && (shouldShow = config.pie_label_show), shouldShow;
	},
	meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
		var $$ = this,
			config = $$.config,
			threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;

		return ratio >= threshold;
	},
	getArcLabelFormat: function getArcLabelFormat() {
		var $$ = this,
			config = $$.config,
			format = config.pie_label_format;

		return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
	},
	getGaugeLabelExtents: function getGaugeLabelExtents() {
		var config = this.config;

		return config.gauge_label_extents;
	},
	getArcTitle: function getArcTitle() {
		var $$ = this;

		return $$.hasType("donut") ? $$.config.donut_title : "";
	},
	updateTargetsForArc: function updateTargetsForArc(targets) {
		var $$ = this,
			main = $$.main,
			classChartArc = $$.classChartArc.bind($$),
			classArcs = $$.classArcs.bind($$),
			classFocus = $$.classFocus.bind($$),
			mainPieUpdate = main.select("." + _classes2.default.chartArcs).selectAll("." + _classes2.default.chartArc).data($$.pie(targets)).attr("class", function(d) {
			return classChartArc(d) + classFocus(d.data);
		}),
			mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
		mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", $$.hasType("gauge") ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
	},
	initArc: function initArc() {
		var $$ = this;

		$$.arcs = $$.main.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
	},

	/**
* Set arc title text
* @private
*/
	setArcTitle: function setArcTitle() {
		var $$ = this,
			title = $$.getArcTitle();

		if (title) {
			var multiline = title.split("\n"),
				text = $$.arcs.append("text").attr("class", _classes2.default.chartArcsTitle).style("text-anchor", "middle");

			// if is multiline text
			if (multiline.length > 1) {
				var fontSize = +text.style("font-size").replace("px", ""),
					height = Math.floor(text.text(".").node().getBBox().height, text.text(""));
				multiline.forEach(function (v, i) {
					return text.insert("tspan").text(v).attr("x", 0).attr("dy", i ? height : 0);
				}), text.attr("y", "-" + (fontSize * (multiline.length - 2) || fontSize / 2));
			} else text.text(title);
		}
	},
	redrawArc: function redrawArc(duration, durationForExit, withTransform) {

		function selectArc(_this, arcData, id) {
			$$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
		}

		function unselectArc(arcData) {
			var id = arcData && arcData.id || undefined;

			$$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
		}

		var $$ = this,
			config = $$.config,
			main = $$.main,
			isTouch = $$.inputType === "touch",
			isMouse = $$.inputType === "mouse",
			mainArc = main.selectAll("." + _classes2.default.arcs).selectAll("." + _classes2.default.arc).data($$.arcData.bind($$));

		if (mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function(d) {
			return $$.color(d.data);
		}).style("cursor", function(d) {
			return config.interaction_enabled && (config.data_selection_isselectable(d) ? "pointer" : null);
		}).style("opacity", "0").each(function (d) {
			$$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
		}).merge(mainArc), mainArc.attr("transform", function(d) {
			return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
		}).style("opacity", function(d) {
			return d === this._current ? "0" : "1";
		}).each(function () {
			$$.transiting = !0;
		}).transition().duration(duration).attrTween("d", function(d) {
			var updated = $$.updateAngle(d);

			if (!updated) return function() {
					return "M 0 0";
				};

			isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);

			var interpolate = (0, _d3Interpolate.interpolate)(this._current, updated);

			return this._current = interpolate(0), function(t) {
				var interpolated = interpolate(t);

				// data.id will be updated by interporator
				return interpolated.data = d.data, $$.getArc(interpolated, !0);
			};
		}).attr("transform", withTransform ? "scale(1)" : "").style("fill", function(d) {
			return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
		})
		// Where gauge reading color would receive customization.
		.style("opacity", "1").call($$.endall, function() {
			$$.transiting = !1;
		}), config.interaction_enabled && (mainArc.on("click", function(d, i) {
			var updated = $$.updateAngle(d),
				arcData = void 0;
			updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), $$.config.data_onclick.call($$.api, arcData, this));
		}), isMouse && mainArc.on("mouseover", function(d) {
			if (!$$.transiting) // skip while transiting
				{

					var updated = $$.updateAngle(d),
						arcData = updated ? $$.convertToArcData(updated) : null,
						id = arcData && arcData.id || undefined;
					selectArc(this, arcData, id), $$.config.data_onover(arcData, this);
				}
		}).on("mouseout", function(d) {
			if (!$$.transiting) // skip while transiting
				{
					var updated = $$.updateAngle(d),
						arcData = updated ? $$.convertToArcData(updated) : null;
					unselectArc(), $$.config.data_onout(arcData, this);
				}
		}).on("mousemove", function(d) {
			var updated = $$.updateAngle(d),
				arcData = updated ? $$.convertToArcData(updated) : null;
			$$.showTooltip([arcData], this);
		}), isTouch && $$.hasArcType())) {
				var _getEventArc = function() {
					var touch = _d3Selection.event.changedTouches[0],
						eventArc = (0, _d3Selection.select)(document.elementFromPoint(touch.clientX, touch.clientY));

					return eventArc;
				};

				$$.svg.on("touchstart", function() {
					if (!$$.transiting) // skip while transiting
						{

							var eventArc = _getEventArc(),
								datum = eventArc.datum(),
								updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
								arcData = updated ? $$.convertToArcData(updated) : null,
								id = arcData && arcData.id || undefined;
							id === undefined ? unselectArc() : selectArc(this, arcData, id), $$.config.data_onover(arcData, this);
						}
				}).on("touchend", function() {
					if (!$$.transiting) // skip while transiting
						{

							var eventArc = _getEventArc(),
								datum = eventArc.datum(),
								updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
								arcData = updated ? $$.convertToArcData(updated) : null,
								id = arcData && arcData.id || undefined;
							id === undefined ? unselectArc() : selectArc(this, arcData, id), $$.config.data_onout(arcData, this);
						}
				}).on("touchmove", function() {
					var eventArc = _getEventArc(),
						datum = eventArc.datum(),
						updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
						arcData = updated ? $$.convertToArcData(updated) : null,
						id = arcData && arcData.id || undefined;
					id === undefined ? unselectArc() : selectArc(this, arcData, id);
				});
			}

		var gaugeTextValue = main.selectAll("." + _classes2.default.chartArc).select("text").style("opacity", "0").attr("class", function(d) {
			return $$.isGaugeType(d.data) ? _classes2.default.gaugeValue : "";
		});

		if (config.gauge_fullCircle && gaugeTextValue.attr("dy", "" + Math.round($$.radius / 14)), gaugeTextValue.text($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function(d) {
			return $$.isGaugeType(d.data) ? Math.round($$.radius / 5) + "px" : "";
		}).transition().duration(duration).style("opacity", function(d) {
			return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
		}), main.select("." + _classes2.default.chartArcsTitle).style("opacity", $$.hasType("donut") || $$.hasType("gauge") ? "1" : "0"), $$.hasType("gauge")) {
			var endAngle = (config.gauge_fullCircle ? -4 : -1) * config.gauge_startingAngle;

			$$.arcs.select("." + _classes2.default.chartArcsBackground).attr("d", function() {
				var d = {
					data: [{ value: config.gauge_max }],
					startAngle: config.gauge_startingAngle,
					endAngle: endAngle
				};

				return $$.getArc(d, !0, !0);
			}), $$.arcs.select("." + _classes2.default.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && ($$.arcs.select("." + _classes2.default.chartArcsGaugeMin).attr("dx", -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !config.gauge_fullCircle && $$.arcs.select("." + _classes2.default.chartArcsGaugeMax).attr("dx", $$.innerRadius + ($$.radius - $$.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
		}
	},
	initGauge: function initGauge() {
		var $$ = this,
			config = $$.config,
			arcs = $$.arcs;
		$$.hasType("gauge") && (arcs.append("path").attr("class", _classes2.default.chartArcsBackground), arcs.append("text").attr("class", _classes2.default.chartArcsGaugeUnit).style("text-anchor", "middle").style("pointer-events", "none"), config.gauge_label_show && (arcs.append("text").attr("class", _classes2.default.chartArcsGaugeMin).style("text-anchor", "middle").style("pointer-events", "none"), !config.gauge_fullCircle && arcs.append("text").attr("class", _classes2.default.chartArcsGaugeMax).style("text-anchor", "middle").style("pointer-events", "none")));
	},
	getGaugeLabelHeight: function getGaugeLabelHeight() {
		return this.config.gauge_label_show ? 20 : 0;
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	initBar: function initBar() {
		var $$ = this;

		$$.main.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.chartBars);
	},
	updateTargetsForBar: function updateTargetsForBar(targets) {
		var $$ = this,
			config = $$.config,
			classChartBar = $$.classChartBar.bind($$),
			classBars = $$.classBars.bind($$),
			classFocus = $$.classFocus.bind($$),
			mainBarUpdate = $$.main.select("." + _classes2.default.chartBars).selectAll("." + _classes2.default.chartBar).data(targets).attr("class", function(d) {
			return classChartBar(d) + classFocus(d);
		}),
			mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");

		// Bars for each data
		mainBarEnter.append("g").attr("class", classBars).style("cursor", function(d) {
			return config.data_selection_isselectable(d) ? "pointer" : null;
		});
	},
	updateBar: function updateBar(durationForExit) {
		var $$ = this,
			barData = $$.barData.bind($$),
			classBar = $$.classBar.bind($$),
			initialOpacity = $$.initialOpacity.bind($$),
			color = function(d) {
			return $$.color(d.id);
		};
		$$.mainBar = $$.main.selectAll("." + _classes2.default.bars).selectAll("." + _classes2.default.bar).data(barData), $$.mainBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainBar = $$.mainBar.enter().append("path").attr("class", classBar).style("stroke", color).style("fill", color).merge($$.mainBar).style("opacity", initialOpacity);
	},
	redrawBar: function redrawBar(drawBar, withTransition) {
		return [(withTransition ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
	},
	getBarW: function getBarW(axis, barTargetsNum) {
		var $$ = this,
			config = $$.config,
			w = (0, _util.isNumber)(config.bar_width) ? config.bar_width : barTargetsNum ? axis.tickInterval($$.getMaxDataCount()) * config.bar_width_ratio / barTargetsNum : 0;

		return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;
	},
	getBars: function getBars(i, id) {
		var $$ = this,
			suffix = (0, _util.isValue)(i) ? "-" + i : "";

		return (id ? $$.main.selectAll("." + _classes2.default.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll("." + _classes2.default.bar + suffix);
	},
	expandBars: function expandBars(i, id, reset) {
		var $$ = this;

		reset && $$.unexpandBars(), $$.getBars(i, id).classed(_classes2.default.EXPANDED, !0);
	},
	unexpandBars: function unexpandBars(i) {
		var $$ = this;

		$$.getBars(i).classed(_classes2.default.EXPANDED, !1);
	},
	generateDrawBar: function generateDrawBar(barIndices, isSub) {
		var $$ = this,
			config = $$.config,
			getPoints = $$.generateGetBarPoints(barIndices, isSub);

		return function(d, i) {
			// 4 points that make a bar
			var points = getPoints(d, i),
				indexX = config.axis_rotated ? 1 : 0,
				indexY = +!indexX;

			// switch points if axis is rotated, not applicable for sub chart

			return "M " + points[0][indexX] + "," + points[0][indexY] + "\n\t\t\t\tL " + points[1][indexX] + "," + points[1][indexY] + "\n\t\t\t\tL " + points[2][indexX] + "," + points[2][indexY] + "\n\t\t\t\tL " + points[3][indexX] + "," + points[3][indexY] + " z";
		};
	},
	generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
		var $$ = this,
			axis = isSub ? $$.subXAxis : $$.xAxis,
			barTargetsNum = barIndices.__max__ + 1,
			barW = $$.getBarW(axis, barTargetsNum),
			barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
			barY = $$.getShapeY(!!isSub),
			barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
			yScale = isSub ? $$.getSubYScale : $$.getYScale;

		return function(d, i) {
			var y0 = yScale.call($$, d.id)(0),
				offset = barOffset(d, i) || y0,
				posX = barX(d),
				posY = barY(d); // offset is for stacked bar chart

			// fix posY not to overflow opposite quadrant

			// 4 points that make a bar
			return $$.config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX + barW, posY - (y0 - offset)], [posX + barW, offset]];
		};
	},
	isWithinBar: function isWithinBar(that) {
		var mouse = (0, _d3Selection.mouse)(that),
			list = (0, _util.getRectSegList)(that),
			box = that.getBBox(),
			seg0 = list[0],
			seg1 = list[1],
			x = Math.min(seg0.x, seg1.x),
			y = Math.min(seg0.y, seg1.y),
			w = box.width,
			h = box.height;

		return x - 2 < mouse[0] && mouse[0] < x + w + 2 && y - 2 < mouse[1] && mouse[1] < y + h + 2;
	}
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Array = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initializer
* @private
*/
	initBubble: function initBubble() {
		var $$ = this,
			config = $$.config;
		$$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
	},

	/**
* Get user agent's computed value for the total length of the path in user units
* https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
* @return {Number}
* @private
*/
	getBaseLength: function getBaseLength() {
		var $$ = this;

		return $$.cache.$baseLength || ($$.cache.$baseLength = (0, _d3Array.min)([$$.axes.x.select("path").node().getTotalLength(), $$.axes.y.select("path").node().getTotalLength()])), $$.cache.$baseLength;
	},

	/**
* Get the radius value for bubble circle
* @param {Object} d
* @return {Number}
* @private
	 */
	getBubbleR: function getBubbleR(d) {
		var $$ = this,
			maxR = $$.config.bubble_maxR;
		(0, _util.isFunction)(maxR) ? maxR = maxR(d) : !(0, _util.isNumber)(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);

		var max = (0, _d3Array.max)($$.getMinMaxData().max.map(function (d) {
			return d.value;
		})),
			maxArea = maxR * maxR * Math.PI,
			area = d.value * (maxArea / max);

		return Math.sqrt(area / Math.PI);
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Shape = __webpack_require__(4),
	_d3Selection = __webpack_require__(4),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	initLine: function initLine() {
		var $$ = this;

		$$.main.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.chartLines);
	},
	updateTargetsForLine: function updateTargetsForLine(targets) {
		var $$ = this,
			config = $$.config,
			classChartLine = $$.classChartLine.bind($$),
			classLines = $$.classLines.bind($$),
			classAreas = $$.classAreas.bind($$),
			classCircles = $$.classCircles.bind($$),
			classFocus = $$.classFocus.bind($$),
			mainLineUpdate = $$.main.select("." + _classes2.default.chartLines).selectAll("." + _classes2.default.chartLine).data(targets).attr("class", function(d) {
			return classChartLine(d) + classFocus(d);
		}),
			mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");

		// Lines for each data
		mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function(d) {
			return $$.generateClass(_classes2.default.selectedCircles, d.id);
		}), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function(d) {
			return config.data_selection_isselectable(d) ? "pointer" : null;
		})), targets.forEach(function (t) {
			$$.main.selectAll("." + _classes2.default.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + _classes2.default.selectedCircle).each(function (d) {
				d.value = t.values[d.index].value;
			});
		});
	},
	updateLine: function updateLine(durationForExit) {
		var $$ = this;

		$$.mainLine = $$.main.selectAll("." + _classes2.default.lines).selectAll("." + _classes2.default.line).data($$.lineData.bind($$)), $$.mainLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainLine = $$.mainLine.enter().append("path").attr("class", function(d) {
			var extraLineClass = $$.extraLineClasses(d) ? " " + $$.extraLineClasses(d) : "";

			return $$.classLine.bind($$)(d) + extraLineClass;
		}).style("stroke", $$.color).merge($$.mainLine).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function(d) {
			return $$.isStepType(d) ? "crispEdges" : "";
		}).attr("transform", null);
	},
	redrawLine: function redrawLine(drawLine, withTransition) {
		return [(withTransition ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
	},
	generateDrawLine: function generateDrawLine(lineIndices, isSub) {
		var $$ = this,
			config = $$.config,
			lineConnectNull = config.line_connectNull,
			axisRotated = config.axis_rotated,
			getPoints = $$.generateGetLinePoints(lineIndices, isSub),
			yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
			xValue = function(d) {
			return (isSub ? $$.subxx : $$.xx).call($$, d);
		},
			yValue = function(d, i) {
			return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : $$.isAreaRangeType(d) ? yScaleGetter.call($$, d.id)($$.getAreaRangeData(d, "mid")) : yScaleGetter.call($$, d.id)(d.value);
		},
			line = (0, _d3Shape.line)();

		return line = axisRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
			return d.value !== null;
		})), function(d) {
			var x = isSub ? $$.x : $$.subX,
				y = yScaleGetter.call($$, d.id),
				values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
				x0 = 0,
				y0 = 0,
				path = void 0;

			return $$.isLineType(d) ? config.data_regions[d.id] ? path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getInterpolate(d))(values)) : (values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = axisRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0), path || "M 0 0";
		};
	},
	generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
		// partial duplication of generateGetBarPoints
		var $$ = this,
			config = $$.config,
			lineTargetsNum = lineIndices.__max__ + 1,
			isSub = !!isSubValue,
			x = $$.getShapeX(0, lineTargetsNum, lineIndices, isSub),
			y = $$.getShapeY(isSub),
			lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
			yScale = isSub ? $$.getSubYScale : $$.getYScale;

		return function(d, i) {
			var y0 = yScale.call($$, d.id)(0),
				offset = lineOffset(d, i) || y0,
				posX = x(d),
				posY = y(d); // offset is for stacked area chart

			// fix posY not to overflow opposite quadrant
			config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);

			// 1 point that marks the line position
			var point = [posX, posY - (y0 - offset)];

			return [point, point, // from here and below, needed for compatibility
			point, point];
		};
	},
	lineWithRegions: function lineWithRegions(d, x, y, _regions) {

		function isWithinRegions(withinX, withinRegions) {
			var idx = void 0;

			for (idx = 0; idx < withinRegions.length; idx++) if (withinRegions[idx].start < withinX && withinX <= withinRegions[idx].end) return !0;
			return !1;
		}

		// Check start/end of regions

		// Define svg generator function for region
		function generateM(points) {
			return "M" + points[0][0] + " " + points[0][1] + " " + points[1][0] + " " + points[1][1];
		}

		var $$ = this,
			config = $$.config,
			xOffset = $$.isCategorized() ? .5 : 0,
			regions = [],
			i = void 0,
			j = void 0,
			s = "M",
			sWithRegion = void 0,
			xp = void 0,
			yp = void 0,
			dx = void 0,
			dy = void 0,
			dd = void 0,
			diff = void 0,
			diffx2 = void 0;
		if ((0, _util.isDefined)(_regions)) for (i = 0; i < _regions.length; i++) regions[i] = {}, regions[i].start = (0, _util.isUndefined)(_regions[i].start) ? d[0].x : $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start, regions[i].end = (0, _util.isUndefined)(_regions[i].end) ? d[d.length - 1].x : $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;

		// Set scales
		var xValue = config.axis_rotated ? function(dt) {
			return y(dt.value);
		} : function(dt) {
			return x(dt.x);
		},
			yValue = config.axis_rotated ? function(dt) {
			return x(dt.x);
		} : function(dt) {
			return y(dt.value);
		};

		// Generate
		for (sWithRegion = $$.isTimeSeries() ? function(d0, d1, k, timeseriesDiff) {
			var x0 = d0.x.getTime(),
				xDiff = d1.x - d0.x,
				xv0 = new Date(x0 + xDiff * k),
				xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
				points = void 0;

			return points = config.axis_rotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]], generateM(points);
		} : function(d0, d1, k, otherDiff) {
			var points = void 0;

			return points = config.axis_rotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]], generateM(points);
		}, i = 0; i < d.length; i++)
		// Draw as normal
		if ((0, _util.isUndefined)(regions) || !isWithinRegions(d[i].x, regions)) s += " " + xValue(d[i]) + " " + yValue(d[i]);else for (xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries()), yp = $$.getScale(d[i - 1].value, d[i].value), dx = x(d[i].x) - x(d[i - 1].x), dy = y(d[i].value) - y(d[i - 1].value), dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), diff = 2 / dd, diffx2 = diff * 2, j = diff; j <= 1; j += diffx2) s += sWithRegion(d[i - 1], d[i], j, diff);

		return s;
	},
	updateArea: function updateArea(durationForExit) {
		var $$ = this;

		$$.mainArea = $$.main.selectAll("." + _classes2.default.areas).selectAll("." + _classes2.default.area).data($$.lineData.bind($$)), $$.mainArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainArea = $$.mainArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function() {
			return $$.orgAreaOpacity = (0, _d3Selection.select)(this).style("opacity"), "0";
		}).merge($$.mainArea), $$.mainArea.style("opacity", $$.orgAreaOpacity);
	},
	redrawArea: function redrawArea(drawArea, withTransition) {
		var $$ = this;

		return [(withTransition ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr("d", drawArea).style("fill", this.color).style("opacity", function(d) {
			return $$.isAreaRangeType(d) ? $$.orgAreaOpacity / 1.75 : $$.orgAreaOpacity;
		})];
	},
	generateDrawArea: function generateDrawArea(areaIndices, isSub) {
		var $$ = this,
			config = $$.config,
			lineConnectNull = config.line_connectNull,
			axisRotated = config.axis_rotated,
			getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
			yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
			xValue = function(d) {
			return (isSub ? $$.subxx : $$.xx).call($$, d);
		},
			value0 = function(d, i) {
			return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
		},
			value1 = function(d, i) {
			return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
		};

		return function(d) {
			var values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
				x0 = 0,
				y0 = 0,
				path = void 0;

			if ($$.isAreaType(d)) {
				var isAreaRangeType = $$.isAreaRangeType(d),
					area = (0, _d3Shape.area)();
				area = axisRotated ? isAreaRangeType ? area.x0(function (d) {
					return yScaleGetter.call($$, d.id)($$.getAreaRangeData(d, "high"));
				}).x1(function (d) {
					return yScaleGetter.call($$, d.id)($$.getAreaRangeData(d, "low"));
				}).y(xValue) : area.x0(value0).x1(value1).y(xValue) : isAreaRangeType ? area.x(xValue).y0(function (d) {
					return yScaleGetter.call($$, d.id)($$.getAreaRangeData(d, "high"));
				}).y1(function (d) {
					return yScaleGetter.call($$, d.id)($$.getAreaRangeData(d, "low"));
				}) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
					return d.value !== null;
				})), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getInterpolate(d))(values);
			} else values[0] && (x0 = $$.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = axisRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

			return path || "M 0 0";
		};
	},
	getAreaBaseValue: function getAreaBaseValue() {
		return 0;
	},
	generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
		// partial duplication of generateGetBarPoints
		var $$ = this,
			config = $$.config,
			areaTargetsNum = areaIndices.__max__ + 1,
			x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
			y = $$.getShapeY(!!isSub),
			areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
			yScale = isSub ? $$.getSubYScale : $$.getYScale;

		return function(d, i) {
			var y0 = yScale.call($$, d.id)(0),
				offset = areaOffset(d, i) || y0,
				posX = x(d),
				posY = y(d); // offset is for stacked area chart

			// fix posY not to overflow opposite quadrant

			// 1 point that marks the area position
			return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
			[posX, offset] // needed for compatibility
			];
		};
	},
	updateCircle: function updateCircle() {
		var $$ = this;

		$$.config.point_show && ($$.mainCircle = $$.main.selectAll("." + _classes2.default.circles).selectAll("." + _classes2.default.circle).data($$.lineScatterBubbleData.bind($$)), $$.mainCircle.exit().remove(), $$.mainCircle = $$.mainCircle.enter().append($$.point("create", this, $$.classCircle.bind($$), $$.pointR.bind($$), $$.color)).merge($$.mainCircle).style("opacity", $$.initialOpacityForCircle.bind($$)));
	},
	redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
		var $$ = this,
			selectedCircles = $$.main.selectAll("." + _classes2.default.selectedCircle);

		if (!$$.config.point_show) return [];

		var mainCircles = [];

		$$.mainCircle.each(function (d) {
			var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
				result = fn(d);
			mainCircles.push(result);
		});

		var posAttr = $$.isCirclePoint() ? "c" : "";

		return [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
	},
	circleX: function circleX(d) {
		var $$ = this,
			hasValue = (0, _util.isValue)(d.x);

		return $$.config.zoom_enabled && $$.zoomScale ? hasValue ? $$.zoomScale(d.x) : null : hasValue ? $$.x(d.x) : null;
	},
	updateCircleY: function updateCircleY() {
		var $$ = this,
			lineIndices = void 0,
			getPoints = void 0;
		$$.config.data_groups.length > 0 ? (lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices), $$.circleY = function(d, i) {
			return getPoints(d, i)[0][1];
		}) : $$.circleY = function(d) {
			return $$.isAreaRangeType(d) ? $$.getYScale(d.id)($$.getAreaRangeData(d, "mid")) : $$.getYScale(d.id)(d.value);
		};
	},
	getCircles: function getCircles(i, id) {
		var $$ = this,
			suffix = (0, _util.isValue)(i) ? "-" + i : "";

		return (id ? $$.main.selectAll("." + _classes2.default.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll("." + _classes2.default.circle + suffix);
	},
	expandCircles: function expandCircles(i, id, reset) {
		var $$ = this,
			r = $$.pointExpandedR.bind($$);
		reset && $$.unexpandCircles();

		var circles = $$.getCircles(i, id).classed(_classes2.default.EXPANDED, !0),
			scale = r(circles) / $$.config.point_r;
		$$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
			var point = (0, _d3Selection.select)(this),
				box = this.getBBox(),
				x1 = box.x + box.width * .5,
				y1 = box.y + box.height * .5;

			this.tagName === "circle" ? point.attr("r", r) : point.style("transform", "translate(" + (1 - scale) * x1 + "px, " + (1 - scale) * y1 + "px) scale(" + scale + ")");
		});
	},
	unexpandCircles: function unexpandCircles(i) {
		var $$ = this,
			r = $$.pointR.bind($$),
			circles = $$.getCircles(i).filter(function () {
			return (0, _d3Selection.select)(this).classed(_classes2.default.EXPANDED);
		}).classed(_classes2.default.EXPANDED, !1),
			scale = r(circles) / $$.config.point_r;
		circles.attr("r", r), $$.isCirclePoint() || circles.style("transform", "scale(" + scale + ")");
	},
	pointR: function(d) {
		var $$ = this,
			config = $$.config,
			pointR = config.point_r,
			r = pointR;

		return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : (0, _util.isFunction)(pointR) && (r = pointR(d)), r;
	},
	pointExpandedR: function pointExpandedR(d) {
		var $$ = this,
			config = $$.config,
			scale = $$.isBubbleType(d) ? 1.15 : 1.75;

		return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
	},
	pointSelectR: function pointSelectR(d) {
		var $$ = this,
			selectR = $$.config.point_select_r;

		return (0, _util.isFunction)(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
	},
	isWithinCircle: function isWithinCircle(node, r) {
		var mouse = (0, _d3Selection.mouse)(node),
			element = (0, _d3Selection.select)(node),
			prefix = this.isCirclePoint() ? "c" : "",
			cx = +element.attr(prefix + "x"),
			cy = +element.attr(prefix + "y");

		// if node don't have cx/y or x/y attribute value
		if (!(cx || cy) && node.nodeType === 1) {
			var domRect = node.getBBox ? node.getBBox() : node.getBoundingClientRect();

			cx = domRect.x, cy = domRect.y;
		}

		return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
	},
	isWithinStep: function isWithinStep(that, y) {
		return Math.abs(y - (0, _d3Selection.mouse)(that)[1]) < 30;
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	hasValidPointType: function hasValidPointType(type) {
		return (/^(circle|rect(angle)?|polygon|ellipse)$/i.test(type || this.config.point_type)
		);
	},
	hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
		var pointType = type || this.config.point_type;

		return (0, _util.isObjectType)(pointType) && (0, _util.isFunction)(pointType.create) && (0, _util.isFunction)(pointType.update);
	},
	insertPointInfoDefs: function insertPointInfoDefs(point, id) {
		var $$ = this,
			parser = new DOMParser(),
			doc = parser.parseFromString(point, "image/svg+xml"),
			node = doc.firstChild,
			clone = document.createElementNS(_d3Selection.namespaces.svg, node.nodeName.toLowerCase()),
			attribs = node.attributes;

		for (var i = 0, l = attribs.length; i < l; i++) {
			var name = attribs[i].name;

			clone.setAttribute(name, node.getAttribute(name));
		}

		clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "none", $$.defs.node().appendChild(clone);
	},
	pointFromDefs: function pointFromDefs(id) {
		return this.defs.select("#" + id);
	},
	generatePoint: function generatePoint() {
		var $$ = this,
			config = $$.config,
			ids = [],
			pattern = (0, _util.notEmpty)(config.point_pattern) ? config.point_pattern : [config.point_type];

		return function(method, context) {
			for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

			return function(d) {
				var id = d.id || d.data && d.data.id || d,
					element = (0, _d3Selection.select)(this),
					point = void 0;

				if (ids.indexOf(id) < 0 && ids.push(id), point = pattern[ids.indexOf(id) % pattern.length], $$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
					var pointId = $$.datetimeId + "-point-" + id,
						pointFromDefs = $$.pointFromDefs(pointId);

					if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(undefined, [element, pointId].concat(args));
					if (method === "update") return $$.custom.update.bind(context).apply(undefined, [element].concat(args));
				}

				return point[method].bind(context).apply(undefined, [element].concat(args));
			};
		};
	},
	getTransitionName: function getTransitionName() {
		return Math.random().toString();
	},

	custom: {
		create: function create(element, id, cssClassFn, sizeFn, fillStyleFn) {
			return element.append("use").attr("xlink:href", "#" + id).attr("class", cssClassFn).style("fill", fillStyleFn).node();
		},
		update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
			var $$ = this,
				box = element.node().getBBox(),
				xPosFn2 = function(d) {
				return xPosFn(d) - box.width * .5;
			},
				yPosFn2 = function(d) {
				return yPosFn(d) - box.height * .5;
			},
				mainCircles = element;

			if (withTransition) {
				var transitionName = $$.getTransitionName();

				flow && (mainCircles = element.attr("x", xPosFn2)), mainCircles = element.transition(transitionName).attr("x", xPosFn2).attr("y", yPosFn2).transition(transitionName), selectedCircles.transition($$.getTransitionName());
			} else mainCircles = element.attr("x", xPosFn2).attr("y", yPosFn2);

			return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
		}
	},

	// 'circle' data point
	circle: {
		create: function create(element, cssClassFn, sizeFn, fillStyleFn) {
			return element.append("circle").attr("class", cssClassFn).attr("r", sizeFn).style("fill", fillStyleFn).node();
		},
		update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
			var $$ = this,
				mainCircles = element;

			// when '.load()' called, bubble size should be updated

			if ($$.hasType("bubble") && (mainCircles = mainCircles.attr("r", $$.pointR.bind($$))), withTransition) {
				var transitionName = $$.getTransitionName();

				flow && (mainCircles = mainCircles.attr("cx", xPosFn)), mainCircles = mainCircles.transition(transitionName).attr("cx", xPosFn).attr("cy", yPosFn).transition(transitionName), selectedCircles.transition($$.getTransitionName());
			} else mainCircles = mainCircles.attr("cx", xPosFn).attr("cy", yPosFn);

			return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
		}
	},

	// 'rectangle' data point
	rectangle: {
		create: function create(element, cssClassFn, sizeFn, fillStyleFn) {
			var rectSizeFn = function(d) {
				return sizeFn(d) * 2;
			};

			return element.append("rect").attr("class", cssClassFn).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
		},
		update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
			var $$ = this,
				r = $$.config.point_r,
				rectXPosFn = function(d) {
				return xPosFn(d) - r;
			},
				rectYPosFn = function(d) {
				return yPosFn(d) - r;
			},
				mainCircles = element;

			if (withTransition) {
				var transitionName = $$.getTransitionName();

				flow && (mainCircles = mainCircles.attr("x", rectXPosFn)), mainCircles = mainCircles.transition(transitionName).attr("x", rectXPosFn).attr("y", rectYPosFn).transition(transitionName), selectedCircles.transition($$.getTransitionName());
			} else mainCircles = mainCircles.attr("x", rectXPosFn).attr("y", rectYPosFn);

			return mainCircles.style("opacity", opacityStyleFn).style("fill", fillStyleFn);
		}
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initializes the text
* @private
*/
	initText: function initText() {
		var $$ = this;

		$$.main.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.chartTexts), $$.mainText = (0, _d3Selection.selectAll)([]);
	},

	/**
* Update chartText
* @private
* @param {Object} $$.data.targets
*/
	updateTargetsForText: function updateTargetsForText(targets) {
		var $$ = this,
			classChartText = $$.classChartText.bind($$),
			classTexts = $$.classTexts.bind($$),
			classFocus = $$.classFocus.bind($$),
			mainTextUpdate = $$.main.select("." + _classes2.default.chartTexts).selectAll("." + _classes2.default.chartText).data(targets).attr("class", function(d) {
			return classChartText(d) + classFocus(d);
		}),
			mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
		mainTextEnter.append("g").attr("class", classTexts);
	},

	/**
* Update text
* @private
* @param {Number} Fade-out transition duration
*/
	updateText: function updateText(durationForExit) {
		var $$ = this,
			config = $$.config,
			barLineBubbleData = $$.barLineBubbleData.bind($$),
			classText = $$.classText.bind($$);
		$$.mainText = $$.main.selectAll("." + _classes2.default.texts).selectAll("." + _classes2.default.text).data(barLineBubbleData), $$.mainText.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $$.mainText = $$.mainText.enter().append("text").attr("class", classText).attr("text-anchor", function(d) {
			return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
		}).style("stroke", "none").style("fill", function(d) {
			return $$.color(d);
		}).style("fill-opacity", "0").merge($$.mainText).text(function (d, i, j) {
			return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
		});
	},

	/**
* Redraw chartText
* @private
* @param {Number} x Attribute
* @param {Number} y Attribute
* @param {Object} options.flow
* @param {Boolean} indicates transition is enabled
* @returns {Object} $$.mainText
*/
	redrawText: function redrawText(xForText, yForText, forFlow, withTransition) {
		return [(withTransition ? this.mainText.transition() : this.mainText).attr("x", xForText).attr("y", yForText).style("fill", this.color).style("fill-opacity", forFlow ? 0 : this.opacityForText.bind(this))];
	},

	/**
* Gets the getBoundingClientRect value of the element
* @private
* @param {String} text
* @param {String} class
* @param {HTMLElement} element
* @returns {Object} value of element.getBoundingClientRect()
*/
	getTextRect: function getTextRect(text, cls, element) {
		var dummy = (0, _d3Selection.select)("body").append("div").classed("bb", !0),
			svg = dummy.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px"),
			font = (0, _d3Selection.select)(element).style("font"),
			rect = void 0;

		return svg.selectAll(".dummy").data([text]).enter().append("text").classed(cls ? cls : "", !0).style("font", font).text(text).each(function () {
			rect = this.getBoundingClientRect();
		}), dummy.remove(), rect;
	},

	/**
* Gets the x or y coordinate of the text
* @private
* @param {Object} area Indices
* @param {Object} bar Indices
* @param {Object} line Indices
* @param {Boolean} whether or not to x
* @returns {Number} coordinates
*/
	generateXYForText: function generateXYForText(areaIndices, barIndices, lineIndices, forX) {
		var $$ = this,
			getAreaPoints = $$.generateGetAreaPoints(areaIndices, !1),
			getBarPoints = $$.generateGetBarPoints(barIndices, !1),
			getLinePoints = $$.generateGetLinePoints(lineIndices, !1),
			getter = forX ? $$.getXForText : $$.getYForText;

		return function(d, i) {
			var getPoints = $$.isAreaType(d) && getAreaPoints || $$.isBarType(d) && getBarPoints || getLinePoints;

			return getter.call($$, getPoints(d, i), d, this);
		};
	},

	/**
* Gets the x coordinate of the text
* @private
* @param {Object} points
* @param {Object} data
* @param {HTMLElement} element
* @returns {Number} x coordinate
*/
	getXForText: function getXForText(points, d, textElement) {
		var $$ = this,
			config = $$.config,
			xPos = void 0,
			padding = void 0;

		return config.axis_rotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null && (xPos > $$.width ? xPos = $$.width - textElement.getBoundingClientRect().width : xPos < 0 && (xPos = 4)), xPos + (config.data_labels_position.x || 0);
	},

	/**
* Gets the y coordinate of the text
* @private
* @param {Object} points
* @param {Object} data
* @param {HTMLElement} element
* @returns {Number} y coordinate
*/
	getYForText: function getYForText(points, d, textElement) {
		var $$ = this,
			config = $$.config,
			yPos = void 0;

		if (config.axis_rotated) yPos = (points[0][0] + points[2][0] + textElement.getBoundingClientRect().height * .6) / 2;else if (yPos = points[2][1], d.value < 0 || d.value === 0 && !$$.hasPositiveValue) yPos += textElement.getBoundingClientRect().height, $$.isBarType(d) && $$.isSafari() ? yPos -= 3 : !$$.isBarType(d) && $$.isChrome() && (yPos += 3);else {
				var diff = -6;

				$$.isBarType(d) ? diff = -3 : $$.isBubbleType(d) && (diff = 3), yPos += diff;
			}
		// show labels regardless of the domain if value is null
		if (d.value === null && !config.axis_rotated) {
			var boxHeight = textElement.getBoundingClientRect().height;

			yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
		}

		return yPos + (config.data_labels_position.y || 0);
	}
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	setTargetType: function setTargetType(targetIds, type) {
		var $$ = this,
			config = $$.config;
		$$.mapToTargetIds(targetIds).forEach(function (id) {
			$$.withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
		}), targetIds || (config.data_type = type);
	},
	hasType: function hasType(type, targetsValue) {
		var $$ = this,
			types = $$.config.data_types,
			targets = targetsValue || $$.data.targets,
			has = !1;

		return targets && targets.length ? targets.forEach(function (target) {
			var t = types[target.id];

			(t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
		}) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
			types[id] === type && (has = !0);
		}) : has = $$.config.data_type === type, has;
	},
	hasArcType: function hasArcType(targets) {
		return this.hasType("pie", targets) || this.hasType("donut", targets) || this.hasType("gauge", targets);
	},
	isLineType: function isLineType(d) {
		var id = (0, _util.isString)(d) ? d : d.id;

		return !this.config.data_types[id] || this.isTypeOf(id, ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"]);
	},
	isTypeOf: function isTypeOf(d, type) {
		var id = (0, _util.isString)(d) ? d : d.id,
			dataType = this.config.data_types[id];

		return (0, _util.isArray)(type) ? type.indexOf(dataType) >= 0 : dataType === type;
	},
	isStepType: function isStepType(d) {
		return this.isTypeOf(d, ["step", "area-step"]);
	},
	isSplineType: function isSplineType(d) {
		return this.isTypeOf(d, ["spline", "area-spline", "area-spline-range"]);
	},
	isAreaType: function isAreaType(d) {
		return this.isTypeOf(d, ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"]);
	},
	isAreaRangeType: function isAreaRangeType(d) {
		return this.isTypeOf(d, ["area-spline-range", "area-line-range"]);
	},
	isBarType: function isBarType(d) {
		return this.isTypeOf(d, "bar");
	},
	isBubbleType: function isBubbleType(d) {
		return this.isTypeOf(d, "bubble");
	},
	isScatterType: function isScatterType(d) {
		return this.isTypeOf(d, "scatter");
	},
	isPieType: function isPieType(d) {
		return this.isTypeOf(d, "pie");
	},
	isGaugeType: function isGaugeType(d) {
		return this.isTypeOf(d, "gauge");
	},
	isDonutType: function isDonutType(d) {
		return this.isTypeOf(d, "donut");
	},
	isArcType: function isArcType(d) {
		return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
	},

	// determine if is 'circle' data point
	isCirclePoint: function isCirclePoint() {
		var config = this.config,
			pattern = config.point_pattern;

		return config.point_type === "circle" && (!pattern || (0, _util.isArray)(pattern) && pattern.length === 0);
	},
	lineData: function lineData(d) {
		return this.isLineType(d) ? [d] : [];
	},
	arcData: function arcData(d) {
		return this.isArcType(d.data) ? [d] : [];
	},
	barData: function barData(d) {
		return this.isBarType(d) ? d.values : [];
	},

	// determine if data is line, scatter or bubble type
	lineScatterBubbleData: function lineScatterBubbleData(d) {
		return this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) ? d.values : [];
	},
	barLineBubbleData: function barLineBubbleData(d) {
		return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
	},

	// https://github.com/d3/d3-shape#curves
	isInterpolationType: function isInterpolationType(type) {
		return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
	}
});

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	initGrid: function initGrid() {
		var $$ = this,
			config = $$.config;
		$$.grid = $$.main.append("g").attr("clip-path", $$.clipPathForGrid).attr("class", _classes2.default.grid), config.grid_x_show && $$.grid.append("g").attr("class", _classes2.default.xgrids), config.grid_y_show && $$.grid.append("g").attr("class", _classes2.default.ygrids), config.grid_focus_show && $$.grid.append("g").attr("class", _classes2.default.xgridFocus).append("line").attr("class", _classes2.default.xgridFocus), $$.xgrid = (0, _d3Selection.selectAll)([]), config.grid_lines_front || $$.initGridLines();
	},
	initGridLines: function initGridLines() {
		var $$ = this;

		$$.gridLines = $$.main.append("g").attr("clip-path", $$.clipPathForGrid).attr("class", _classes2.default.grid + " " + _classes2.default.gridLines), $$.gridLines.append("g").attr("class", _classes2.default.xgridLines), $$.gridLines.append("g").attr("class", _classes2.default.ygridLines), $$.xgridLines = (0, _d3Selection.selectAll)([]);
	},
	updateXGrid: function updateXGrid(withoutUpdate) {
		var $$ = this,
			config = $$.config,
			xgridData = $$.generateGridData(config.grid_x_type, $$.x),
			tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;
		$$.xgridAttr = config.axis_rotated ? {
			"x1": 0,
			"x2": $$.width,
			"y1": function y1(d) {
				return $$.x(d) - tickOffset;
			},
			"y2": function y2(d) {
				return $$.x(d) - tickOffset;
			}
		} : {
			"x1": function x1(d) {
				return $$.x(d) + tickOffset;
			},
			"x2": function x2(d) {
				return $$.x(d) + tickOffset;
			},
			"y1": 0,
			"y2": $$.height
		}, $$.xgrid = $$.main.select("." + _classes2.default.xgrids).selectAll("." + _classes2.default.xgrid).data(xgridData), $$.xgrid.exit().remove(), $$.xgrid = $$.xgrid.enter().append("line").attr("class", _classes2.default.xgrid).merge($$.xgrid), withoutUpdate || $$.xgrid.each(function () {
			var grid = (0, _d3Selection.select)(this);

			Object.keys($$.xgridAttr).forEach(function (id) {
				grid.attr(id, $$.xgridAttr[id]).style("opacity", function() {
					return grid.attr(config.axis_rotated ? "y1" : "x1") === (config.axis_rotated ? $$.height : 0) ? "0" : "1";
				});
			});
		});
	},
	updateYGrid: function updateYGrid() {
		var $$ = this,
			config = $$.config,
			gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
		$$.ygrid = $$.main.select("." + _classes2.default.ygrids).selectAll("." + _classes2.default.ygrid).data(gridValues), $$.ygrid.exit().remove(), $$.ygrid = $$.ygrid.enter().append("line").attr("class", _classes2.default.ygrid).merge($$.ygrid), $$.ygrid.attr("x1", config.axis_rotated ? $$.y : 0).attr("x2", config.axis_rotated ? $$.y : $$.width).attr("y1", config.axis_rotated ? 0 : $$.y).attr("y2", config.axis_rotated ? $$.height : $$.y), $$.smoothLines($$.ygrid, "grid");
	},
	gridTextAnchor: function gridTextAnchor(d) {
		return d.position ? d.position : "end";
	},
	gridTextDx: function gridTextDx(d) {
		return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
	},
	xGridTextX: function xGridTextX(d) {
		return d.position === "start" ? -this.height : d.position === "middle" ? -this.height / 2 : 0;
	},
	yGridTextX: function yGridTextX(d) {
		return d.position === "start" ? 0 : d.position === "middle" ? this.width / 2 : this.width;
	},
	updateGrid: function updateGrid(duration) {
		var $$ = this,
			main = $$.main,
			config = $$.config;

		// hide if arc type
		$$.grid.style("visibility", $$.hasArcType() ? "hidden" : "visible"), main.select("line." + _classes2.default.xgridFocus).style("visibility", "hidden"), config.grid_x_show && $$.updateXGrid(), $$.xgridLines = main.select("." + _classes2.default.xgridLines).selectAll("." + _classes2.default.xgridLine).data(config.grid_x_lines), $$.xgridLines.exit().transition().duration(duration).style("opacity", "0").remove();

		// enter
		var xgridLine = $$.xgridLines.enter().append("g").attr("class", function(d) {
			return _classes2.default.xgridLine + (d.class ? " " + d.class : "");
		});

		xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "" : "rotate(-90)").attr("dx", $$.gridTextDx).attr("dy", -5).style("opacity", "0"), $$.xgridLines = xgridLine.merge($$.xgridLines), config.grid_y_show && $$.updateYGrid(), $$.ygridLines = main.select("." + _classes2.default.ygridLines).selectAll("." + _classes2.default.ygridLine).data(config.grid_y_lines), $$.ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();

		// enter
		var ygridLine = $$.ygridLines.enter().append("g").attr("class", function(d) {
			return _classes2.default.ygridLine + (d.class ? " " + d.class : "");
		});

		ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "rotate(-90)" : "").attr("dx", $$.gridTextDx).attr("dy", -5).style("opacity", "0"), $$.ygridLines = ygridLine.merge($$.ygridLines);

		// update
		var yv = $$.yv.bind($$);

		$$.ygridLines.select("line").transition().duration(duration).attr("x1", config.axis_rotated ? yv : 0).attr("x2", config.axis_rotated ? yv : $$.width).attr("y1", config.axis_rotated ? 0 : yv).attr("y2", config.axis_rotated ? $$.height : yv).transition().style("opacity", "1"), $$.ygridLines.select("text").transition().duration(duration).attr("x", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr("y", yv).text(function (d) {
			return d.text;
		}).transition().style("opacity", "1");
	},
	redrawGrid: function redrawGrid(withTransition) {
		var $$ = this,
			rotated = $$.config.axis_rotated,
			xv = $$.xv.bind($$),
			lines = $$.xgridLines.select("line"),
			texts = $$.xgridLines.select("text");

		return lines = (withTransition ? lines.transition() : lines).attr("x1", rotated ? 0 : xv).attr("x2", rotated ? $$.width : xv).attr("y1", rotated ? xv : 0).attr("y2", rotated ? xv : $$.height), texts = (withTransition ? texts.transition() : texts).attr("x", rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr("y", xv).text(function (d) {
			return d.text;
		}), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
	},
	showXGridFocus: function showXGridFocus(selectedData) {
		var $$ = this,
			config = $$.config,
			dataToShow = selectedData.filter(function (d) {
			return d && (0, _util.isValue)(d.value);
		}),
			focusEl = $$.main.selectAll("line." + _classes2.default.xgridFocus),
			xx = $$.xx.bind($$);
		!config.tooltip_show || $$.hasType("bubble") || $$.hasType("scatter") || $$.hasArcType() || (focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(config.axis_rotated ? "y1" : "x1", xx).attr(config.axis_rotated ? "y2" : "x2", xx), $$.smoothLines(focusEl, "grid"));

		// Hide when bubble/scatter plot exists
	},
	hideXGridFocus: function hideXGridFocus() {
		this.main.select("line." + _classes2.default.xgridFocus).style("visibility", "hidden");
	},
	updateXgridFocus: function updateXgridFocus() {
		var $$ = this,
			isRotated = $$.config.axis_rotated;
		$$.main.select("line." + _classes2.default.xgridFocus).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? $$.width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : $$.height);
	},
	generateGridData: function generateGridData(type, scale) {
		var $$ = this,
			tickNum = $$.main.select("." + _classes2.default.axisX).selectAll(".tick").size(),
			gridData = [];

		if (type === "year") {
			var xDomain = $$.getXDomain(),
				firstYear = xDomain[0].getFullYear(),
				lastYear = xDomain[1].getFullYear();

			for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
		} else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
				return (d + "").indexOf(".") < 0;
			}));

		return gridData;
	},
	getGridFilterToRemove: function getGridFilterToRemove(params) {
		return params ? function(line) {
			var found = !1;

			return ((0, _util.isArray)(params) ? params.concat() : [params]).forEach(function (param) {
				("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
			}), found;
		} : function() {
			return !0;
		};
	},
	removeGridLines: function removeGridLines(params, forX) {
		var $$ = this,
			config = $$.config,
			toRemove = $$.getGridFilterToRemove(params),
			classLines = forX ? _classes2.default.xgridLines : _classes2.default.ygridLines,
			classLine = forX ? _classes2.default.xgridLine : _classes2.default.ygridLine;
		$$.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();

		var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";

		config[gridLines] = config[gridLines].filter(function toShow(line) {
			return !toRemove(line);
		});
	}
});

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initializes the tooltip
* @private
*/
	initTooltip: function initTooltip() {
		var $$ = this,
			config = $$.config;

		// Show tooltip if needed
		if ($$.tooltip = $$.selectChart.style("position", "relative").append("div").attr("class", _classes2.default.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none"), config.tooltip_init_show) {
			if ($$.isTimeSeries() && (0, _util.isString)(config.tooltip_init_x)) {
				var i = void 0,
					len = void 0;

				for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0, len = $$.data.targets[0].values.length; i < len && $$.data.targets[0].values[i].x - config.tooltip_init_x !== 0; i++);

				config.tooltip_init_x = i;
			}

			$$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {
				return $$.addName(d.values[config.tooltip_init_x]);
			}), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color)), $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
		}
	},

	/**
* Returns the tooltip content(HTML string)
* @private
* @param {Object} data
* @param {Function} default title format
* @param {Function} default format for each data value in the tooltip.
* @param {Object} $$.color(generateColor())
* @returns {string} html
*/
	getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
		var $$ = this,
			config = $$.config,
			titleFormat = config.tooltip_format_title || defaultTitleFormat,
			nameFormat = config.tooltip_format_name || function(name) {
			return name;
		},
			valueFormat = config.tooltip_format_value || defaultValueFormat,
			order = config.tooltip_order,
			text = void 0,
			title = void 0,
			hiValue = void 0,
			loValue = void 0,
			value = void 0,
			name = void 0,
			bgcolor = void 0,
			getRowValue = function(row) {
			return $$.isAreaRangeType(row) ? $$.getAreaRangeData(row, "mid") : row.value;
		};

		if (order === null && config.data_groups.length) {
			// for stacked data, order should aligned with the visually displayed data
			var ids = $$.orderTargets($$.data.targets).map(function (i2) {
				return i2.id;
			}).reverse();

			d.sort(function (a, b) {
				var v1 = a ? a.value : null,
					v2 = b ? b.value : null;

				return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
			});
		} else if (/^(asc|desc)$/.test(order)) {
			d.sort(function (a, b) {
				var v1 = a ? getRowValue(a) : null,
					v2 = b ? getRowValue(b) : null;

				return order === "asc" ? v1 - v2 : v2 - v1;
			});
		} else (0, _util.isFunction)(order) && d.sort(order);

		for (var row, i = 0, len = d.length; i < len; i++) if ((row = d[i]) && (getRowValue(row) || getRowValue(row) === 0)) {

				var isAreaRangeType = $$.isAreaRangeType(row);

				if (text || (title = (0, _util.sanitise)(titleFormat ? titleFormat(row.x) : row.x), text = title || title === 0 ? "<tr><th colspan=\"2\">" + title + "</th></tr>" : "", text = "<table class=\"" + $$.CLASS.tooltip + "\">" + text), isAreaRangeType && (hiValue = (0, _util.sanitise)(valueFormat($$.getAreaRangeData(row, "high"), row.ratio, row.id, row.index, d)), loValue = (0, _util.sanitise)(valueFormat($$.getAreaRangeData(row, "low"), row.ratio, row.id, row.index, d))), value = (0, _util.sanitise)(valueFormat(getRowValue(row), row.ratio, row.id, row.index, d)), value !== undefined) {
					// Skip elements when their name is set to null
					if (row.name === null) continue;

					name = (0, _util.sanitise)(nameFormat(row.name, row.ratio, row.id, row.index)), bgcolor = $$.levelColor ? $$.levelColor(row.value) : color(row.id), text += "<tr class=\"" + $$.CLASS.tooltipName + $$.getTargetSelectorSuffix(row.id) + "\"><td class=\"name\">", text += $$.patterns ? "<svg><rect style=\"fill:" + bgcolor + "\" width=\"10\" height=\"10\"></rect></svg>" : "<span style=\"background-color:" + bgcolor + "\"></span>", text += name + "</td><td class=\"value\">" + (isAreaRangeType ? "<b>Mid:</b> " + value + " <b>High:</b> " + hiValue + " <b>Low:</b> " + loValue : value) + "</td></tr>";
				}
			}

		return text + "</table>";
	},

	/**
* Returns the position of the tooltip
* @private
* @param {Object} data
* @param {String} width
* @param {String} hHeight
* @param {HTMLElement} element
* @returns {Object} top, left value
*/
	tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
		var $$ = this,
			config = $$.config,
			forArc = $$.hasArcType(),
			isTouch = $$.inputType === "touch",
			mouse = (0, _d3Selection.mouse)(element),
			svgLeft = void 0,
			tooltipLeft = void 0,
			tooltipRight = void 0,
			tooltipTop = void 0,
			chartRight = void 0;

		// Determine tooltip position

		return forArc ? (tooltipLeft = isTouch ? mouse[0] : ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0], tooltipTop = isTouch ? mouse[1] + 20 : $$.height / 2 + mouse[1] + 20) : (svgLeft = $$.getSvgLeft(!0), config.axis_rotated ? (tooltipLeft = svgLeft + mouse[0] + 100, tooltipRight = tooltipLeft + tWidth, chartRight = $$.currentWidth - $$.getCurrentPaddingRight(), tooltipTop = $$.x(dataToShow[0].x) + 20) : (tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(!0) + $$.x(dataToShow[0].x) + 20, tooltipRight = tooltipLeft + tWidth, chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight(), tooltipTop = mouse[1] + 15), tooltipRight > chartRight && (tooltipLeft -= tooltipRight - chartRight + 20), tooltipTop + tHeight > $$.currentHeight && (tooltipTop -= tHeight + 30)), tooltipTop < 0 && (tooltipTop = 0), {
			top: tooltipTop,
			left: tooltipLeft
		};
	},

	/**
* Show the tooltip
* @private
* @param {Object} data
* @param {HTMLElement} element
*/
	showTooltip: function showTooltip(selectedData, element) {
		var $$ = this,
			config = $$.config,
			forArc = $$.hasArcType(),
			dataToShow = selectedData.filter(function (d) {
			return d && (0, _util.isValue)(d.value);
		}),
			positionFunction = config.tooltip_position || $$.tooltipPosition;

		if (dataToShow.length !== 0 && config.tooltip_show) {

				var datum = $$.tooltip.datum(),
					width = datum && datum.width || 0,
					height = datum && datum.height || 0;

				if (!datum || datum.current !== JSON.stringify(selectedData)) {
					var html = config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color);

					(0, _util.isFunction)(config.tooltip_onshow) && config.tooltip_onshow.call($$), $$.tooltip.html(html).style("display", "block").datum({
						current: JSON.stringify(selectedData),
						width: width = $$.tooltip.property("offsetWidth"),
						height: height = $$.tooltip.property("offsetHeight")
					}), (0, _util.isFunction)(config.tooltip_onshown) && config.tooltip_onshown.call($$), $$._handleLinkedCharts(!0, selectedData[0].x);
				}

				// Get tooltip dimensions
				var position = positionFunction.call(this, dataToShow, width, height, element);

				// Set tooltip position
				$$.tooltip.style("top", position.top + "px").style("left", position.left + "px");
			}
	},

	/**
* Hide the tooltip
* @private
*/
	hideTooltip: function hideTooltip() {
		var $$ = this,
			config = $$.config;
		(0, _util.isFunction)(config.tooltip_onhide) && config.tooltip_onhide.call($$), this.tooltip.style("display", "none").datum(null), (0, _util.isFunction)(config.tooltip_onhidden) && config.tooltip_onhidden.call($$), $$._handleLinkedCharts(!1);
	},

	/**
* Toggle display for linked chart instances
* @param {Boolean} show true: show, false: hide
* @param {Number} x x Axis coordinate
* @private
*/
	_handleLinkedCharts: function _handleLinkedCharts(show, x) {
		var $$ = this;

		$$.config.tooltip_linked && $$.api.internal.charts.forEach(function (c) {
			var isInDom = document.body.contains(c.element);

			if (c !== $$.api && isInDom) {
				var isShowing = c.internal.tooltip.style("display") === "block";

				isShowing && !show ? c.tooltip.hide() : !isShowing && show && c.tooltip.show({ x: x });
			}
		});
	}
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initialize the legend.
* @private
*/
	initLegend: function initLegend() {
		var $$ = this,
			config = $$.config;
		$$.legendItemTextBox = {}, $$.legendHasRendered = !1, $$.legend = $$.svg.append("g"), config.legend_show ? config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : ($$.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegendWithDefaults()) : ($$.legend.style("visibility", "hidden"), $$.hiddenLegendIds = $$.mapToIds($$.data.targets));
	},

	/**
* Update legend using template option
* @private
*/
	updateLegendTemplate: function updateLegendTemplate() {
		var $$ = this,
			config = $$.config,
			wrapper = (0, _d3Selection.select)(config.legend_contents_bindto),
			template = config.legend_contents_template;

		if (!wrapper.empty()) {
			var targets = $$.data.targets,
				ids = [],
				html = "";
			$$.mapToIds(targets).forEach(function (v) {
				var content = (0, _util.isFunction)(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : template.replace(/{=COLOR}/g, $$.color(v)).replace(/{=TITLE}/g, v);

				content && (ids.push(v), html += content);
			});

			var legendItem = wrapper.html(html).selectAll(function () {
				return this.childNodes;
			}).data(ids);

			$$.setLegendItem(legendItem);
		}
	},

	/**
* Update the legend to its default value.
* @private
*/
	updateLegendWithDefaults: function updateLegendWithDefaults() {
		var $$ = this;

		$$.updateLegend($$.mapToIds($$.data.targets), {
			withTransform: !1,
			withTransitionForTransform: !1,
			withTransition: !1
		});
	},

	/**
* Update the size of the legend.
* @private
* @param {Number} height
* @param {Number} width
*/
	updateSizeForLegend: function updateSizeForLegend(legendHeight, legendWidth) {
		var $$ = this,
			config = $$.config,
			insetLegendPosition = {
			top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,
			left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
		};
		$$.margin3 = {
			top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,
			right: NaN,
			bottom: 0,
			left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0
		};
	},

	/**
* Transform Legend
* @private
* @param {Boolean} whether or not to transition.
*/
	transformLegend: function transformLegend(withTransition) {
		var $$ = this;

		(withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate("legend"));
	},

	/**
* Update the legend step
* @private
* @param {Number} step
*/
	updateLegendStep: function updateLegendStep(step) {
		this.legendStep = step;
	},

	/**
* Update legend item width
* @private
* @param {Number} width
*/
	updateLegendItemWidth: function updateLegendItemWidth(w) {
		this.legendItemWidth = w;
	},

	/**
* Update legend item height
* @private
* @param {Number} height
*/
	updateLegendItemHeight: function updateLegendItemHeight(h) {
		this.legendItemHeight = h;
	},

	/**
* Get the width of the legend
* @private
* @param {Number} width
*/
	getLegendWidth: function getLegendWidth() {
		var $$ = this;

		return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
	},

	/**
* Get the height of the legend
* @private
* @param {Number} height
*/
	getLegendHeight: function getLegendHeight() {
		var $$ = this,
			h = 0;

		return $$.config.legend_show && ($$.isLegendRight ? h = $$.currentHeight : h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1)), h;
	},

	/**
* Get the opacity of the legend
* @private
* @param {Object} d3.Select
* @returns {Number} opacity
*/
	opacityForLegend: function opacityForLegend(legendItem) {
		return legendItem.classed(_classes2.default.legendItemHidden) ? null : "1";
	},

	/**
* Get the opacity of the legend that is unfocused
* @private
* @param {Object} legendItem, d3.Select
* @returns {Number} opacity
*/
	opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
		return legendItem.classed(_classes2.default.legendItemHidden) ? null : "0.3";
	},

	/**
* Toggles the focus of the legend
* @private
* @param {Array} ID's of target
* @param {Boolean} whether or not to focus.
*/
	toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
		var $$ = this,
			targetIdz = $$.mapToTargetIds(targetIds);
		$$.legend.selectAll("." + _classes2.default.legendItem).filter(function (id) {
			return targetIdz.indexOf(id) >= 0;
		}).classed(_classes2.default.legendItemFocused, focus).transition().duration(100).style("opacity", function() {
			var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;

			return opacity.call($$, (0, _d3Selection.select)(this));
		});
	},

	/**
* Revert the legend to its default state
* @private
*/
	revertLegend: function revertLegend() {
		var $$ = this;

		$$.legend.selectAll("." + _classes2.default.legendItem).classed(_classes2.default.legendItemFocused, !1).transition().duration(100).style("opacity", function() {
			return $$.opacityForLegend((0, _d3Selection.select)(this));
		});
	},

	/**
* Shows the legend
* @private
* @param {Array} ID's of target
*/
	showLegend: function showLegend(targetIds) {
		var $$ = this,
			config = $$.config;
		config.legend_show || (config.legend_show = !0, $$.legend.style("visibility", "visible"), !$$.legendHasRendered && $$.updateLegendWithDefaults()), $$.removeHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function() {
			return $$.opacityForLegend((0, _d3Selection.select)(this));
		});
	},

	/**
* Hide the legend
* @private
* @param {Array} ID's of target
*/
	hideLegend: function hideLegend(targetIds) {
		var $$ = this,
			config = $$.config;
		config.legend_show && (0, _util.isEmpty)(targetIds) && (config.legend_show = !1, $$.legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
	},

	/**
* Clear the LegendItemTextBox cache.
* @private
*/
	clearLegendItemTextBoxCache: function clearLegendItemTextBoxCache() {
		this.legendItemTextBox = {};
	},

	/**
* Set legend item style & bind events
* @private
* @param {d3.selection} item
*/
	setLegendItem: function setLegendItem(item) {
		var $$ = this,
			config = $$.config,
			isTouch = $$.inputType === "touch";
		item.attr("class", function(id) {
			return $$.generateClass(_classes2.default.legendItem, id);
		}).style("visibility", function(id) {
			return $$.isLegendToShow(id) ? "visible" : "hidden";
		}).style("cursor", "pointer").on("click", function(id) {
			(0, _util.isFunction)(config.legend_item_onclick) ? config.legend_item_onclick.call($$, id) : _d3Selection.event.altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert()), isTouch && $$.hideTooltip();
		}), isTouch || item.on("mouseout", function(id) {
			(0, _util.isFunction)(config.legend_item_onout) ? config.legend_item_onout.call($$, id) : ((0, _d3Selection.select)(this).classed(_classes2.default.legendItemFocused, !1), $$.api.revert());
		}).on("mouseover", function(id) {
			(0, _util.isFunction)(config.legend_item_onover) ? config.legend_item_onover.call($$, id) : ((0, _d3Selection.select)(this).classed(_classes2.default.legendItemFocused, !0), !$$.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
		});
	},

	/**
* Update the legend
* @private
* @param {Array} ID's of target
* @param {Object} withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
* @param {Object} the return value of the generateTransitions
*/
	updateLegend: function updateLegend(targetIds, options, transitions) {
		var $$ = this,
			config = $$.config,
			tileWidth = config.legend_item_tile_width + 5,
			maxWidth = 0,
			maxHeight = 0,
			xForLegend = void 0,
			yForLegend = void 0,
			totalLength = 0,
			offsets = {},
			widths = {},
			heights = {},
			margins = [0],
			steps = {},
			step = 0,
			background = void 0,
			isLegendRightOrInset = $$.isLegendRight || $$.isLegendInset,
			targetIdz = targetIds.filter(function (id) {
			return !(0, _util.isDefined)(config.data_names[id]) || config.data_names[id] !== null;
		}),
			optionz = options || {},
			withTransition = (0, _util.getOption)(optionz, "withTransition", !0),
			withTransitionForTransform = (0, _util.getOption)(optionz, "withTransitionForTransform", !0),
			getTextBox = function(textElement, id) {

			return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, _classes2.default.legendItem, textElement)), $$.legendItemTextBox[id];
		},
			updatePositions = function(textElement, id, index) {
			var isLast = index === targetIdz.length - 1,
				box = getTextBox(textElement, id),
				itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
				itemHeight = box.height + 4,
				itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
				areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
				margin = void 0,
				updateValues = function(id2, withoutStep) {
				withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < 10 && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = $$.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
			};

			// MEMO: care about condifion of step, totalLength

			if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);

			widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);

			var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;

			config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
				return widths[id2] = maxWidth;
			}), Object.keys(heights).forEach(function (id2) {
				return heights[id2] = maxHeight;
			}), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < 10 ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
				return updateValues(id2);
			})) : updateValues(id, !0)) : updateValues(id);
		};

		// Skip elements when their name is set to null
		$$.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), $$.isLegendRight ? (xForLegend = function(id) {
			return maxWidth * steps[id];
		}, yForLegend = function(id) {
			return margins[steps[id]] + offsets[id];
		}) : $$.isLegendInset ? (xForLegend = function(id) {
			return maxWidth * steps[id] + 10;
		}, yForLegend = function(id) {
			return margins[steps[id]] + offsets[id];
		}) : (xForLegend = function(id) {
			return margins[steps[id]] + offsets[id];
		}, yForLegend = function(id) {
			return maxHeight * steps[id];
		});

		var xForLegendText = function(id, i) {
			return xForLegend(id, i) + 4 + config.legend_item_tile_width;
		},
			yForLegendText = function(id, i) {
			return yForLegend(id, i) + 9;
		},
			xForLegendRect = function(id, i) {
			return xForLegend(id, i);
		},
			yForLegendRect = function(id, i) {
			return yForLegend(id, i) - 5;
		},
			x1ForLegendTile = function(id, i) {
			return xForLegend(id, i) - 2;
		},
			x2ForLegendTile = function(id, i) {
			return xForLegend(id, i) - 2 + config.legend_item_tile_width;
		},
			yForLegendTile = function(id, i) {
			return yForLegend(id, i) + 4;
		},
			l = $$.legend.selectAll("." + _classes2.default.legendItem).data(targetIdz).enter().append("g");

		// Define g for legend area
		$$.setLegendItem(l), l.append("text").text(function (id) {
			return (0, _util.isDefined)(config.data_names[id]) ? config.data_names[id] : id;
		}).each(function (id, i) {
			updatePositions(this, id, i);
		}).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : -200).attr("y", isLegendRightOrInset ? -200 : yForLegendText), l.append("rect").attr("class", _classes2.default.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : -200).attr("y", isLegendRightOrInset ? -200 : yForLegendRect);

		var usePoint = $$.config.legend_usePoint;

		if (usePoint) {
			var ids = [];

			l.append(function (d) {
				var pattern = (0, _util.notEmpty)(config.point_pattern) ? config.point_pattern : [config.point_type];

				ids.indexOf(d) === -1 && ids.push(d);

				var point = pattern[ids.indexOf(d) % pattern.length];

				return point === "rectangle" && (point = "rect"), document.createElementNS(_d3Selection.namespaces.svg, $$.hasValidPointType(point) ? point : "use");
			}).attr("class", _classes2.default.legendItemPoint).style("fill", function(d) {
				return $$.color(d);
			}).style("pointer-events", "none").attr("href", function(data, idx, selection) {
				var node = selection[idx],
					nodeName = node.nodeName.toLowerCase();

				return nodeName === "use" ? "#" + $$.datetimeId + "-point-" + data : undefined;
			});
		} else l.append("line").attr("class", _classes2.default.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : -200).attr("y1", isLegendRightOrInset ? -200 : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : -200).attr("y2", isLegendRightOrInset ? -200 : yForLegendTile).attr("stroke-width", config.legend_item_tile_height);

		// Set background for inset legend
		background = $$.legend.select("." + _classes2.default.legendBackground + " rect"), $$.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = $$.legend.insert("g", "." + _classes2.default.legendItem).attr("class", _classes2.default.legendBackground).append("rect"));

		var texts = $$.legend.selectAll("text").data(targetIdz).text(function (id) {
			return (0, _util.isDefined)(config.data_names[id]) ? config.data_names[id] : id;
		}) // MEMO: needed for update
		.each(function (id, i) {
			updatePositions(this, id, i);
		});

		(withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);

		var rects = $$.legend.selectAll("rect." + _classes2.default.legendItemEvent).data(targetIdz);

		if ((withTransition ? rects.transition() : rects).attr("width", function(id) {
			return widths[id];
		}).attr("height", function(id) {
			return heights[id];
		}).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
			var tiles = $$.legend.selectAll("." + _classes2.default.legendItemPoint).data(targetIdz);

			(withTransition ? tiles.transition() : tiles).each(function () {
				var nodeName = this.nodeName.toLowerCase(),
					pointR = $$.config.point_r,
					x = "x",
					y = "y",
					xOffset = 2,
					yOffset = 2.5,
					radius = void 0,
					width = void 0,
					height = void 0;

				if (nodeName === "circle") {
					var size = pointR * .2;

					x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
				} else if (nodeName === "rect") {
					var _size = pointR * 2.5;

					width = _size, height = _size, yOffset = 3;
				}

				(0, _d3Selection.select)(this).attr(x, function(d) {
					return x1ForLegendTile(d) + xOffset;
				}).attr(y, function(d) {
					return yForLegendTile(d) - yOffset;
				}).attr("r", radius).attr("width", width).attr("height", height);
			});
		} else {
			var _tiles = $$.legend.selectAll("line." + _classes2.default.legendItemTile).data(targetIdz);

			(withTransition ? _tiles.transition() : _tiles).style("stroke", $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
		}

		background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.legend.selectAll("." + _classes2.default.legendItem).classed(_classes2.default.legendItemHidden, function(id) {
			return !$$.isTargetToShow(id);
		}), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step), $$.updateSizes(), $$.updateScales(!withTransition), $$.updateSvgSize(), $$.transformAll(withTransitionForTransform, transitions), $$.legendHasRendered = !0;
	}
});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initializes the title
* @private
*/
	initTitle: function initTitle() {
		var $$ = this;

		$$.title = $$.svg.append("text").text($$.config.title_text).attr("class", $$.CLASS.title);
	},

	/**
* Redraw title
* @private
*/
	redrawTitle: function redrawTitle() {
		var $$ = this;

		$$.title.attr("x", $$.xForTitle.bind($$)).attr("y", $$.yForTitle.bind($$));
	},

	/**
* Returns the x attribute value of the title
* @private
* @returns {Number} x attribute value
*/
	xForTitle: function xForTitle() {
		var $$ = this,
			config = $$.config,
			position = config.title_position || "left",
			x = void 0;

		return x = position.indexOf("right") >= 0 ? $$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width - config.title_padding.right : position.indexOf("center") >= 0 ? ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2 : config.title_padding.left, x;
	},

	/**
* Returns the y attribute value of the title
* @private
* @returns {Number} y attribute value
*/
	yForTitle: function yForTitle() {
		var $$ = this;

		return $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height;
	},

	/**
* Get title padding
* @private
* @returns {Number} padding value
*/
	getTitlePadding: function getTitlePadding() {
		var $$ = this;

		return $$.yForTitle() + $$.config.title_padding.bottom;
	}
});

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	getClipPath: function getClipPath(id) {
		var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;

		return "url(" + (isIE9 ? "" : document.URL.split("#")[0]) + "#" + id + ")";
	},
	appendClip: function appendClip(parent, id) {
		return parent.append("clipPath").attr("id", id).append("rect");
	},
	getAxisClipX: function getAxisClipX(forHorizontal) {
		// axis line width + padding for left
		var left = Math.max(30, this.margin.left);

		return forHorizontal ? -(1 + left) : -(left - 1);
	},
	getAxisClipY: function getAxisClipY(forHorizontal) {
		return forHorizontal ? -20 : -this.margin.top;
	},
	getXAxisClipX: function getXAxisClipX() {
		var $$ = this;

		return $$.getAxisClipX(!$$.config.axis_rotated);
	},
	getXAxisClipY: function getXAxisClipY() {
		var $$ = this;

		return $$.getAxisClipY(!$$.config.axis_rotated);
	},
	getYAxisClipX: function getYAxisClipX() {
		var $$ = this;

		return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
	},
	getYAxisClipY: function getYAxisClipY() {
		var $$ = this;

		return $$.getAxisClipY($$.config.axis_rotated);
	},
	getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
		var $$ = this,
			left = Math.max(30, $$.margin.left),
			right = Math.max(30, $$.margin.right);

		// width + axis line width + padding for left/right
		return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
	},
	getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
		// less than 20 is not enough to show the axis label 'outer' without legend
		return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
	},
	getXAxisClipWidth: function getXAxisClipWidth() {
		var $$ = this;

		return $$.getAxisClipWidth(!$$.config.axis_rotated);
	},
	getXAxisClipHeight: function getXAxisClipHeight() {
		var $$ = this;

		return $$.getAxisClipHeight(!$$.config.axis_rotated);
	},
	getYAxisClipWidth: function getYAxisClipWidth() {
		var $$ = this;

		return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
	},
	getYAxisClipHeight: function getYAxisClipHeight() {
		var $$ = this;

		return $$.getAxisClipHeight($$.config.axis_rotated);
	}
});

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	initRegion: function initRegion() {
		var $$ = this;

		$$.region = $$.main.append("g").attr("clip-path", $$.clipPath).attr("class", _classes2.default.regions);
	},
	updateRegion: function updateRegion(duration) {
		var $$ = this,
			config = $$.config;

		// hide if arc type
		$$.region.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.mainRegion = $$.main.select("." + _classes2.default.regions).selectAll("." + _classes2.default.region).data(config.regions), $$.mainRegion.exit().transition().duration(duration).style("opacity", "0").remove(), $$.mainRegion = $$.mainRegion.enter().append("g").merge($$.mainRegion).attr("class", $$.classRegion.bind($$)), $$.mainRegion.append("rect").style("fill-opacity", "0");
	},
	redrawRegion: function redrawRegion(withTransition) {
		var $$ = this,
			x = $$.regionX.bind($$),
			y = $$.regionY.bind($$),
			w = $$.regionWidth.bind($$),
			h = $$.regionHeight.bind($$),
			regions = $$.mainRegion.select("rect");

		return regions = (withTransition ? regions.transition() : regions).attr("x", x).attr("y", y).attr("width", w).attr("height", h), [(withTransition ? regions.transition() : regions).style("fill-opacity", function(d) {
			return (0, _util.isValue)(d.opacity) ? d.opacity : "0.1";
		}).on("end", function() {
			(0, _d3Selection.select)(this.parentNode).selectAll("rect:not([x])").remove();
		})];
	},
	regionX: function regionX(d) {
		var $$ = this,
			config = $$.config,
			yScale = d.axis === "y" ? $$.y : $$.y2,
			xPos = void 0;

		return xPos = d.axis === "y" || d.axis === "y2" ? config.axis_rotated ? "start" in d ? yScale(d.start) : 0 : 0 : config.axis_rotated ? 0 : "start" in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0, xPos;
	},
	regionY: function regionY(d) {
		var $$ = this,
			config = $$.config,
			yScale = d.axis === "y" ? $$.y : $$.y2,
			yPos = void 0;

		return yPos = d.axis === "y" || d.axis === "y2" ? config.axis_rotated ? 0 : "end" in d ? yScale(d.end) : 0 : config.axis_rotated ? "start" in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0 : 0, yPos;
	},
	regionWidth: function regionWidth(d) {
		var $$ = this,
			config = $$.config,
			yScale = d.axis === "y" ? $$.y : $$.y2,
			start = $$.regionX(d),
			end = void 0;

		return end = d.axis === "y" || d.axis === "y2" ? config.axis_rotated ? "end" in d ? yScale(d.end) : $$.width : $$.width : config.axis_rotated ? $$.width : "end" in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width, end < start ? 0 : end - start;
	},
	regionHeight: function regionHeight(d) {
		var $$ = this,
			config = $$.config,
			start = this.regionY(d),
			end = void 0,
			yScale = d.axis === "y" ? $$.y : $$.y2;

		return end = d.axis === "y" || d.axis === "y2" ? config.axis_rotated ? $$.height : "start" in d ? yScale(d.start) : $$.height : config.axis_rotated ? "end" in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height : $$.height, end < start ? 0 : end - start;
	},
	isRegionOnX: function isRegionOnX(d) {
		return !d.axis || d.axis === "x";
	}
}); // selection

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Called when dragging.
* Data points can be selected.
* @private
* @param {Object} mouse Object
*/
	drag: function drag(mouse) {
		var $$ = this,
			config = $$.config,
			main = $$.main;
		// do nothing if not selectable
		// skip when single selection because drag is used for multiple selection

		if (!$$.hasArcType() && config.data_selection_enabled && (!config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple) // skip if zoomable because of conflict drag dehavior
			{
				var sx = $$.dragStart[0],
					sy = $$.dragStart[1],
					mx = mouse[0],
					my = mouse[1],
					minX = Math.min(sx, mx),
					maxX = Math.max(sx, mx),
					minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my),
					maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);
				main.select("." + _classes2.default.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + _classes2.default.shapes).selectAll("." + _classes2.default.shape).filter(function (d) {
					return config.data_selection_isselectable(d);
				}).each(function (d, i) {
					var shape = (0, _d3Selection.select)(this),
						isSelected = shape.classed(_classes2.default.SELECTED),
						isIncluded = shape.classed(_classes2.default.INCLUDED),
						_x = void 0,
						_y = void 0,
						_w = void 0,
						_h = void 0,
						toggle = void 0,
						isWithin = !1,
						box = void 0;

					if (shape.classed(_classes2.default.circle)) _x = shape.attr("cx") * 1, _y = shape.attr("cy") * 1, toggle = $$.togglePoint, isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;else if (shape.classed(_classes2.default.bar)) box = (0, _util.getPathBox)(this), _x = box.x, _y = box.y, _w = box.width, _h = box.height, toggle = $$.togglePath, isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);else
						// line/area selection not supported yet
						return;
					isWithin ^ isIncluded && (shape.classed(_classes2.default.INCLUDED, !isIncluded), shape.classed(_classes2.default.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
				});
			}
	},

	/**
* Called when the drag starts.
* Adds and Shows the drag area.
* @private
* @param {Object} mouse Object
*/
	dragstart: function dragstart(mouse) {
		var $$ = this,
			config = $$.config;
		// do nothing if not selectable
		$$.hasArcType() || !config.data_selection_enabled || ($$.dragStart = mouse, $$.main.select("." + _classes2.default.chart).append("rect").attr("class", _classes2.default.dragarea).style("opacity", "0.1"), $$.dragging = !0);
	},

	/**
* Called when the drag finishes.
* Removes the drag area.
* @private
*/
	dragend: function dragend() {
		var $$ = this,
			config = $$.config;
		// do nothing if not selectable
		$$.hasArcType() || !config.data_selection_enabled || ($$.main.select("." + _classes2.default.dragarea).transition().duration(100).style("opacity", "0").remove(), $$.main.selectAll("." + _classes2.default.shape).classed(_classes2.default.INCLUDED, !1), $$.dragging = !1);
	}
});

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_d3Color = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Select a point
* @private
* @param {Object} target point
* @param {Object} data
* @param {Number} index
*/
	selectPoint: function selectPoint(target, d, i) {
		var $$ = this,
			config = $$.config,
			cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
			cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),
			r = $$.pointSelectR.bind($$);
		config.data_onselected.call($$.api, d, target.node()), $$.main.select("." + _classes2.default.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + _classes2.default.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function() {
			return $$.generateClass(_classes2.default.selectedCircle, i);
		}).attr("cx", cx).attr("cy", cy).attr("stroke", function() {
			return $$.color(d);
		}).attr("r", function(d2) {
			return $$.pointSelectR(d2) * 1.4;
		}).transition().duration(100).attr("r", r);
	},

	/**
* Unelect a point
* @private
* @param {Object} target point
* @param {Object} data
* @param {Number} index
*/
	unselectPoint: function unselectPoint(target, d, i) {
		var $$ = this;

		$$.config.data_onunselected.call($$.api, d, target.node()), $$.main.select("." + _classes2.default.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + _classes2.default.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
	},

	/**
* Toggles the selection of points
* @private
* @param {Boolean} whether or not to select.
* @param {Object} target point
* @param {Object} data
* @param {Number} index
*/
	togglePoint: function togglePoint(selected, target, d, i) {
		selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
	},

	/**
* Select a path
* @private
* @param {Object} target path
* @param {Object} data
*/
	selectPath: function selectPath(target, d) {
		var $$ = this;

		$$.config.data_onselected.call($$, d, target.node()), $$.config.interaction_brighten && target.transition().duration(100).style("fill", function() {
			return (0, _d3Color.rgb)($$.color(d)).brighter(.75);
		});
	},

	/**
* Unelect a path
* @private
* @param {Object} target path
* @param {Object} data
*/
	unselectPath: function unselectPath(target, d) {
		var $$ = this;

		$$.config.data_onunselected.call($$, d, target.node()), $$.config.interaction_brighten && target.transition().duration(100).style("fill", function() {
			return $$.color(d);
		});
	},

	/**
* Toggles the selection of lines
* @private
* @param {Boolean} whether or not to select.
* @param {Object} target shape
* @param {Object} data
* @param {Number} index
*/
	togglePath: function togglePath(selected, target, d, i) {
		selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
	},

	/**
* Returns the toggle method of the target
* @private
* @param {Object} target shape
* @param {Object} data
* @returns {Function} toggle method
*/
	getToggle: function getToggle(that, d) {
		var $$ = this,
			toggle = void 0;

		return that.nodeName === "path" ? that.nodeName === "path" && (toggle = $$.togglePath) : $$.isStepType(d) ? toggle = function() {} : toggle = $$.togglePoint, toggle;
	},

	/**
* Toggles the selection of shapes
* @private
* @param {Object} target shape
* @param {Object} data
* @param {Number} index
*/
	toggleShape: function toggleShape(that, d, i) {
		var $$ = this,
			config = $$.config,
			shape = (0, _d3Selection.select)(that),
			isSelected = shape.classed(_classes2.default.SELECTED),
			toggle = $$.getToggle(that, d).bind($$),
			toggledShape = void 0;

		if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
			if (!config.data_selection_multiple) {
				var selecter = "." + _classes2.default.shapes;

				config.data_selection_grouped && (selecter = "." + selecter + $$.getTargetSelectorSuffix(d.id)), $$.main.selectAll("" + selecter).selectAll("." + _classes2.default.shape).each(function (d, i) {
					var shape = (0, _d3Selection.select)(this);

					shape.classed(_classes2.default.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(_classes2.default.SELECTED, !1), d, i));
				});
			}

			toggledShape && toggledShape.node() === shape.node() || (shape.classed(_classes2.default.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
		}
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_d3Brush = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initialize the brush.
* @private
*/
	initBrush: function initBrush() {
		var $$ = this;

		// set the brush
		$$.brush = $$.config.axis_rotated ? (0, _d3Brush.brushY)() : (0, _d3Brush.brushX)();

		// set "brush" event
		var brushHandler = function() {
			$$.redrawForBrush();
		};

		$$.brush.on("start", function() {
			$$.inputType === "touch" && $$.hideTooltip(), brushHandler();
		}).on("brush", brushHandler), $$.brush.update = function() {
			var extent = this.extent()();

			return extent[1].filter(function (v) {
				return isNaN(v);
			}).length === 0 && $$.context && $$.context.select("." + _classes2.default.brush).call(this), this;
		}, $$.brush.scale = function(scale, height) {
			var overlay = $$.svg.select(".bb-brush .overlay"),
				extent = [[0, 0]];
			scale.range ? extent.push([scale.range()[1], (height || !overlay.empty()) && ~~overlay.attr("height") || 60]) : scale.constructor === Array && extent.push(scale), $$.config.axis_rotated && extent.reverse(), this.extent($$.config.axis_x_extent || extent), this.update();
		}, $$.brush.getSelection = function() {
			return $$.context ? $$.context.select("." + _classes2.default.brush) : (0, _d3Selection.select)([]);
		};
	},

	/**
* Initialize the subchart.
* @private
*/
	initSubchart: function initSubchart() {
		var $$ = this,
			config = $$.config,
			visibility = config.subchart_show ? "visible" : "hidden";
		$$.context = $$.svg.append("g").attr("transform", $$.getTranslate("context"));

		var context = $$.context;

		context.style("visibility", visibility), context.append("g").attr("clip-path", $$.clipPathForSubchart).attr("class", _classes2.default.chart), context.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.chartBars), context.select("." + _classes2.default.chart).append("g").attr("class", _classes2.default.chartLines), context.append("g").attr("clip-path", $$.clipPath).attr("class", _classes2.default.brush).call($$.brush), $$.axes.subx = context.append("g").attr("class", _classes2.default.axisX).attr("transform", $$.getTranslate("subx")).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
	},

	/**
* Update sub chart
* @private
* @param {Object} $$.data.targets
*/
	updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
		var $$ = this,
			context = $$.context,
			config = $$.config,
			classChartBar = $$.classChartBar.bind($$),
			classBars = $$.classBars.bind($$),
			classChartLine = $$.classChartLine.bind($$),
			classLines = $$.classLines.bind($$),
			classAreas = $$.classAreas.bind($$);

		if (config.subchart_show) {
			// -- Bar --//
			var contextBarUpdate = context.select("." + _classes2.default.chartBars).selectAll("." + _classes2.default.chartBar).data(targets).attr("class", classChartBar),
				contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);

			// Bars for each data
			contextBarEnter.append("g").attr("class", classBars);

			// -- Line --//
			var contextLineUpdate = context.select("." + _classes2.default.chartLines).selectAll("." + _classes2.default.chartLine).data(targets).attr("class", classChartLine),
				contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);

			// Lines for each data
			contextLineEnter.append("g").attr("class", classLines), contextLineEnter.append("g").attr("class", classAreas), context.selectAll("." + _classes2.default.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
		}
	},

	/**
* Update the bar of the sub chart
* @private
* @param {Object} durationForExit
*/
	updateBarForSubchart: function updateBarForSubchart(durationForExit) {
		var $$ = this;

		$$.contextBar = $$.context.selectAll("." + _classes2.default.bars).selectAll("." + _classes2.default.bar).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
	},

	/**
* Redraw the bar of the subchart
* @private
* @param {String} path in subchart bar
* @param {Boolean} whether or not to transition.
* @param {Number} transition duration
*/
	redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
		var contextBar = void 0;

		contextBar = withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar, contextBar.attr("d", drawBarOnSub).style("opacity", "1");
	},

	/**
* Update the line of the sub chart
* @private
* @param {Number} Fade-out transition duration
*/
	updateLineForSubchart: function updateLineForSubchart(durationForExit) {
		var $$ = this;

		$$.contextLine = $$.context.selectAll("." + _classes2.default.lines).selectAll("." + _classes2.default.line).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
	},

	/**
* Redraw the line of the subchart
* @private
* @param {String} path in subchart line
* @param {Boolean} whether or not to transition
* @param {Number} transition duration
*/
	redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
		var contextLine = void 0;

		contextLine = withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine, contextLine.attr("d", drawLineOnSub).style("opacity", "1");
	},

	/**
* Update the area of the sub chart
* @private
* @param {Number} Fade-out transition duration
*/
	updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
		var $$ = this;

		$$.contextArea = $$.context.selectAll("." + _classes2.default.areas).selectAll("." + _classes2.default.area).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function() {
			return $$.orgAreaOpacity = (0, _d3Selection.select)(this).style("opacity"), "0";
		}).merge($$.contextArea).style("opacity", "0");
	},

	/**
* Redraw the area of the subchart
* @private
* @param {String} path in subchart line
* @param {Boolean} whether or not to transition
* @param {Number} transition duration
*/
	redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
		var contextArea = void 0;

		contextArea = withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea, contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
	},

	/**
* Redraw subchart.
* @private
* @param {Boolean} whether or not to show subchart
* @param Do not use.
* @param {Number} transition duration
* @param Do not use.
* @param {Object} area Indices
* @param {Object} bar Indices
* @param {Object} line Indices
*/
	redrawSubchart: function redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
		var $$ = this,
			config = $$.config;

		// subchart
		if ($$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (_d3Selection.event && _d3Selection.event.type === "zoom" && $$.brush.update(), withSubchart))

			// update subchart elements if needed
			{
				$$.brushEmpty() || $$.brush.update();

				// setup drawer - MEMO: this must be called after axis updated
				var _drawAreaOnSub = $$.generateDrawArea(areaIndices, !0),
					_drawBarOnSub = $$.generateDrawBar(barIndices, !0),
					_drawLineOnSub = $$.generateDrawLine(lineIndices, !0);
				$$.updateBarForSubchart(duration), $$.updateLineForSubchart(duration), $$.updateAreaForSubchart(duration), $$.redrawBarForSubchart(_drawBarOnSub, duration, duration), $$.redrawLineForSubchart(_drawLineOnSub, duration, duration), $$.redrawAreaForSubchart(_drawAreaOnSub, duration, duration);
			}
	},

	/**
* Redraw the brush.
* @private
*/
	redrawForBrush: function redrawForBrush() {
		var $$ = this,
			x = $$.x;
		$$.redraw({
			withTransition: !1,
			withY: $$.config.zoom_rescale,
			withSubchart: !1,
			withUpdateXDomain: !0,
			withDimension: !1
		}), $$.config.subchart_onbrush.call($$.api, x.orgDomain());
	},

	/**
* Transform context
* @private
* @param {Boolean} indicates transition is enabled
* @param {Object} The return value of the generateTransitions method of Axis.
*/
	transformContext: function transformContext(withTransition, transitions) {
		var $$ = this,
			subXAxis = void 0;
		transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select("." + _classes2.default.axisX), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subx"));
	},

	/**
* Get default extent
* @private
* @returns {Array} default extent
*/
	getDefaultExtent: function getDefaultExtent() {
		var $$ = this,
			config = $$.config,
			extent = (0, _util.isFunction)(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;

		return $$.isTimeSeries() && (extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])]), extent;
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Array = __webpack_require__(4),
	_d3Selection = __webpack_require__(4),
	_d3Zoom = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Initialize zoom.
* @private
*/
	initZoom: function initZoom() {
		var $$ = this,
			config = $$.config,
			startEvent = void 0;
		$$.zoomScale = null, $$.zoom = (0, _d3Zoom.zoom)().duration(0).on("start", function() {
			startEvent = _d3Selection.event.sourceEvent, $$.zoom.altDomain = _d3Selection.event.sourceEvent.altKey ? $$.x.orgDomain() : null, config.zoom_onzoomstart.call($$.api, _d3Selection.event.sourceEvent);
		}).on("zoom", function() {
			$$.redrawForZoom.call($$);
		}).on("end", function() {
			var event = _d3Selection.event.sourceEvent;

			// if click, do nothing. otherwise, click interaction will be canceled.
			event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), (0, _util.isFunction)(config.zoom_onzoomend) && config.zoom_onzoomend.call($$.api, $$.x.orgDomain()));
		}), $$.zoom.orgScaleExtent = function() {
			var extent = config.zoom_extent ? config.zoom_extent : [1, 10];

			return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
		}, $$.zoom.updateScaleExtent = function() {
			var ratio = (0, _util.diffDomain)($$.x.orgDomain()) / (0, _util.diffDomain)($$.getZoomDomain()),
				extent = this.orgScaleExtent();

			return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
		}, $$.zoom.updateTransformScale = function(transform) {
			var newScale = transform.rescaleX($$.x);

			newScale.domain($$.trimXDomain(newScale.domain())), $$.zoomScale = newScale, $$.xAxis.scale($$.zoomScale), $$.main.select("." + _classes2.default.eventRects).node().__zoom = transform;
		};
	},

	/**
* Get zoom domain
* @private
* @returns {Array} zoom domain
*/
	getZoomDomain: function getZoomDomain() {
		var $$ = this,
			config = $$.config,
			min = (0, _d3Array.min)([$$.orgXDomain[0], config.zoom_x_min]),
			max = (0, _d3Array.max)([$$.orgXDomain[1], config.zoom_x_max]);

		return [min, max];
	},

	/**
* Update zoom
* @private
*/
	updateZoom: function updateZoom() {
		var $$ = this,
			z = $$.config.zoom_enabled ? $$.zoom : function() {};

		// bind zoom module
		// $$.main.select(`.${CLASS.zoomRect}`)
		// 	.call(z)
		// 	.on("dblclick.zoom", null);

		if ($$.zoomScale) {
			var zoomDomain = $$.zoomScale.domain(),
				xDomain = $$.x.domain(),
				delta = .015;
			// arbitrary value

			// check if the zoomed chart is fully shown, then reset scale when zoom is out as initial
			(zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta) && ($$.xAxis.scale($$.x), $$.zoomScale = null);
		}

		$$.main.select("." + _classes2.default.eventRects).call(z).on("dblclick.zoom", null);
	},

	/**
* Redraw the zoom.
* @private
*/
	redrawForZoom: function redrawForZoom() {
		var $$ = this,
			config = $$.config;

		if (config.zoom_enabled) {

				var zoom = $$.zoom,
					x = $$.x,
					event = _d3Selection.event,
					transform = event.transform;
				return $$.zoom.updateTransformScale(transform), $$.filterTargetsToShow($$.data.targets).length === 0 ? void 0 : event.sourceEvent.type === "mousemove" && zoom.altDomain ? (x.domain(zoom.altDomain), void transform.scale($$.zoomScale).updateScaleExtent()) : void ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0] && x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]), $$.redraw({
					withTransition: !1,
					withY: config.zoom_rescale,
					withSubchart: !1,
					withEventRect: !1,
					withDimension: !1
				}), event.sourceEvent.type === "mousemove" && ($$.cancelClick = !0), (0, _util.isFunction)(config.zoom_onzoom) && config.zoom_onzoom.call($$.api, x.orgDomain()));
			}
	}
});

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_d3Scale = __webpack_require__(4),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var colorizePattern = function(pattern, color, id) {
	var node = (0, _d3Selection.select)(pattern.cloneNode(!0));

	return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
		id: id,
		node: node.node()
	};
},
	schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];

// Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)
(0, _util.extend)(_ChartInternal2.default.prototype, {
	generateColor: function generateColor() {
		var $$ = this,
			config = $$.config,
			colors = config.data_colors,
			callback = config.data_color,
			ids = [],
			pattern = (0, _util.notEmpty)(config.color_pattern) ? config.color_pattern : (0, _d3Scale.scaleOrdinal)(schemeCategory10).range(),
			originalColorPattern = pattern;

		if ((0, _util.isFunction)(config.color_tiles)) {
			var tiles = config.color_tiles(),
				colorizedPatterns = pattern.map(function (p, index) {
				var color = p.replace(/[#\(\)\s,]/g, ""),
					id = $$.datetimeId + "-pattern-" + color + "-" + index;

				return colorizePattern(tiles[index % tiles.length], p, id);
			});

			// Add background color to patterns
			pattern = colorizedPatterns.map(function (p) {
				return "url(#" + p.id + ")";
			}), $$.patterns = colorizedPatterns;
		}

		return function(d) {
			var id = d.id || d.data && d.data.id || d,
				isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !$$.config.data_types[id],
				color = void 0;

			// if callback function is provided

			return colors[id] instanceof Function ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), callback instanceof Function ? callback(color, d) : color;
		};
	},
	generateLevelColor: function generateLevelColor() {
		var $$ = this,
			config = $$.config,
			colors = config.color_pattern,
			threshold = config.color_threshold,
			asValue = threshold.unit === "value",
			max = threshold.max || 100,
			values = threshold.values && threshold.values.length ? threshold.values : [];

		return (0, _util.notEmpty)(threshold) ? function(value) {
			var color = colors[colors.length - 1];

			for (var v, i = 0; i < values.length; i++) if (v = asValue ? value : value * 100 / max, v < values[i]) {
				color = colors[i];

				break;
			}

			return color;
		} : null;
	}
});

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var getFormat = function($$, typeValue, v) {
	var config = $$.config,
		type = "axis_" + typeValue + "_tick_format",
		format = config[type] ? config[type] : $$.defaultValueFormat;

	return format(v);
};

(0, _util.extend)(_ChartInternal2.default.prototype, {
	getYFormat: function getYFormat(forArc) {
		var $$ = this,
			formatForY = $$.yFormat,
			formatForY2 = $$.y2Format;

		return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function(v, ratio, id) {
			var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;

			return format.call($$, v, ratio);
		};
	},
	yFormat: function yFormat(v) {
		return getFormat(this, "y", v);
	},
	y2Format: function y2Format(v) {
		return getFormat(this, "y2", v);
	},
	defaultValueFormat: function defaultValueFormat(v) {
		return (0, _util.isValue)(v) ? +v : "";
	},
	defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
		return (ratio * 100).toFixed(1) + "%";
	},
	dataLabelFormat: function dataLabelFormat(targetId) {
		var $$ = this,
			dataLabels = $$.config.data_labels,
			defaultFormat = function(v) {
			return (0, _util.isValue)(v) ? +v : "";
		},
			format = void 0;

		// find format according to axis id

		return format = (0, _util.isFunction)(dataLabels.format) ? dataLabels.format : (0, _util.isObjectType)(dataLabels.format) ? dataLabels.format[targetId] ? dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : function() {
			return "";
		} : defaultFormat, format;
	}
});

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_ChartInternal2.default.prototype, {
	hasCaches: function hasCaches(ids) {
		for (var i = 0, len = ids.length; i < len; i++) if (!(ids[i] in this.cache)) return !1;

		return !0;
	},
	addCache: function addCache(id, target) {
		this.cache[id] = this.cloneTarget(target);
	},
	getCaches: function getCaches(ids) {
		var targets = [];

		for (var key, i = 0; key = ids[i]; i++) key in this.cache && targets.push(this.cloneTarget(this.cache[key]));

		return targets;
	},

	/**
* reset cached data
* @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
* @private
	 */
	resetCache: function resetCache(all) {
		var $$ = this;

		for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
	}
});

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_ChartInternal2.default.prototype, {
	CLASS: _classes2.default,

	generateClass: function generateClass(prefix, targetId) {
		return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
	},
	classText: function classText(d) {
		return this.generateClass(_classes2.default.text, d.index);
	},
	classTexts: function classTexts(d) {
		return this.generateClass(_classes2.default.texts, d.id);
	},
	classShape: function classShape(d) {
		return this.generateClass(_classes2.default.shape, d.index);
	},
	classShapes: function classShapes(d) {
		return this.generateClass(_classes2.default.shapes, d.id);
	},
	generateExtraLineClass: function generateExtraLineClass() {
		var $$ = this,
			classes = $$.config.line_classes || [],
			ids = [];

		return function(d) {
			var id = d.id || d.data && d.data.id || d;

			return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
		};
	},
	classLine: function classLine(d) {
		return this.classShape(d) + this.generateClass(_classes2.default.line, d.id);
	},
	classLines: function classLines(d) {
		return this.classShapes(d) + this.generateClass(_classes2.default.lines, d.id);
	},
	classCircle: function classCircle(d) {
		return this.classShape(d) + this.generateClass(_classes2.default.circle, d.index);
	},
	classCircles: function classCircles(d) {
		return this.classShapes(d) + this.generateClass(_classes2.default.circles, d.id);
	},
	classBar: function classBar(d) {
		return this.classShape(d) + this.generateClass(_classes2.default.bar, d.index);
	},
	classBars: function classBars(d) {
		return this.classShapes(d) + this.generateClass(_classes2.default.bars, d.id);
	},
	classArc: function classArc(d) {
		return this.classShape(d.data) + this.generateClass(_classes2.default.arc, d.data.id);
	},
	classArcs: function classArcs(d) {
		return this.classShapes(d.data) + this.generateClass(_classes2.default.arcs, d.data.id);
	},
	classArea: function classArea(d) {
		return this.classShape(d) + this.generateClass(_classes2.default.area, d.id);
	},
	classAreas: function classAreas(d) {
		return this.classShapes(d) + this.generateClass(_classes2.default.areas, d.id);
	},
	classRegion: function classRegion(d, i) {
		return this.generateClass(_classes2.default.region, i) + " " + ("class" in d ? d.class : "");
	},
	classEvent: function classEvent(d) {
		return this.generateClass(_classes2.default.eventRect, d.index);
	},
	classTarget: function classTarget(id) {
		var additionalClassSuffix = this.config.data_classes[id],
			additionalClass = "";

		return additionalClassSuffix && (additionalClass = " " + _classes2.default.target + "-" + additionalClassSuffix), this.generateClass(_classes2.default.target, id) + additionalClass;
	},
	classFocus: function classFocus(d) {
		return this.classFocused(d) + this.classDefocused(d);
	},
	classFocused: function classFocused(d) {
		return " " + (this.focusedTargetIds.indexOf(d.id) >= 0 ? _classes2.default.focused : "");
	},
	classDefocused: function classDefocused(d) {
		return " " + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? _classes2.default.defocused : "");
	},
	classChartText: function classChartText(d) {
		return _classes2.default.chartText + this.classTarget(d.id);
	},
	classChartLine: function classChartLine(d) {
		return _classes2.default.chartLine + this.classTarget(d.id);
	},
	classChartBar: function classChartBar(d) {
		return _classes2.default.chartBar + this.classTarget(d.id);
	},
	classChartArc: function classChartArc(d) {
		return _classes2.default.chartArc + this.classTarget(d.data.id);
	},
	getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
		return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
	},
	selectorTarget: function selectorTarget(id, prefix) {
		return (prefix || "") + "." + (_classes2.default.target + this.getTargetSelectorSuffix(id));
	},
	selectorTargets: function selectorTargets(idsValue, prefix) {
		var $$ = this,
			ids = idsValue || [];

		return ids.length ? ids.map(function (id) {
			return $$.selectorTarget(id, prefix);
		}) : null;
	},
	selectorLegend: function selectorLegend(id) {
		return "." + (_classes2.default.legendItem + this.getTargetSelectorSuffix(id));
	},
	selectorLegends: function selectorLegends(ids) {
		var $$ = this;

		return ids && ids.length ? ids.map(function (id) {
			return $$.selectorLegend(id);
		}) : null;
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* This API highlights specified targets and fade out the others.<br><br>
* You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
* @method focus
* @instance
* @memberOf Chart
* @param {String|Array} targetIdsValue Target ids to be highlighted.
* @example
*  // data1 will be highlighted and the others will be faded out
*  chart.focus("data1");
*
* // data1 and data2 will be highlighted and the others will be faded out
* chart.focus(["data1", "data2"]);
*
* // all targets will be highlighted
* chart.focus();
*/
	focus: function focus(targetIdsValue) {
		var $$ = this.internal,
			targetIds = $$.mapToTargetIds(targetIdsValue),
			candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
		this.revert(), this.defocus(), candidates.classed(_classes2.default.focused, !0).classed(_classes2.default.defocused, !1), $$.hasArcType() && $$.expandArc(targetIds), $$.toggleFocusLegend(targetIds, !0), $$.focusedTargetIds = targetIds, $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
			return targetIds.indexOf(id) < 0;
		});
	},

	/**
* This API fades out specified targets and reverts the others.<br><br>
* You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
* @method defocus
* @instance
* @memberOf Chart
* @param {String|Array} Target ids to be faded out.
* @example
* // data1 will be faded out and the others will be reverted.
* chart.defocus("data1");
*
* // data1 and data2 will be faded out and the others will be reverted.
* chart.defocus(["data1", "data2"]);
*
* // all targets will be faded out.
* chart.defocus();
*/
	defocus: function defocus(targetIdsValue) {
		var $$ = this.internal,
			targetIds = $$.mapToTargetIds(targetIdsValue),
			candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
		candidates.classed(_classes2.default.focused, !1).classed(_classes2.default.defocused, !0), $$.hasArcType() && $$.unexpandArc(targetIds), $$.toggleFocusLegend(targetIds, !1), $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
			return targetIds.indexOf(id) < 0;
		}), $$.defocusedTargetIds = targetIds;
	},

	/**
* This API reverts specified targets.<br><br>
* You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
* @method revert
* @instance
* @memberOf Chart
* @param {String|Array} Target ids to be reverted
* @example
* // data1 will be reverted.
* chart.revert("data1");
*
* // data1 and data2 will be reverted.
* chart.revert(["data1", "data2"]);
*
* // all targets will be reverted.
* chart.revert();
*/
	revert: function revert(targetIdsValue) {
		var $$ = this.internal,
			targetIds = $$.mapToTargetIds(targetIdsValue),
			candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
		// should be for all targets

		candidates.classed(_classes2.default.focused, !1).classed(_classes2.default.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), $$.config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
			return (0, _d3Selection.select)(this).classed(_classes2.default.legendItemFocused);
		}).classed(_classes2.default.legendItemFocused, !1)), $$.focusedTargetIds = [], $$.defocusedTargetIds = [];
	}
});

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Show data series on chart
* @method show
* @instance
* @memberOf Chart
* @param {String|Array} [targetIdsValue=all] The target id value.
* @param {Object} [options] The object can consist with following members:<br>
*
*    | Key | Type | default | Description |
*    | --- | --- | --- | --- |
*    | withLegend | Boolean | false | whether or not display legend |
*
* @example
* // show 'data1'
* chart.show("data1");
*
* // show 'data1' and 'data3'
* chart.show(["data1", "data3"]);
*/
	show: function show(targetIdsValue) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
			$$ = this.internal,
			targetIds = $$.mapToTargetIds(targetIdsValue);
		$$.removeHiddenTargetIds(targetIds);

		var targets = $$.svg.selectAll($$.selectorTargets(targetIds));

		targets.transition().style("opacity", "1", "important").call($$.endall, function() {
			targets.style("opacity", null).style("opacity", "1");
		}), options.withLegend && $$.showLegend(targetIds), $$.redraw({
			withUpdateOrgXDomain: !0,
			withUpdateXDomain: !0,
			withLegend: !0
		});
	},

	/**
* Hide data series from chart
* @method hide
* @instance
* @memberOf Chart
* @param {String|Array} [targetIdsValue=all] The target id value.
* @param {Object} [options] The object can consist with following members:<br>
*
*    | Key | Type | default | Description |
*    | --- | --- | --- | --- |
*    | withLegend | Boolean | false | whether or not display legend |
*
* @example
* // hide 'data1'
* chart.hide("data1");
*
* // hide 'data1' and 'data3'
* chart.hide(["data1", "data3"]);
*/
	hide: function hide(targetIdsValue) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
			$$ = this.internal,
			targetIds = $$.mapToTargetIds(targetIdsValue);
		$$.addHiddenTargetIds(targetIds);

		var targets = $$.svg.selectAll($$.selectorTargets(targetIds));

		targets.transition().style("opacity", "0", "important").call($$.endall, function() {
			targets.style("opacity", null).style("opacity", "0");
		}), options.withLegend && $$.hideLegend(targetIds), $$.redraw({
			withUpdateOrgXDomain: !0,
			withUpdateXDomain: !0,
			withLegend: !0
		});
	},

	/**
* Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
* @method toggle
* @instance
* @memberOf Chart
* @param {String|Array} [targetIdsValue=all] The target id value.
* @param {Object} [options] The object can consist with following members:<br>
*
*    | Key | Type | default | Description |
*    | --- | --- | --- | --- |
*    | withLegend | Boolean | false | whether or not display legend |
*
* @example
* // toggle 'data1'
* chart.toggle("data1");
*
* // toggle 'data1' and 'data3'
* chart.toggle(["data1", "data3"]);
*/
	toggle: function toggle(targetIds) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
			that = this,
			$$ = this.internal;
		$$.mapToTargetIds(targetIds).forEach(function (targetId) {
			$$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);
		});
	}
});

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Array = __webpack_require__(4),
	_d3Zoom = __webpack_require__(4),
	_Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Zoom by giving x domain.
 * @method zoom
 * @instance
 * @memberOf Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var zoom = function(domainValue) {
	var $$ = this.internal,
		isTimeSeries = $$.isTimeSeries(),
		domain = domainValue,
		resultDomain = void 0;

	if ($$.config.zoom_enabled && domain) {

		if (isTimeSeries && (domain = domain.map(function (x) {
			return $$.parseDate(x);
		})), $$.config.subchart_show) {
			var xScale = $$.zoomScale || $$.x;

			$$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
		} else {
			var orgDomain = $$.x.orgDomain(),
				k = (orgDomain[1] - orgDomain[0]) / (domain[1] - domain[0]),
				tx = isTimeSeries ? 0 - k * $$.x(domain[0].getTime()) : domain[0] - k * $$.x(domain[0]);
			$$.zoom.updateTransformScale(_d3Zoom.zoomIdentity.translate(tx, 0).scale(k)), resultDomain = $$.zoomScale.domain();
		}

		$$.redraw({
			withTransition: !0,
			withY: $$.config.zoom_rescale,
			withDimension: !1
		}), $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
	} else resultDomain = ($$.zoomScale || $$.x).domain();

	return resultDomain;
};

(0, _util.extend)(zoom, {
	/**
* Enable and disable zooming.
* @method zoom․enable
* @instance
* @memberOf Chart
* @param {Boolean} enabled If enabled is true, the feature of zooming will be enabled. If false is given, it will be disabled.<br>When set to false, the current zooming status will be reset.
* @example
*  // Enable zooming
*  chart.zoom.enable(true);
*
*  // Disable zooming
*  chart.zoom.enable(false);
*/
	enable: function enable() {
		var enabled = !!(arguments.length > 0 && arguments[0] !== undefined) && arguments[0],
			$$ = this.internal;
		$$.config.zoom_enabled = enabled, $$.updateAndRedraw();
	},

	/**
* Set or get x Axis maximum zoom range value
* @method zoom․max
* @instance
* @memberOf Chart
* @param {Number} [max] maximum value to set for zoom
* @return {Number} zoom max value
* @example
*  // Set maximum range value
*  chart.zoom.max(20);
*/
	max: function max(_max) {
		var $$ = this.internal,
			config = $$.config;

		return (_max === 0 || _max) && (config.zoom_x_max = (0, _d3Array.max)([$$.orgXDomain[1], _max])), config.zoom_x_max;
	},

	/**
* Set or get x Axis minimum zoom range value
* @method zoom․min
* @instance
* @memberOf Chart
* @param {Number} [min] minimum value tp set for zoom
* @return {Number} zoom min value
* @example
*  // Set minimum range value
*  chart.zoom.min(-1);
*/
	min: function min(_min) {
		var $$ = this.internal,
			config = $$.config;

		return (_min === 0 || _min) && (config.zoom_x_min = (0, _d3Array.min)([$$.orgXDomain[0], _min])), config.zoom_x_min;
	},

	/**
* Set zoom range
* @method zoom․range
* @instance
* @memberOf Chart
* @param {Object} [range]
* @return {Object} zoom range value
* {
*   min: 0,
*   max: 100
* }
* @example
*  chart.zoom.range({
*      min: 10,
*      max: 100
*  });
*/
	range: function range(_range) {
		var zoom = this.zoom;

		return (0, _util.isObject)(_range) && ((0, _util.isDefined)(_range.min) && zoom.min(_range.min), (0, _util.isDefined)(_range.max) && zoom.max(_range.max)), {
			min: zoom.min(),
			max: zoom.max()
		};
	}
}), (0, _util.extend)(_Chart2.default.prototype, {
	zoom: zoom,

	/**
* Unzoom zoomed area
* @method unzoom
* @instance
* @memberOf Chart
* @example
*  chart.unzoom();
*/
	unzoom: function unzoom() {
		var $$ = this.internal;

		$$.config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(_d3Zoom.zoomIdentity), $$.redraw({
			withTransition: !0,
			withY: $$.config.zoom_rescale
		});
	}
});

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Load data to the chart.<br><br>
* You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
* - <b>Note:</b>
* unload should be used if some data needs to be unloaded simultaneously. If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
* done will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering
* @method load
* @instance
* @memberOf Chart
* @param {Object} args The object can consist with following members:<br>
*
*    | Key | Description |
*    | --- | --- |
*    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
*    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
*    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
*    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
*    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
*    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
*    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
*    | done | The specified function will be called after data loaded.|
*
* @example
*  // Load data1 and unload data2 and data3
*  chart.load({
*     columns: [
*        ["data1", 100, 200, 150, ...],
*        ...
*    ],
*    unload: ["data2", "data3"],
*    url: "...",
*    done: function() { ... }
*  });
*/
	load: function load(args) {
		var $$ = this.internal,
			config = $$.config;

		// update xs if specified

		// use cache if exists
		return args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
			config.data_classes[id] = args.classes[id];
		}), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
			config.data_axes[id] = args.axes[id];
		}), "colors" in args && Object.keys(args.colors).forEach(function (id) {
			config.data_colors[id] = args.colors[id];
		}), "cacheIds" in args && $$.hasCaches(args.cacheIds) ? void $$.load($$.getCaches(args.cacheIds), args.done) : void ("unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds((0, _util.isBoolean)(args.unload) && args.unload ? null : args.unload), function() {
			return $$.loadFromArgs(args);
		}) : $$.loadFromArgs(args));

		// unload if needed
	},

	/**
* Unload data to the chart.<br><br>
* You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
* - <b>Note:</b>
* If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
* `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
* @method unload
* @instance
* @memberOf Chart
* @param {Object} args
* - If ids given, the data that has specified target id will be unloaded. ids should be String or Array. If ids is not specified, all data will be unloaded.
* - If done given, the specified function will be called after data loded.
* @example
*  // Unload data2 and data3
*  chart.unload({
*    ids: ["data2", "data3"]
*  });
*/
	unload: function unload(argsValue) {
		var $$ = this.internal,
			args = argsValue || {};
		args instanceof Array ? args = { ids: args } : (0, _util.isString)(args) && (args = { ids: [args] }), $$.unload($$.mapToTargetIds(args.ids), function() {
			$$.redraw({
				withUpdateOrgXDomain: !0,
				withUpdateXDomain: !0,
				withLegend: !0
			}), args.done && args.done();
		});
	}
});

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_d3Ease = __webpack_require__(4),
	_d3Transition = __webpack_require__(4),
	_Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Flow data to the chart.<br><br>
* By this API, you can append new data points to the chart.
* @method flow
* @instance
* @memberOf Chart
* @param {Object} args The object can consist with following members:<br>
*
*    | Key | Type | Description |
*    | --- | --- | --- |
*    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
*    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
*    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
*    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
*    | length | Number | The lower x edge will move by the number of this argument |
*    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
*    | done | Function | The specified function will be called when flow ends |
*
* - **NOTE:**
*   If json, rows and columns given, the data will be loaded.<br>
*   If data that has the same target id is given, the chart will be appended.<br>
*   Otherwise, new target will be added. One of these is required when calling.<br>
*   If json specified, keys is required as well as data.json.
* @example
* // 2 data points will be apprended to the tail and popped from the head.
* // After that, 4 data points will be appended and no data points will be poppoed.
* chart.flow({
*  columns: [
*    ["x", "2018-01-11", "2018-01-21"],
*    ["data1", 500, 200],
*    ["data2", 100, 300],
*    ["data3", 200, 120]
*  ],
*  to: "2013-01-11",
*  done: function() {
*    chart.flow({
*      columns: [
*        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
*        ["data1", 200, 300, 100, 250],
*        ["data2", 100, 90, 40, 120],
*        ["data3", 100, 100, 300, 500]
*      ],
*      length: 2,
	 *      duration: 1500
*    });
*  }
* });
*/
	flow: function flow(args) {
		var $$ = this.internal,
			notfoundIds = [],
			orgDataCount = $$.getMaxDataCount(),
			data = void 0,
			domain = void 0,
			length = 0,
			tail = 0,
			diff = void 0,
			to = void 0;

		if (args.json) data = $$.convertJsonToData(args.json, args.keys);else if (args.rows) data = $$.convertRowsToData(args.rows);else if (args.columns) data = $$.convertColumnsToData(args.columns);else return;

		var targets = $$.convertDataToTargets(data, !0);

		// Update/Add data
		$$.data.targets.forEach(function (t) {
			var found = !1;

			for (var i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
				found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

				for (var _j = 0; _j < length; _j++) targets[i].values[_j].index = tail + _j, $$.isTimeSeries() || (targets[i].values[_j].x = tail + _j);

				t.values = t.values.concat(targets[i].values), targets.splice(i, 1);

				break;
			}

			found || notfoundIds.push(t.id);
		}), $$.data.targets.forEach(function (t) {
			for (var i = 0; i < notfoundIds.length; i++) if (t.id === notfoundIds[i]) {
				tail = t.values[t.values.length - 1].index + 1;

				for (var _j2 = 0; _j2 < length; _j2++) t.values.push({
					id: t.id,
					index: tail + _j2,
					x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j2) : tail + _j2,
					value: null
				});
			}
		}), $$.data.targets.length && targets.forEach(function (t) {
			var missing = [];

			for (var i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
				id: t.id,
				index: i,
				x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
				value: null
			});

			t.values.forEach(function (v) {
				v.index += tail, $$.isTimeSeries() || (v.x += tail);
			}), t.values = missing.concat(t.values);
		}), $$.data.targets = $$.data.targets.concat(targets);
		// add remained

		// check data count because behavior needs to change when it"s only one
		// const dataCount = $$.getMaxDataCount();
		var baseTarget = $$.data.targets[0],
			baseValue = baseTarget.values[0];

		// Update length to flow if needed
		(0, _util.isDefined)(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
			v.x < to && length++;
		})) : (0, _util.isDefined)(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)], $$.updateXDomain(null, !0, !0, !1, domain)) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x], $$.updateXDomain(null, !0, !0, !1, domain)), $$.updateTargets($$.data.targets), $$.redraw({
			flow: {
				index: baseValue.index,
				length: length,
				duration: (0, _util.isValue)(args.duration) ? args.duration : $$.config.transition_duration,
				done: args.done,
				orgDataCount: orgDataCount
			},
			withLegend: !0,
			withTransition: orgDataCount > 1,
			withTrimXDomain: !1,
			withUpdateXAxis: !0
		});
	}
}), (0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Generate flow
* @memberOf ChartInternal
* @private
* @param {Object} args
* @return {Function}
*/
	generateFlow: function generateFlow(args) {
		var $$ = this,
			config = $$.config;

		return function() {
			var targets = args.targets,
				flow = args.flow,
				drawBar = args.drawBar,
				drawLine = args.drawLine,
				drawArea = args.drawArea,
				cx = args.cx,
				cy = args.cy,
				xv = args.xv,
				xForText = args.xForText,
				yForText = args.yForText,
				duration = args.duration,
				translateX = void 0,
				scaleX = 1,
				flowIndex = flow.index,
				flowLength = flow.length,
				flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
				flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
				orgDomain = $$.x.domain(),
				durationForFlow = flow.duration || duration,
				done = flow.done || function() {},
				wait = $$.generateWait(),
				xgrid = $$.xgrid || (0, _d3Selection.selectAll)([]),
				xgridLines = $$.xgridLines || (0, _d3Selection.selectAll)([]),
				mainRegion = $$.mainRegion || (0, _d3Selection.selectAll)([]),
				mainText = $$.mainText || (0, _d3Selection.selectAll)([]),
				mainBar = $$.mainBar || (0, _d3Selection.selectAll)([]),
				mainLine = $$.mainLine || (0, _d3Selection.selectAll)([]),
				mainArea = $$.mainArea || (0, _d3Selection.selectAll)([]),
				mainCircle = $$.mainCircle || (0, _d3Selection.selectAll)([]);

			// set flag
			$$.flowing = !0, $$.data.targets.forEach(function (d) {
				d.values.splice(0, flowLength);
			});

			// update x domain to generate axis elements for flow
			var domain = $$.updateXDomain(targets, !0, !0);

			// update elements related to x scale
			$$.updateXGrid && $$.updateXGrid(!0), flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : $$.isTimeSeries() ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : translateX = $$.x(flowStart.x) - $$.x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)) : translateX = (0, _util.diffDomain)(domain) / 2 : translateX = $$.x(orgDomain[0]) - $$.x(domain[0]), scaleX = (0, _util.diffDomain)(orgDomain) / (0, _util.diffDomain)(domain);

			var transform = "translate(" + translateX + ",0) scale(" + scaleX + ",1)";

			$$.hideXGridFocus();

			var gt = (0, _d3Transition.transition)().ease(_d3Ease.easeLinear).duration(durationForFlow);

			wait.add([$$.axes.x.transition(gt).call($$.xAxis.setTransition(gt)), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function() {
				var shapes = [],
					texts = [],
					eventRects = [];

				// remove flowed elements
				if (flowLength) {
					for (var index, i = 0; i < flowLength; i++) index = flowIndex + i, shapes.push("." + _classes2.default.shape + "-" + index), texts.push("." + _classes2.default.text + "-" + index), eventRects.push("." + _classes2.default.eventRect + "-" + index);

					$$.svg.selectAll("." + _classes2.default.shapes).selectAll(shapes).remove(), $$.svg.selectAll("." + _classes2.default.texts).selectAll(texts).remove(), $$.svg.selectAll("." + _classes2.default.eventRects).selectAll(eventRects).remove(), $$.svg.select("." + _classes2.default.xgrid).remove();
				}

				// draw again for removing flowed elements and reverting attr

				if (xgrid.size() && xgrid.attr("transform", null).attr($$.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv), xgridLines.select("text").attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
					mainCircle.attr("x", function xFunc(d) {
						return cx(d) - config.point_r;
					}).attr("y", function yFunc(d) {
						return cy(d) - config.point_r;
					}).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
					.attr("cy", cy);
				}

				mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), $$.flowing = !1;
			});
		};
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Get selected data points.<br><br>
* By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
* @method selected
* @instance
* @memberOf Chart
* @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
* @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
* @example
*  // all selected data points will be returned.
*  chart.selected();
*  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
*
*  // all selected data points of data1 will be returned.
*  chart.selected("data1");
*/
	selected: function selected(targetId) {
		var $$ = this.internal,
			dataPoint = [];

		return $$.main.selectAll("." + (_classes2.default.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + _classes2.default.shape).filter(function () {
			return (0, _d3Selection.select)(this).classed(_classes2.default.SELECTED);
		}).each(function (d) {
			return dataPoint.push(d);
		}), dataPoint;
	},

	/**
* Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
* @method select
* @instance
* @memberOf Chart
* @param {String|Array} [ids] id value to get selected.
* @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
* @param {Boolean} [resetOther] Unselect already selected.
* @example
*  // select all data points
*  chart.select();
*
*  // select all from 'data2'
*  chart.select("data2");
*
*  // select all from 'data1' and 'data2'
*  chart.select(["data1", "data2"]);
*
*  // select from 'data1', indices 2 and unselect others selected
*  chart.select("data1", [2], true);
*
*  // select from 'data1', indices 0, 3 and 5
*  chart.select("data1", [0, 3, 5]);
*/
	select: function select(ids, indices, resetOther) {
		var $$ = this.internal,
			config = $$.config;
		config.data_selection_enabled && $$.main.selectAll("." + _classes2.default.shapes).selectAll("." + _classes2.default.shape).each(function (d, i) {
			var shape = (0, _d3Selection.select)(this),
				id = d.data ? d.data.id : d.id,
				toggle = $$.getToggle(this, d).bind($$),
				isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
				isTargetIndex = !indices || indices.indexOf(i) >= 0,
				isSelected = shape.classed(_classes2.default.SELECTED);

			// line/area selection not supported yet
			shape.classed(_classes2.default.line) || shape.classed(_classes2.default.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(_classes2.default.SELECTED, !0), d, i) : (0, _util.isDefined)(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(_classes2.default.SELECTED, !1), d, i));
		});
	},

	/**
* Set data points to be un-selected.
* @method unselect
* @instance
* @memberOf Chart
* @param {String|Array} [ids] id value to be unselected.
* @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
* @example
*  // unselect all data points
*  chart.unselect();
*
*  // unselect all from 'data1'
*  chart.unselect("data1");
*
*  // unselect from 'data1', indices 2
*  chart.unselect("data1", [2]);
*/
	unselect: function unselect(ids, indices) {
		var $$ = this.internal,
			config = $$.config;
		config.data_selection_enabled && $$.main.selectAll("." + _classes2.default.shapes).selectAll("." + _classes2.default.shape).each(function (d, i) {
			var shape = (0, _d3Selection.select)(this),
				id = d.data ? d.data.id : d.id,
				toggle = $$.getToggle(this, d).bind($$),
				isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
				isTargetIndex = !indices || indices.indexOf(i) >= 0,
				isSelected = shape.classed(_classes2.default.SELECTED);

			// line/area selection not supported yet
			shape.classed(_classes2.default.line) || shape.classed(_classes2.default.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(_classes2.default.SELECTED, !1), d, i);
		});
	}
});

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Change the type of the chart.
* @method transform
* @instance
* @memberOf Chart
* @param {String} type Specify the type to be transformed. The types listed in data.type can be used.
* @param {String|Array} targetIds Specify targets to be transformed. If not given, all targets will be the candidate.
* @example
*  // all targets will be bar chart.
*  chart.transform("bar");
*
*  // only data1 will be bar chart.
*  chart.transform("bar", "data1");
*
*  // only data1 and data2 will be bar chart.
*  chart.transform("bar", ["data1", "data2"]);
*/
	transform: function transform(type, targetIds) {
		var $$ = this.internal,
			options = ["pie", "donut"].indexOf(type) >= 0 ? { withTransform: !0 } : null;
		$$.transformTo(targetIds, type, options);
	}
}), (0, _util.extend)(_ChartInternal2.default.prototype, {
	/**
* Change the type of the chart.
* @private
* @param {String|Array} targetIds
* @param {String} type
* @param {Object} optionsForRedraw
*/
	transformTo: function transformTo(targetIds, type, optionsForRedraw) {
		var $$ = this,
			withTransitionForAxis = !$$.hasArcType(),
			options = optionsForRedraw || { withTransitionForAxis: withTransitionForAxis };
		options.withTransitionForTransform = !1, $$.transiting = !1, $$.setTargetType(targetIds, type), $$.updateTargets($$.data.targets), $$.updateAndRedraw(options);
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Update groups for the targets.
* @method groups
* @instance
* @memberOf Chart
* @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
* @example
*  // data1 and data2 will be a new group.
*  chart.groups([
*     ["data1", "data2"]
*  ]);
*/
	groups: function groups(_groups) {
		var $$ = this.internal,
			config = $$.config;
		return (0, _util.isUndefined)(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
	}
});

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberOf Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var xgrids = function(grids) {
	var $$ = this.internal,
		config = $$.config;
	return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
};

(0, _util.extend)(xgrids, {
	/**
* Add x grid lines.<br>
* This API adds new x grid lines instead of replacing like xgrids.
* @method xgrids․add
* @instance
* @memberOf Chart
* @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
* @example
*  // Add a new x grid line
* chart.xgrids.add(
*   {value: 4, text: "Label 4"}
* );
*
* // Add new x grid lines
* chart.xgrids.add([
*   {value: 2, text: "Label 2"},
*   {value: 4, text: "Label 4"}
* ]);
*/
	add: function add(grids) {
		return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
	},

	/**
* Remove x grid lines.<br>
* This API removes x grid lines.
* @method xgrids․remove
* @instance
* @memberOf Chart
* @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
* @example
* // x grid line on x = 2 will be removed
* chart.xgrids.remove({value: 2});
*
* // x grid lines that have 'grid-A' will be removed
* chart.xgrids.remove({
*   class: "grid-A"
* });
*
* // all of x grid lines will be removed
* chart.xgrids.remove();
*/
	remove: function remove(params) {
		this.internal.removeGridLines(params, !0);
	}
});

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberOf Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */
var ygrids = function(grids) {
	var $$ = this.internal,
		config = $$.config;
	return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
};

(0, _util.extend)(ygrids, {
	/**
* Add y grid lines.<br>
* This API adds new y grid lines instead of replacing like ygrids.
* @method ygrids․add
* @instance
* @memberOf Chart
* @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
* @example
*  // Add a new x grid line
* chart.ygrids.add(
*   {value: 400, text: "Label 4"}
* );
*
* // Add new x grid lines
* chart.ygrids.add([
*   {value: 200, text: "Label 2"},
*   {value: 400, text: "Label 4"}
* ]);
*/
	add: function add(grids) {
		return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
	},

	/**
* Remove y grid lines.<br>
* This API removes x grid lines.
* @method ygrids․remove
* @instance
* @memberOf Chart
* @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
* @example
* // y grid line on y = 200 will be removed
* chart.ygrids.remove({value: 200});
*
* // y grid lines that have 'grid-A' will be removed
* chart.ygrids.remove({
*   class: "grid-A"
* });
*
* // all of y grid lines will be removed
* chart.ygrids.remove();
*/
	remove: function remove(params) {
		this.internal.removeGridLines(params, !1);
	}
}), (0, _util.extend)(_Chart2.default.prototype, {
	xgrids: xgrids,
	ygrids: ygrids
});

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_classes = __webpack_require__(8),
	_classes2 = _interopRequireDefault(_classes),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Update regions.
 * @method regions
 * @instance
 * @memberOf Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */
var regions = function(_regions) {
	var $$ = this.internal,
		config = $$.config;
	return _regions ? (config.regions = _regions, $$.redrawWithoutRescale(), config.regions) : config.regions;
}; /**
	* Copyright (c) 2017 NAVER Corp.
	* billboard.js project is licensed under the MIT license
	*/
(0, _util.extend)(regions, {
	/**
* Add new region.<br><br>
* This API adds new region instead of replacing like regions.
* @method regions․add
* @instance
* @memberOf Chart
* @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
* @return {Array} regions
* @example
* // Add a new region
* chart.regions.add(
*    {axis: "x", start: 5, class: "regionX"}
* );
*
* // Add new regions
* chart.regions.add([
*    {axis: "x", start: 5, class: "regionX"},
*    {axis: "y", end: 50, class: "regionY"}
*]);
*/
	add: function add(regions) {
		var $$ = this.internal,
			config = $$.config;
		return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
	},

	/**
* Remove regions.<br><br>
* This API removes regions.
* @method regions․remove
* @instance
* @memberOf Chart
* @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
* @return {Array} regions
* @example
* // regions that have 'region-A' or 'region-B' will be removed.
* chart.regions.remove({
*   classes: [
*     "region-A", "region-B"
*   ]
* });
*
* // all of regions will be removed.
* chart.regions.remove();
*/
	remove: function remove(optionsValue) {
		var $$ = this.internal,
			config = $$.config,
			options = optionsValue || {},
			duration = $$.getOption(options, "duration", config.transition_duration),
			classes = $$.getOption(options, "classes", [_classes2.default.region]),
			regions = $$.main.select("." + _classes2.default.regions).selectAll(classes.map(function (c) {
			return "." + c;
		}));

		return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), config.regions = config.regions.filter(function (region) {
			var found = !1;

			return !region.class || (region.class.split(" ").forEach(function (c) {
				classes.indexOf(c) >= 0 && (found = !0);
			}), !found);
		}), config.regions;
	}
}), (0, _util.extend)(_Chart2.default.prototype, { regions: regions });

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberOf Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @example
 * // Get only data1 data
 * chart.data("data1");
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var data = function(targetIds) {
	var targets = this.internal.data.targets;

	return (0, _util.isUndefined)(targetIds) ? targets : targets.filter(function (t) {
		return targetIds.indexOf(t.id) >= 0;
	});
};

(0, _util.extend)(data, {
	/**
* Get data shown in the chart.
* @method data․shown
* @instance
* @memberOf Chart
* @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
* @example
* // Get shown data by filtering to include only data1 data
* chart.data.shown("data1");
*
* // Get shown data by filtering to include data1 and data2 data
* chart.data.shown(["data1", "data2"]);
*
* // Get all shown data
* chart.data.shown();
*/
	shown: function shown(targetIds) {
		return this.internal.filterTargetsToShow(this.data(targetIds));
	},

	/**
* Get values of the data loaded in the chart.
* @method data․values
* @instance
* @memberOf Chart
* @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
* @example
* // Get data1 values
* chart.data.values("data1");
*/
	values: function(targetId) {
		var values = null;

		if (targetId) {
			var targets = this.data(targetId);

			targets && (0, _util.isArray)(targets) && (values = [], targets.forEach(function (v) {
				values = values.concat(v.values.map(function (d) {
					return d.value;
				}));
			}));
		}

		return values;
	},

	/**
* Get and set names of the data loaded in the chart.
* @method data․names
* @instance
* @memberOf Chart
* @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
* @example
* // Get current names
* chart.data.names();
*
* // Update names
* chart.data.names({
*  data1: "New Name 1",
*  data2: "New Name 2"
*});
*/
	names: function names(_names) {

		return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes("names", _names);
	},

	/**
* Get and set colors of the data loaded in the chart.
* @method data․colors
* @instance
* @memberOf Chart
* @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as
* @example
* // Get current colors
* chart.data.colors();
*
* // Update colors
* chart.data.colors({
*  data1: "#FFFFFF",
*  data2: "#000000"
* });
*/
	colors: function colors(_colors) {
		return this.internal.updateDataAttributes("colors", _colors);
	},

	/**
* Get and set axes of the data loaded in the chart.
* @method data․axes
* @instance
* @memberOf Chart
* @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
* @example
* // Get current axes
* chart.data.axes();
*
* // Update axes
* chart.data.axes({
*  data1: "y",
*  data2: "y2"
* });
*/
	axes: function axes(_axes) {
		return this.internal.updateDataAttributes("axes", _axes);
	}
}), (0, _util.extend)(_Chart2.default.prototype, { data: data });

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Set specified category name on category axis.
* @method category
* @instance
* @memberOf Chart
* @param {Number} i index of category to be changed
* @param {String} category category value to be changed
* @example
* chart.category(2, "Category 3");
*/
	category: function category(i, _category) {
		var $$ = this.internal,
			config = $$.config;

		return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
	},

	/**
* Set category names on category axis.
* @method categories
* @instance
* @memberOf Chart
* @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
* @example
* chart.categories([
*      "Category 1", "Category 2", ...
* ]);
*/
	categories: function categories(_categories) {
		var $$ = this.internal,
			config = $$.config;
		return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
	}
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Get the color
* @method color
* @instance
* @memberOf Chart
* @param {String} id id to get the color
* @example
* chart.color("data1");
*/
	color: function color(id) {
		return this.internal.color(id); // more patterns
	}
});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Get and set x values for the chart.
* @method x
* @instance
* @memberOf Chart
* @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
* @return {Object} xs
* @example
*  // Get current x values
*  chart.x();
*
*  // Update x values for all targets
*  chart.x([100, 200, 300, 400, ...]);
*/
	x: function x(_x) {
		var $$ = this.internal;

		return arguments.length && ($$.updateTargetX($$.data.targets, _x), $$.redraw({
			withUpdateOrgXDomain: !0,
			withUpdateXDomain: !0
		})), $$.data.xs;
	},

	/**
* Get and set x values for the chart.
* @method xs
* @instance
* @memberOf Chart
* @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
* @return {Object} xs
* @example
*  // Get current x values
*  chart.xs();
*
*  // Update x values for all targets
*  chart.xs({
*    data1: [10, 20, 30, 40, ...],
*    data2: [100, 200, 300, 400, ...]
*  });
*/
	xs: function xs(_xs) {
		var $$ = this.internal;

		return arguments.length && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
			withUpdateOrgXDomain: !0,
			withUpdateXDomain: !0
		})), $$.data.xs;
	}
});

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var setMinMax = function($$, type, value) {
	var config = $$.config,
		axisY = "axis_y_" + type,
		axisY2 = "axis_y2_" + type;

	return (0, _util.isDefined)(value) && ((0, _util.isObjectType)(value) ? ((0, _util.isValue)(value.x) && (config["axis_x_" + type] = value.x), (0, _util.isValue)(value.y) && (config[axisY] = value.y), (0, _util.isValue)(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
		withUpdateOrgXDomain: !0,
		withUpdateXDomain: !0
	})), undefined;
},
	getMinMax = function($$, type) {
	var config = $$.config;

	return {
		x: config["axis_x_" + type],
		y: config["axis_y_" + type],
		y2: config["axis_y2_" + type]
	};
},
	axis = (0, _util.extend)(function () {}, {
	/**
* Get and set axis labels.
* @method axis․labels
* @instance
* @memberOf Chart
* @param {Object} labels specified axis' label to be updated.
* @example
* // Update axis' label
* chart.axis.labels({
*   x: "New X Axis Label",
*   y: "New Y Axis Label"
* });
*/
	labels: function labels(_labels) {
		var $$ = this.internal;

		arguments.length && (Object.keys(_labels).forEach(function (axisId) {
			$$.axis.setLabelText(axisId, _labels[axisId]);
		}), $$.axis.updateLabels());
	},

	/**
* Get and set axis min value.
* @method axis․min
* @instance
* @memberOf Chart
* @param {Object} min If min is given, specified axis' min value will be updated.<br>
*     If no argument is given, the min values set on generating option for each axis will be returned.
*     If not set any min values on generation, it will return `undefined`.
* @example
* // Update axis' min
* chart.axis.min({
*   x: -10,
*   y: 1000,
*   y2: 100
* });
*/
	min: function min(_min) {
		var $$ = this.internal;

		return arguments.length ? setMinMax($$, "min", _min) : getMinMax($$, "min");
	},

	/**
* Get and set axis max value.
* @method axis․max
* @instance
* @memberOf Chart
* @param {Object} max If max is given, specified axis' max value will be updated.<br>
*     If no argument is given, the max values set on generating option for each axis will be returned.
*     If not set any max values on generation, it will return `undefined`.
* @example
* // Update axis' label
* chart.axis.max({
*    x: 100,
*    y: 1000,
*    y2: 10000
* });
*/
	max: function max(_max) {
		var $$ = this.internal;

		return arguments.length ? setMinMax($$, "max", _max) : getMinMax($$, "max");
	},

	/**
* Get and set axis min and max value.
* @method axis․range
* @instance
* @memberOf Chart
* @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
* @example
* // Update axis' label
* chart.axis.range({
*   min: {
*     x: -10,
*     y: -1000,
*     y2: -10000
*   },
*   max: {
*     x: 100,
*     y: 1000,
*     y2: 10000
*   },
* });
*/
	range: function range(_range) {
		var axis = this.axis;

		if (arguments.length) (0, _util.isDefined)(_range.max) && axis.max(_range.max), (0, _util.isDefined)(_range.min) && axis.min(_range.min);else return {
				max: axis.max(),
				min: axis.min()
			};

		return undefined;
	}
});

/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */

/**
 * Define axis
 */
(0, _util.extend)(_Chart2.default.prototype, { axis: axis });

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Define legend
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var legend = (0, _util.extend)(function () {}, {
	/**
* Show legend for each target.
* @method legend․show
* @instance
* @memberOf Chart
* @param {String|Array} targetIds
* - If targetIds is given, specified target's legend will be shown.
* - If only one target is the candidate, String can be passed.
* - If no argument is given, all of target's legend will be shown.
* @example
* // Show legend for data1.
* chart.legend.show("data1");
*
* // Show legend for data1 and data2.
* chart.legend.show(["data1", "data2"]);
*
* // Show all legend.
* chart.legend.show();
*/
	show: function show(targetIds) {
		var $$ = this.internal;

		$$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({ withLegend: !0 });
	},

	/**
* Hide legend for each target.
* @method legend․hide
* @instance
* @memberOf Chart
* @param {String|Array} targetIds
* - If targetIds is given, specified target's legend will be hidden.
* - If only one target is the candidate, String can be passed.
* - If no argument is given, all of target's legend will be hidden.
* @example
* // Hide legend for data1.
* chart.legend.hide("data1");
*
* // Hide legend for data1 and data2.
* chart.legend.hide(["data1", "data2"]);
*
* // Hide all legend.
* chart.legend.hide();
*/
	hide: function hide(targetIds) {
		var $$ = this.internal;

		$$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({ withLegend: !0 });
	}
});

(0, _util.extend)(_Chart2.default.prototype, { legend: legend });

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_browser = __webpack_require__(61),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Resize the chart.
* @method resize
* @instance
* @memberOf Chart
* @param {Object} size This argument should include width and height in pixels.
* @example
* // Resize to 640x480
* chart.resize({
*    width: 640,
*    height: 480
* });
*/
	resize: function resize(size) {
		var config = this.internal.config;

		config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush();
	},

	/**
* Force to redraw.
* @method flush
* @instance
* @memberOf Chart
* @example
* chart.flush();
*/
	flush: function flush() {
		this.internal.updateAndRedraw({
			withLegend: !0,
			withTransition: !1,
			withTransitionForTransform: !1
		});
	},

	/**
* Reset the chart object and remove element and events completely.
* @method destroy
* @instance
* @memberOf Chart
* @example
* chart.destroy();
*/
	destroy: function destroy() {
		var _this = this,
			$$ = this.internal;

		return $$.charts.splice($$.charts.indexOf(this), 1), _browser.window.clearInterval($$.intervalForObserveInserted), $$.resizeTimeout !== undefined && _browser.window.clearTimeout($$.resizeTimeout), (0, _util.removeEvent)(_browser.window, "resize", $$.resizeFunction), $$.selectChart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
			key === "internal" && Object.keys($$).forEach(function (k) {
				$$[k] = null;
			}), _this[key] = null, delete _this[key];
		}), null;
	}
}); /**
	 * Copyright (c) 2017 NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = !0;
exports.document = exports.window = undefined;

var _util = __webpack_require__(6),
	win = (0, _util.isDefined)(window) && window.Math === Math ? window : (0, _util.isDefined)(self) && (self.Math === Math ? self : Function("return this")()),
	doc = win.document;

/**
 * Window object
 * @module
 * @ignore
 */
/* eslint-disable no-new-func */

/* eslint-enable no-new-func */

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
exports.window = win;
exports.document = doc;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Define tooltip
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var tooltip = (0, _util.extend)(function () {}, {
	/**
* Show tooltip
* @method tooltip․show
* @instance
* @memberOf Chart
* @param {Object} args The object can consist with following members:<br>
*
*    | Key | Type | Description |
*    | --- | --- | --- |
*    | index | Number | Determine focus by index |
*    | x | Number|Date | Determine focus by x Axis index |
*    | data | Object | Determine focus data with following keys: `x` or `index`.<br>When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is set, the target is determined by mouse position and needs specify `x`, `id` and `value`. |
*    | mouse | Array | Determine x and y coordinate value relative the targeted x Axis element.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
*
* @example
*  // show the 2nd x Axis coordinate tooltip
*  chart.tooltip.show({
*    index: 1
*  });
*
*  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate relative the x Axis element.
*  chart.tooltip.show({
*    data: {x: 2},
*    mouse: [50, 100]
*  });
*
*  // show tooltip for timeseries x axis
*  chart.tooltip.show({
*    x: new Date("2018-01-02 00:00")
*  });
*/
	show: function show() {
		var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			$$ = this.internal,
			index = void 0,
			mouse = void 0;

		// determine mouse position on the chart
		args.mouse && (mouse = args.mouse), args.data ? $$.isMultipleX() ? (mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)], index = null) : index = (0, _util.isValue)(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x) : (0, _util.isDefined)(args.x) ? index = $$.getIndexByX(args.x) : (0, _util.isDefined)(args.index) && (index = args.index), ["mouseover", "mousemove"].forEach(function (eventName) {
			$$.dispatchEvent(eventName, index, mouse);
		});
	},

	/**
* Hide tooltip
* @method tooltip․hide
* @instance
* @memberOf Chart
*/
	hide: function hide() {
		var $$ = this.internal;

		$$.hideTooltip(), $$.hideXGridFocus();
	}
});

(0, _util.extend)(_Chart2.default.prototype, { tooltip: tooltip });

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _ChartInternal = __webpack_require__(3),
	_ChartInternal2 = _interopRequireDefault(_ChartInternal),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var ua = window.navigator.userAgent;

(0, _util.extend)(_ChartInternal2.default.prototype, {
	isSafari: function isSafari() {
		return ua.indexOf("Safari") > -1 && !this.isChrome();
	},
	isChrome: function isChrome() {
		return ua.indexOf("Chrome") > -1;
	},
	isMobile: function isMobile() {
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
		return ua.indexOf("Mobi") > -1;
	}
});

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _d3Selection = __webpack_require__(4),
	_Chart = __webpack_require__(1),
	_Chart2 = _interopRequireDefault(_Chart),
	_util = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */
var b64EncodeUnicode = function(str) {
	return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p) {
		return String.fromCharCode("0x" + p);
	}));
},
	nodeToSvgDataUrl = function(node) {
	var bounds = node.getBoundingClientRect(),
		clone = node.cloneNode(!0),
		styleSheets = (0, _util.toArray)(document.styleSheets),
		cssRules = (0, _util.getCssRules)(styleSheets),
		cssText = cssRules.filter(function (r) {
		return r.cssText;
	}).map(function (r) {
		return r.cssText;
	});
	clone.setAttribute("xmlns", _d3Selection.namespaces.xhtml);

	var nodeXml = new XMLSerializer().serializeToString(clone),
		dataStr = ("<svg xmlns=\"" + _d3Selection.namespaces.svg + "\" width=\"" + bounds.width + "\" height=\"" + bounds.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t<style>" + cssText.join("\n") + "</style>\n\t\t\t\t" + nodeXml + "\n\t\t\t</foreignObject></svg>").replace(/#/g, "%23").replace("/\n/g", "%0A");

	// foreignObject not supported in IE11 and below
	// https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

	return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
};

/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @return {String}
 * @private
 */
/**
 * Copyright (c) 2017 NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
(0, _util.extend)(_Chart2.default.prototype, {
	/**
* Export chart as an image.
* - **NOTE:** IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
*
* @method export
* @instance
* @memberOf Chart
* @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
* @param {Function} [callback] The callback to be invoked when export is ready.
* @return {String} dataURI
* @example
*  chart.export();
*  // --> "data:image/svg+xml;base64,PHN..."
*
*  // Initialize the download automatically
*  chart.export("image/png", dataUrl => {
*     const link = document.createElement("a");
*
*     link.download = `${Date.now()}.png`;
*     link.href = dataUrl;
*     link.innerHTML = "Download chart as image";
*
*     document.body.appendChild(link);
*  });
*/
	export: function _export() {
		var mimeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "image/png",
			callback = arguments[1],
			svgDataUrl = nodeToSvgDataUrl(this.element);

		if ((0, _util.isFunction)(callback)) {
			var img = new Image();

			img.crosssOrigin = "Anonymous", img.onload = function() {
				var canvas = document.createElement("canvas"),
					ctx = canvas.getContext("2d");
				canvas.width = img.width, canvas.height = img.height, ctx.drawImage(img, 0, 0), canvas.toBlob(function (blob) {
					callback(window.URL.createObjectURL(blob));
				}, mimeType);
			}, img.src = svgDataUrl;
		}

		return svgDataUrl;
	}
});

/***/ })
/******/ ]);
});
//# sourceMappingURL=billboard.js.map

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(19);

Object.keys(_coreNamed).forEach(function (key) {
if (key === "default" || key === "__esModule") return;
Object.defineProperty(exports, key, {
	enumerable: true,
	get: function get() {
	  return _coreNamed[key];
	}
});
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Set of utilities for array operations
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function() {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
* Checks if the given arrays have the same content.
* @param {!Array<*>} arr1
* @param {!Array<*>} arr2
* @return {boolean}
*/
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
* Returns the first value in the given array that isn't undefined.
* @param {!Array} arr
* @return {*}
*/

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
* Transforms the input nested array to become flat.
* @param {Array.<*|Array.<*>>} arr Nested array to flatten.
* @param {Array.<*>=} output Optional output array.
* @return {Array.<*>} Flat array.
*/

	}, {
		key: 'flatten',
		value: function flatten(arr) {
			var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
* Removes the first occurrence of a particular value from an array.
* @param {Array.<T>} arr Array from which to remove value.
* @param {T} obj Object to remove.
* @return {boolean} True if an element was removed.
* @template T
*/

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
* Removes from an array the element at index i
* @param {Array} arr Array or array like object from which to remove value.
* @param {number} i The index to remove.
* @return {boolean} True if an element was removed.
*/

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
* Slices the given array, just like Array.prototype.slice, but this
* is faster and working on all array-like objects (like arguments).
* @param {!Object} arr Array-like object to slice.
* @param {number} start The index that should start the slice.
* @param {number=} end The index where the slice should end, not
*   included in the final array. If not given, all elements after the
*   start index will be included.
* @return {!Array}
*/

	}, {
		key: 'slice',
		value: function slice(arr, start) {
			var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;

			var sliced = [];
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* !
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _coreNamed = __webpack_require__(19);

var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function(exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function(callback, context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function() {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function(fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function(callback, context) {
	var cb = callback;
	if (context) {
		cb = callback.bind(context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		if (typeof setImmediate === 'function' && (0, _coreNamed.isServerSide)({ checkEnv: false })) {
			async.nextTick.setImmediate_ = setImmediate;
		} else {
			// eslint-disable-next-line
			async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
		}
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function() {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function(such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function(e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function() {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function(cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function(cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function() {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function(cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function(callback) {
	return callback;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37).setImmediate))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
if (timeout) {
	timeout.close();
}
};

function Timeout(id, clearFn) {
this._id = id;
this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
clearTimeout(item._idleTimeoutId);
item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
clearTimeout(item._idleTimeoutId);
item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
clearTimeout(item._idleTimeoutId);

var msecs = item._idleTimeout;
if (msecs >= 0) {
	item._idleTimeoutId = setTimeout(function onTimeout() {
	  if (item._onTimeout)
		item._onTimeout();
	}, msecs);
}
};

// setimmediate attaches itself to the global object
__webpack_require__(38);
// On some exotic environments, it's not clear which object `setimmeidate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
					   (typeof global !== "undefined" && global.setImmediate) ||
					   (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
						 (typeof global !== "undefined" && global.clearImmediate) ||
						 (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	"use strict";

	if (global.setImmediate) {
		return;
	}

	var nextHandle = 1; // Spec says greater than zero
	var tasksByHandle = {};
	var currentlyRunningATask = false;
	var doc = global.document;
	var registerImmediate;

	function setImmediate(callback) {
	  // Callback can either be a function or a string
	  if (typeof callback !== "function") {
		callback = new Function("" + callback);
	  }
	  // Copy function arguments
	  var args = new Array(arguments.length - 1);
	  for (var i = 0; i < args.length; i++) {
		  args[i] = arguments[i + 1];
	  }
	  // Store and register the task
	  var task = { callback: callback, args: args };
	  tasksByHandle[nextHandle] = task;
	  registerImmediate(nextHandle);
	  return nextHandle++;
	}

	function clearImmediate(handle) {
		delete tasksByHandle[handle];
	}

	function run(task) {
		var callback = task.callback;
		var args = task.args;
		switch (args.length) {
		case 0:
			callback();
			break;
		case 1:
			callback(args[0]);
			break;
		case 2:
			callback(args[0], args[1]);
			break;
		case 3:
			callback(args[0], args[1], args[2]);
			break;
		default:
			callback.apply(undefined, args);
			break;
		}
	}

	function runIfPresent(handle) {
		// From the spec: "Wait until any invocations of this algorithm started before this one have completed."
		// So if we're currently running a task, we'll need to delay this invocation.
		if (currentlyRunningATask) {
			// Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
			// "too much recursion" error.
			setTimeout(runIfPresent, 0, handle);
		} else {
			var task = tasksByHandle[handle];
			if (task) {
				currentlyRunningATask = true;
				try {
					run(task);
				} finally {
					clearImmediate(handle);
					currentlyRunningATask = false;
				}
			}
		}
	}

	function installNextTickImplementation() {
		registerImmediate = function(handle) {
			process.nextTick(function () { runIfPresent(handle); });
		};
	}

	function canUsePostMessage() {
		// The test against `importScripts` prevents this implementation from being installed inside a web worker,
		// where `global.postMessage` means something completely different and can't be used for this purpose.
		if (global.postMessage && !global.importScripts) {
			var postMessageIsAsynchronous = true;
			var oldOnMessage = global.onmessage;
			global.onmessage = function() {
				postMessageIsAsynchronous = false;
			};
			global.postMessage("", "*");
			global.onmessage = oldOnMessage;
			return postMessageIsAsynchronous;
		}
	}

	function installPostMessageImplementation() {
		// Installs an event handler on `global` for the `message` event: see
		// * https://developer.mozilla.org/en/DOM/window.postMessage
		// * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

		var messagePrefix = "setImmediate$" + Math.random() + "$";
		var onGlobalMessage = function(event) {
			if (event.source === global &&
				typeof event.data === "string" &&
				event.data.indexOf(messagePrefix) === 0) {
				runIfPresent(+event.data.slice(messagePrefix.length));
			}
		};

		if (global.addEventListener) {
			global.addEventListener("message", onGlobalMessage, false);
		} else {
			global.attachEvent("onmessage", onGlobalMessage);
		}

		registerImmediate = function(handle) {
			global.postMessage(messagePrefix + handle, "*");
		};
	}

	function installMessageChannelImplementation() {
		var channel = new MessageChannel();
		channel.port1.onmessage = function(event) {
			var handle = event.data;
			runIfPresent(handle);
		};

		registerImmediate = function(handle) {
			channel.port2.postMessage(handle);
		};
	}

	function installReadyStateChangeImplementation() {
		var html = doc.documentElement;
		registerImmediate = function(handle) {
			// Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
			// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
			var script = doc.createElement("script");
			script.onreadystatechange = function() {
				runIfPresent(handle);
				script.onreadystatechange = null;
				html.removeChild(script);
				script = null;
			};
			html.appendChild(script);
		};
	}

	function installSetTimeoutImplementation() {
		registerImmediate = function(handle) {
			setTimeout(runIfPresent, 0, handle);
		};
	}

	// If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

	// Don't get fooled by e.g. browserify environments.
	if ({}.toString.call(global.process) === "[object process]") {
		// For Node.js before 0.9
		installNextTickImplementation();

	} else if (canUsePostMessage()) {
		// For non-IE10 modern browsers
		installPostMessageImplementation();

	} else if (global.MessageChannel) {
		// For web workers, where supported
		installMessageChannelImplementation();

	} else if (doc && "onreadystatechange" in doc.createElement("script")) {
		// For IE 6–8
		installReadyStateChangeImplementation();

	} else {
		// For older browsers
		installSetTimeoutImplementation();
	}

	attachTo.setImmediate = setImmediate;
	attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), __webpack_require__(14)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function() {
	/**
* Disposable constructor
*/
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
* Flag indicating if this instance has already been disposed.
* @type {boolean}
* @protected
*/
		this.disposed_ = false;
	}

	/**
* Disposes of this instance's object references. Calls `disposeInternal`.
*/

	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
* Subclasses should override this method to implement any specific
* disposing logic (like clearing references and calling `dispose` on other
* disposables).
*/

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
* Checks if this instance has already been disposed.
* @return {boolean}
*/

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Set of utilities for object operations
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function() {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
* Copies all the members of a source object to a target object.
* @param {Object} target Target object.
* @param {...Object} var_args The objects from which values will be copied.
* @return {Object} Returns the target object reference.
*/
		value: function mixin(target) {
			var key = void 0;
			var source = void 0;

			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			for (var i = 0; i < args.length; i++) {
				source = args[i];
				// Possible prototype chain leak, breaks 1 metal-dom and
				// 1 metal-incremental-dom test if guard-for-in rule is addressed
				// eslint-disable-next-line
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
* Returns an object based on its fully qualified external name.
* @param {string} name The fully qualified name.
* @param {object=} scope The object within which to look; default is
*     <code>window</code>.
* @return {?} The value (object or primitive) or, if not found, undefined.
*/

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name) {
			var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
* Returns a new object with the same keys as the given one, but with
* their values set to the return values of the specified function.
* @param {!Object} obj
* @param {!function(string, *)} fn
* @return {!Object}
*/

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
* Checks if the two given objects are equal. This is done via a shallow
* check, including only the keys directly contained by the 2 objects.
* @param {Object} obj1
* @param {Object} obj2
* @return {boolean}
*/

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Set of utilities for string operations
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function() {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
* Compares the given strings without taking the case into account.
* @param {string|number} str1
* @param {string|number} str2
* @return {number} Either -1, 0 or 1, according to if the first string is
*     "smaller", equal or "bigger" than the second given string.
*/
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
* Removes the breaking spaces from the left and right of the string and
* collapses the sequences of breaking spaces in the middle into single spaces.
* The original and the result strings render the same way in HTML.
* @param {string} str A string in which to collapse spaces.
* @return {string} Copy of the string with normalized breaking spaces.
*/

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
* Escapes characters in the string that are not safe to use in a RegExp.
* @param {*} str The string to escape. If not a string, it will be casted
*     to one.
* @return {string} A RegExp safe, escaped copy of {@code s}.
*/

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08'); // eslint-disable-line
		}

		/**
* Returns a string with at least 64-bits of randomness.
* @return {string} A random string, e.g. sn1s7vb4gcic.
*/

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
* Calculates the hashcode for a string. The hashcode value is computed by
* the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
* property of using 31 prime is that the multiplication can be replaced by
* a shift and a subtraction for better performance: 31*i == (i<<5)-i.
* Modern VMs do this sort of optimization automatically.
* @param {String} val Target string.
* @return {Number} Returns the string hashcode.
*/

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
* Replaces interval into the string with specified value, e.g.
* `replaceInterval("abcde", 1, 4, "")` returns "ae".
* @param {string} str The input string.
* @param {Number} start Start interval position to be replaced.
* @param {Number} end End interval position to be replaced.
* @param {string} value The value that replaces the specified interval.
* @return {string}
*/

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _validators = __webpack_require__(18);

var _validators2 = _interopRequireDefault(_validators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sugar api that can be used as an alternative for manually building `State`
 * configuration in the expected format. For example, instead of having
 * something like this:
 *
 * ```js
 * MyClass.STATE = {
 *   foo: {
 *     required: true,
 *     validator: validators.number,
 *     value: 13
 *   }
 * };
 * ```
 *
 * You could instead do:
 *
 * ```js
 * MyClass.STATE = {
 *   foo: Config.required().number().value(13)
 * };
 * ```
 */
var Config = {
	/**
* An object that contains a validator function.
* @typedef {!Object} ConfigWithValidator
*/

	/**
* Function that creates `State` object with an `any` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	any: setPrimitiveValidators('any'),

	/**
* Function that creates `State` object with an `array` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	array: setPrimitiveValidators('array'),

	/**
* Function that creates `State` object with an `arrayOf` validator.
* @param {ConfigWithValidator} stateConfig `State` configuration object
* @return {ConfigWithValidator} `State` configuration object.
*/
	arrayOf: setNestedValidators('arrayOf'),

	/**
* Function that creates `State` object with a `bool` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	bool: setPrimitiveValidators('bool'),

	/**
* Function that creates `State` object with a `func` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	func: setPrimitiveValidators('func'),

	/**
* Creates `State` configuration object with a `rangeOf` validator.
* @param {!Number} min The minimum value allowed.
* @param {!Number} max The maximum value allowed.
* @return {ConfigWithValidator} `State` configuration object.
*/
	inRange: function inRange(min, max) {
		return this.validator(_validators2.default.inRange(min, max));
	},

	/**
* Function that creates `State` object with an `instanceOf` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	instanceOf: setExplicitValueValidators('instanceOf'),

	/**
* Function that creates `State` object with a `number` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	number: setPrimitiveValidators('number'),

	/**
* Function that creates `State` object with an `object` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	object: setPrimitiveValidators('object'),

	/**
* Function that creates `State` object with an `objectOf` validator.
* @param {ConfigWithValidator} stateConfig `State` configuration object
* @return {ConfigWithValidator} `State` configuration object.
*/
	objectOf: setNestedValidators('objectOf'),

	/**
* Function that creates `State` object with an `oneOf` validator.
* @param {!Array} values `State` configuration object
* @return {ConfigWithValidator} `State` configuration object.
*/
	oneOf: setExplicitValueValidators('oneOf'),

	/**
* Creates `State` configuration object with an `oneOfType` validator.
* @param {ConfigWithValidator[]} validatorArray Array of `State` configuration objects.
* @return {ConfigWithValidator} `State` configuration object.
*/
	oneOfType: function oneOfType(validatorArray) {
		validatorArray = validatorArray.map(function (configObj) {
			return configObj.config.validator;
		});

		return this.validator(_validators2.default.oneOfType(validatorArray));
	},

	/**
* Creates `State` configuration object with a `shapeOf` validator.
* @param {!Object.<string, ConfigWithValidator>} shapeObj Values being `State` configuration objects.
* @return {ConfigWithValidator} `State` configuration object.
*/
	shapeOf: function shapeOf(shapeObj) {
		shapeObj = destructShapeOfConfigs(shapeObj);

		return this.validator(_validators2.default.shapeOf(shapeObj));
	},

	/**
* Function that creates `State` object with an `string` validator.
* @return {ConfigWithValidator} `State` configuration object.
*/
	string: setPrimitiveValidators('string'),

	/**
* Adds the `internal` flag to the `State` configuration.
* @param {boolean} internal Flag to set "internal" to. True by default.
* @return {!Object} `State` configuration object.
*/
	internal: function internal() {
		var internal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

		return mergeConfig(this, {
			internal: internal
		});
	},

	/**
* Adds the `required` flag to the `State` configuration.
* @param {boolean} required Flag to set "required" to. True by default.
* @return {!Object} `State` configuration object.
*/
	required: function required() {
		var required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

		return mergeConfig(this, {
			required: required
		});
	},

	/**
* Adds a setter to the `State` configuration.
* @param {!function()} setter
* @return {!Object} `State` configuration object.
*/
	setter: function setter(_setter) {
		return mergeConfig(this, {
			setter: _setter
		});
	},

	/**
* Adds a validator to the `State` configuration.
* @param {!function()} validator
* @return {!Object} `State` configuration object.
*/
	validator: function validator(_validator) {
		return mergeConfig(this, {
			validator: _validator
		});
	},

	/**
* Adds a default value to the `State` configuration.
* @param {*} value
* @return {!Object} `State` configuration object.
*/
	value: function value(_value) {
		return mergeConfig(this, {
			value: _value
		});
	},

	/**
* Adds a valueFn that will return a default value for the `State` configuration.
* @param {!function()} valueFn
* @return {!Object} `State` configuration object.
*/
	valueFn: function valueFn(_valueFn) {
		return mergeConfig(this, {
			valueFn: _valueFn
		});
	},

	/**
* Adds the `writeOnce` flag to the `State` configuration.
* @param {boolean} writeOnce Flag to set "writeOnce" to. False by default.
* @return {!Object} `State` configuration object.
*/
	writeOnce: function writeOnce() {
		var writeOnce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		return mergeConfig(this, {
			writeOnce: writeOnce
		});
	}
};

/**
 * Recursively sets validators for shapeOf.
 * @param {!Object} shape The shape of specific types.
 * @return {!Object} Shape object with validators as values.
 */
function destructShapeOfConfigs(shape) {
	var keys = Object.keys(shape);

	var retShape = {};

	keys.forEach(function (key) {
		var value = shape[key];

		retShape[key] = value.config && value.config.validator ? value.config.validator : destructShapeOfConfigs(value);
	});

	return retShape;
}

/**
 * Merges the given config object into the one that has been built so far.
 * @param {!Object} context The object calling this function.
 * @param {!Object} config The object to merge to the built config.
 * @return {!Object} The final object containing the built config.
 */
function mergeConfig(context, config) {
	var obj = context;
	var objConfig = obj.config || {};

	obj = Object.create(Config);
	obj.config = {};

	Object.assign(obj.config, objConfig, config);
	return obj;
}

/**
 * Calls validators with provided argument.
 * @param {string} name The name of the validator.
 * @return {function()}
 */
function setExplicitValueValidators(name) {
	return function(arg) {
		return this.validator(_validators2.default[name](arg));
	};
}

/**
 * Calls validators with a single nested config.
 * @param {string} name The name of the validator.
 * @return {!function()}
 */
function setNestedValidators(name) {
	return function(arg) {
		return this.validator(_validators2.default[name](arg.config.validator));
	};
}

/**
 * Adds primitive type validators to the config object.
 * @param {string} name The name of the validator.
 * @return {!function()}
 */
function setPrimitiveValidators(name) {
	return function() {
		return this.validator(_validators2.default[name]);
	};
}

exports.default = Config;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _metal = __webpack_require__(1);

var _metalEvents = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * State adds support for having object properties that can be watched for
 * changes, as well as configured with validators, setters and other options.
 * See the `configState` method for a complete list of available configuration
 * options for each state key.
 * @extends {EventEmitter}
 */
var State = function(_EventEmitter) {
	_inherits(State, _EventEmitter);

	/**
* Constructor function for `State`.
* @param {Object=} config Optional config object with initial values to
*     set state properties to.
* @param {Object=} obj Optional object that should hold the state
*     properties. If none is given, they will be added directly to `this`
*     instead.
* @param {Object=} context Optional context to call functions (like
*     validators and setters) on. Defaults to `this`.
*/
	function State(config, obj, context) {
		_classCallCheck(this, State);

		/**
* Context to call functions (like validators and setters) on.
* @type {!Object}
* @protected
*/
		var _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));

		_this.context_ = context || _this;

		/**
* Map of keys that can not be used as state keys.
* @type {Object<string, boolean>}
* @protected
*/
		_this.keysBlacklist_ = null;

		/**
* Object that should hold the state properties.
* @type {!Object}
* @protected
*/
		_this.obj_ = obj || _this;

		_this.eventData_ = null;

		/**
* Object with information about the batch event that is currently
* scheduled, or null if none is.
* @type {Object}
* @protected
*/
		_this.scheduledBatchData_ = null;

		/**
* Object that contains information about all this instance's state keys.
* @type {!Object<string, !Object>}
* @protected
*/
		_this.stateInfo_ = {};

		_this.stateConfigs_ = {};

		_this.initialValues_ = _metal.object.mixin({}, config);

		_this.setShouldUseFacade(true);
		_this.configStateFromStaticHint_();

		Object.defineProperty(_this.obj_, State.STATE_REF_KEY, {
			configurable: true,
			enumerable: false,
			value: _this
		});
		return _this;
	}

	/**
* Logs an error if the given property is required but wasn't given.
* @param {string} name
* @protected
*/

	_createClass(State, [{
		key: 'assertGivenIfRequired_',
		value: function assertGivenIfRequired_(name) {
			var config = this.stateConfigs_[name];
			if (config.required) {
				var info = this.getStateInfo(name);
				var value = info.state === State.KeyStates.INITIALIZED ? this.get(name) : this.initialValues_[name];
				if (!(0, _metal.isDefAndNotNull)(value)) {
					var errorMessage = 'The property called "' + name + '" is required but didn\'t receive a value.';
					if (this.shouldThrowValidationError()) {
						throw new Error(errorMessage);
					} else {
						console.error(errorMessage);
					}
				}
			}
		}

		/**
* Logs an error if the `validatorReturn` is instance of `Error`.
* @param {*} validatorReturn
* @protected
*/

	}, {
		key: 'assertValidatorReturnInstanceOfError_',
		value: function assertValidatorReturnInstanceOfError_(validatorReturn) {
			if (validatorReturn instanceof Error) {
				if (this.shouldThrowValidationError()) {
					throw validatorReturn;
				} else {
					console.error('Warning: ' + validatorReturn);
				}
			}
		}

		/**
* Checks that the given name is a valid state key name. If it's not, an error
* will be thrown.
* @param {string} name The name to be validated.
* @throws {Error}
* @protected
*/

	}, {
		key: 'assertValidStateKeyName_',
		value: function assertValidStateKeyName_(name) {
			if (this.keysBlacklist_ && this.keysBlacklist_[name]) {
				throw new Error('It\'s not allowed to create a state key with the name "' + name + '".');
			}
		}

		/**
* Builds the property definition object for the specified state key.
* @param {string} name The name of the key.
* @return {!Object}
* @protected
*/

	}, {
		key: 'buildKeyPropertyDef_',
		value: function buildKeyPropertyDef_(name) {
			return {
				configurable: true,
				enumerable: true,
				get: function get() {
					return this[State.STATE_REF_KEY].getStateKeyValue_(name);
				},
				set: function set(val) {
					this[State.STATE_REF_KEY].setStateKeyValue_(name, val);
				}
			};
		}

		/**
* Calls the requested function, running the appropriate code for when it's
* passed as an actual function object or just the function's name.
* @param {!Function|string} fn Function, or name of the function to run.
* @param {!Array} args optional array of parameters to be passed to the
*   function that will be called.
* @return {*} The return value of the called function.
* @protected
*/

	}, {
		key: 'callFunction_',
		value: function callFunction_(fn, args) {
			if ((0, _metal.isString)(fn)) {
				return this.context_[fn].apply(this.context_, args); // eslint-disable-line
			} else if ((0, _metal.isFunction)(fn)) {
				return fn.apply(this.context_, args);
			}
		}

		/**
* Calls the state key's setter, if there is one.
* @param {string} name The name of the key.
* @param {*} value The value to be set.
* @param {*} currentValue The current value.
* @return {*} The final value to be set.
* @protected
*/

	}, {
		key: 'callSetter_',
		value: function callSetter_(name, value, currentValue) {
			var config = this.stateConfigs_[name];
			if (config.setter) {
				value = this.callFunction_(config.setter, [value, currentValue]);
			}
			return value;
		}

		/**
* Calls the state key's validator, if there is one. Emits console
* warning if validator returns a string.
* @param {string} name The name of the key.
* @param {*} value The value to be validated.
* @return {boolean} Flag indicating if value is valid or not.
* @protected
*/

	}, {
		key: 'callValidator_',
		value: function callValidator_(name, value) {
			var config = this.stateConfigs_[name];
			if (config.validator) {
				var validatorReturn = this.callFunction_(config.validator, [value, name, this.context_]);
				this.assertValidatorReturnInstanceOfError_(validatorReturn);
				return validatorReturn;
			}
			return true;
		}

		/**
* Checks if the it's allowed to write on the requested state key.
* @param {string} name The name of the key.
* @return {boolean}
*/

	}, {
		key: 'canSetState',
		value: function canSetState(name) {
			var info = this.getStateInfo(name);
			return !this.stateConfigs_[name].writeOnce || !info.written;
		}

		/**
* Adds the given key(s) to the state, together with its(their) configs.
* Config objects support the given settings:
*     required - When set to `true`, causes errors to be printed (via
*     `console.error`) if no value is given for the property.
*
*     setter - Function for normalizing state key values. It receives the new
*     value that was set, and returns the value that should be stored.
*
*     validator - Function that validates state key values. When it returns
*     false, the new value is ignored. When it returns an instance of Error,
*     it will emit the error to the console.
*
*     value - The default value for the state key. Note that setting this to
*     an object will cause all class instances to use the same reference to
*     the object. To have each instance use a different reference for objects,
*     use the `valueFn` option instead.
*
*     valueFn - A function that returns the default value for a state key.
*
*     writeOnce - Ignores writes to the state key after it's been first
*     written to. That is, allows writes only when setting the value for the
*     first time.
* @param {!Object.<string, !Object>|string} configs An object that maps
*     configuration options for keys to be added to the state.
* @param {boolean|Object|*=} context The context where the added state
*     keys will be defined (defaults to `this`), or false if they shouldn't
*     be defined at all.
*/

	}, {
		key: 'configState',
		value: function configState(configs, context) {
			var names = Object.keys(configs);
			if (names.length === 0) {
				return;
			}

			if (context !== false) {
				var props = {};
				for (var i = 0; i < names.length; i++) {
					var name = names[i];
					this.assertValidStateKeyName_(name);
					props[name] = this.buildKeyPropertyDef_(name);
				}
				Object.defineProperties(context || this.obj_, props);
			}

			this.stateConfigs_ = configs;
			for (var _i = 0; _i < names.length; _i++) {
				var _name = names[_i];
				configs[_name] = configs[_name].config ? configs[_name].config : configs[_name];
				this.assertGivenIfRequired_(names[_i]);
				this.validateInitialValue_(names[_i]);
			}
		}

		/**
* Adds state keys from super classes static hint `MyClass.STATE = {};`.
* @protected
*/

	}, {
		key: 'configStateFromStaticHint_',
		value: function configStateFromStaticHint_() {
			var ctor = this.constructor;
			if (ctor !== State) {
				var defineContext = void 0;
				if (this.obj_ === this) {
					var staticKey = State.STATE_STATIC_HINT_CONFIGURED;

					ctor[staticKey] = ctor[staticKey] || {};

					defineContext = ctor[staticKey][ctor.name] ? false : ctor.prototype; // eslint-disable-line
					ctor[staticKey][ctor.name] = true;
				}
				this.configState(State.getStateStatic(ctor), defineContext);
			}
		}

		/**
* @inheritDoc
*/

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			_get(State.prototype.__proto__ || Object.getPrototypeOf(State.prototype), 'disposeInternal', this).call(this);
			this.initialValues_ = null;
			this.stateInfo_ = null;
			this.stateConfigs_ = null;
			this.scheduledBatchData_ = null;
		}

		/**
* Emits the state change batch event.
* @protected
*/

	}, {
		key: 'emitBatchEvent_',
		value: function emitBatchEvent_() {
			if (!this.isDisposed()) {
				this.context_.emit('stateWillChange', this.scheduledBatchData_);

				var data = this.scheduledBatchData_;
				this.scheduledBatchData_ = null;
				this.context_.emit('stateChanged', data);
			}
		}

		/**
* Returns the value of the requested state key.
* Note: this can and should be accomplished by accessing the value as a
* regular property. This should only be used in cases where a function is
* actually needed.
* @param {string} name
* @return {*}
*/

	}, {
		key: 'get',
		value: function get(name) {
			return this.obj_[name];
		}

		/**
* Returns an object that maps state keys to their values.
* @param {Array<string>=} names A list of names of the keys that should
*   be returned. If none is given, the whole state will be returned.
* @return {Object.<string, *>}
*/

	}, {
		key: 'getState',
		value: function getState() {
			var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getStateKeys();

			var state = {};

			for (var i = 0; i < names.length; i++) {
				state[names[i]] = this.get(names[i]);
			}

			return state;
		}

		/**
* Gets information about the specified state property.
* @param {string} name
* @return {!Object}
*/

	}, {
		key: 'getStateInfo',
		value: function getStateInfo(name) {
			if (!this.stateInfo_[name]) {
				this.stateInfo_[name] = {};
			}
			return this.stateInfo_[name];
		}

		/**
* Gets the config object for the requested state key.
* @param {string} name The key's name.
* @return {Object}
* @protected
*/

	}, {
		key: 'getStateKeyConfig',
		value: function getStateKeyConfig(name) {
			return this.stateConfigs_ ? this.stateConfigs_[name] : null;
		}

		/**
* Returns an array with all state keys.
* @return {!Array.<string>}
*/

	}, {
		key: 'getStateKeys',
		value: function getStateKeys() {
			return this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];
		}

		/**
* Gets the value of the specified state key. This is passed as that key's
* getter to the `Object.defineProperty` call inside the `addKeyToState` method.
* @param {string} name The name of the key.
* @return {*}
* @protected
*/

	}, {
		key: 'getStateKeyValue_',
		value: function getStateKeyValue_(name) {
			if (!this.warnIfDisposed_(name)) {
				this.initStateKey_(name);
				return this.getStateInfo(name).value;
			}
		}

		/**
* Merges the STATE static variable for the given constructor function.
* @param  {!Function} ctor Constructor function.
* @return {boolean} Returns true if merge happens, false otherwise.
* @static
*/

	}, {
		key: 'hasBeenSet',

		/**
* Checks if the value of the state key with the given name has already been
* set. Note that this doesn't run the key's getter.
* @param {string} name The name of the key.
* @return {boolean}
*/
		value: function hasBeenSet(name) {
			var info = this.getStateInfo(name);
			return info.state === State.KeyStates.INITIALIZED || this.hasInitialValue_(name) // eslint-disable-line
			;
		}

		/**
* Checks if an initial value was given to the specified state property.
* @param {string} name The name of the key.
* @return {boolean}
* @protected
*/

	}, {
		key: 'hasInitialValue_',
		value: function hasInitialValue_(name) {
			return this.initialValues_.hasOwnProperty(name) && (0, _metal.isDef)(this.initialValues_[name]);
		}

		/**
* Checks if the given key is present in this instance's state.
* @param {string} key
* @return {boolean}
*/

	}, {
		key: 'hasStateKey',
		value: function hasStateKey(key) {
			if (!this.warnIfDisposed_(key)) {
				return !!this.stateConfigs_[key];
			}
		}

		/**
* Informs of changes to a state key's value through an event. Won't trigger
* the event if the value hasn't changed or if it's being initialized.
* @param {string} name The name of the key.
* @param {*} prevVal The previous value of the key.
* @protected
*/

	}, {
		key: 'informChange_',
		value: function informChange_(name, prevVal) {
			if (this.shouldInformChange_(name, prevVal)) {
				var data = _metal.object.mixin({
					key: name,
					newVal: this.get(name),
					prevVal: prevVal
				}, this.eventData_);
				this.context_.emit(name + 'Changed', data);
				this.context_.emit('stateKeyChanged', data);
				this.scheduleBatchEvent_(data);
			}
		}

		/**
* Initializes the specified state key, giving it a first value.
* @param {string} name The name of the key.
* @protected
*/

	}, {
		key: 'initStateKey_',
		value: function initStateKey_(name) {
			var info = this.getStateInfo(name);
			if (info.state !== State.KeyStates.UNINITIALIZED) {
				return;
			}

			info.state = State.KeyStates.INITIALIZING;
			this.setInitialValue_(name);
			if (!info.written) {
				this.setDefaultValue(name);
			}
			info.state = State.KeyStates.INITIALIZED;
		}

		/**
* Merges two values for the STATE property into a single object.
* @param {Object} mergedVal
* @param {Object} currVal
* @return {!Object} The merged value.
* @static
*/

	}, {
		key: 'removeStateKey',

		/**
* Removes the requested state key.
* @param {string} name The name of the key.
*/
		value: function removeStateKey(name) {
			this.stateInfo_[name] = null;
			this.stateConfigs_[name] = null;
			delete this.obj_[name];
		}

		/**
* Schedules a state change batch event to be emitted asynchronously.
* @param {!Object} changeData Information about a state key's update.
* @protected
*/

	}, {
		key: 'scheduleBatchEvent_',
		value: function scheduleBatchEvent_(changeData) {
			if (!this.scheduledBatchData_) {
				_metal.async.nextTick(this.emitBatchEvent_, this);
				this.scheduledBatchData_ = _metal.object.mixin({
					changes: {}
				}, this.eventData_);
			}

			var name = changeData.key;
			var changes = this.scheduledBatchData_.changes;
			if (changes[name]) {
				changes[name].newVal = changeData.newVal;
			} else {
				changes[name] = changeData;
			}
		}

		/**
* Sets the value of the requested state key.
* Note: this can and should be accomplished by setting the state key as a
* regular property. This should only be used in cases where a function is
* actually needed.
* @param {string} name
* @param {*} value
*/

	}, {
		key: 'set',
		value: function set(name, value) {
			if (this.hasStateKey(name)) {
				this.obj_[name] = value;
			}
		}

		/**
* Sets the default value of the requested state key.
* @param {string} name The name of the key.
*/

	}, {
		key: 'setDefaultValue',
		value: function setDefaultValue(name) {
			var config = this.stateConfigs_[name];

			if (config.value !== undefined) {
				this.set(name, config.value);
			} else {
				this.set(name, this.callFunction_(config.valueFn));
			}
		}

		/**
* Sets data to be sent with all events emitted from this instance.
* @param {Object} data
*/

	}, {
		key: 'setEventData',
		value: function setEventData(data) {
			this.eventData_ = data;
		}

		/**
* Sets the initial value of the requested state key.
* @param {string} name The name of the key.
* @protected
*/

	}, {
		key: 'setInitialValue_',
		value: function setInitialValue_(name) {
			if (this.hasInitialValue_(name)) {
				this.set(name, this.initialValues_[name]);
				this.initialValues_[name] = undefined;
			}
		}

		/**
* Sets a map of keys that are not valid state keys.
* @param {!Object<string, boolean>} blacklist
*/

	}, {
		key: 'setKeysBlacklist',
		value: function setKeysBlacklist(blacklist) {
			this.keysBlacklist_ = blacklist;
		}

		/**
* Sets the value of all the specified state keys.
* @param {!Object.<string,*>} values A map of state keys to the values they
*   should be set to.
* @param {function()=} callback An optional function that will be run
*   after the next batched update is triggered.
*/

	}, {
		key: 'setState',
		value: function setState(values, callback) {
			var _this2 = this;

			Object.keys(values).forEach(function (name) {
				return _this2.set(name, values[name]);
			});
			if (callback && this.scheduledBatchData_) {
				this.context_.once('stateChanged', callback);
			}
		}

		/**
* Sets the value of the specified state key. This is passed as that key's
* setter to the `Object.defineProperty` call inside the `addKeyToState`
* method.
* @param {string} name The name of the key.
* @param {*} value The new value of the key.
* @protected
*/

	}, {
		key: 'setStateKeyValue_',
		value: function setStateKeyValue_(name, value) {
			if (this.warnIfDisposed_(name) || !this.canSetState(name) || !this.validateKeyValue_(name, value)) {
				return;
			}

			var prevVal = this.get(name);
			var info = this.getStateInfo(name);
			info.value = this.callSetter_(name, value, prevVal);
			this.assertGivenIfRequired_(name);
			info.written = true;
			this.informChange_(name, prevVal);
		}

		/**
* Checks if we should inform about a state update. Updates are ignored during
* state initialization. Otherwise, updates to primitive values are only
* informed when the new value is different from the previous one. Updates to
* objects (which includes functions and arrays) are always informed outside
* initialization though, since we can't be sure if all of the internal data
* has stayed the same.
* @param {string} name The name of the key.
* @param {*} prevVal The previous value of the key.
* @return {boolean}
* @protected
*/

	}, {
		key: 'shouldInformChange_',
		value: function shouldInformChange_(name, prevVal) {
			var info = this.getStateInfo(name);
			return info.state === State.KeyStates.INITIALIZED && ((0, _metal.isObject)(prevVal) || prevVal !== this.get(name));
		}

		/**
* Returns a boolean that determines whether or not should throw error when
* vaildator functions returns an `Error` instance.
* @return {boolean} By default returns false.
*/

	}, {
		key: 'shouldThrowValidationError',
		value: function shouldThrowValidationError() {
			return false;
		}

		/**
* Validates the initial value for the state property with the given name.
* @param {string} name
* @protected
*/

	}, {
		key: 'validateInitialValue_',
		value: function validateInitialValue_(name) {
			if (this.initialValues_.hasOwnProperty(name) && !this.callValidator_(name, this.initialValues_[name])) {
				delete this.initialValues_[name];
			}
		}

		/**
* Validates the state key's value, which includes calling the validator
* defined in the key's configuration object, if there is one.
* @param {string} name The name of the key.
* @param {*} value The value to be validated.
* @return {boolean} Flag indicating if value is valid or not.
* @protected
*/

	}, {
		key: 'validateKeyValue_',
		value: function validateKeyValue_(name, value) {
			var info = this.getStateInfo(name);
			return info.state === State.KeyStates.INITIALIZING || this.callValidator_(name, value);
		}

		/**
* Warns if this instance has already been disposed.
* @param {string} name Name of the property to be accessed if not disposed.
* @return {boolean} True if disposed, or false otherwise.
* @protected
*/

	}, {
		key: 'warnIfDisposed_',
		value: function warnIfDisposed_(name) {
			var disposed = this.isDisposed();
			if (disposed) {
				console.warn('Error. Trying to access property "' + name + '" on disposed instance');
			}
			return disposed;
		}
	}], [{
		key: 'getStateStatic',
		value: function getStateStatic(ctor) {
			return (0, _metal.getStaticProperty)(ctor, 'STATE', State.mergeState);
		}
	}, {
		key: 'mergeState',
		value: function mergeState(mergedVal, currVal) {
			return _metal.object.mixin({}, currVal, mergedVal);
		}
	}]);

	return State;
}(_metalEvents.EventEmitter);

/**
 * Constant used as key on State instance for storing property definition.
 * @type {!string}
 */

State.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';

/**
 * Constant used as key on class constructors that extend from State, stores
 * which constructors have had their static STATE configured so that
 * configuration of STATE is not repeated.
 * @type {!string}
 */
State.STATE_STATIC_HINT_CONFIGURED = '__METAL_STATE_STATIC_HINT_CONFIGURED__';

/**
 * Constants that represent the states that a state key can be in.
 * @type {!Object}
 */
State.KeyStates = {
	UNINITIALIZED: undefined,
	INITIALIZING: 1,
	INITIALIZED: 2
};

exports.default = State;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

var _EventHandle = __webpack_require__(20);

var _EventHandle2 = _interopRequireDefault(_EventHandle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var singleArray_ = [0];

/**
 * EventEmitter utility.
 * @extends {Disposable}
 */

var EventEmitter = function(_Disposable) {
	_inherits(EventEmitter, _Disposable);

	/**
* EventEmitter constructor
*/
	function EventEmitter() {
		_classCallCheck(this, EventEmitter);

		/**
* Holds event listeners scoped by event type.
* @type {Object<string, !Array<!function()>>}
* @protected
*/
		var _this = _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).call(this));

		_this.events_ = null;

		/**
* Handlers that are triggered when an event is listened to.
* @type {Array}
*/
		_this.listenerHandlers_ = null;

		/**
* Configuration option which determines if an event facade should be sent
* as a param of listeners when emitting events. If set to true, the facade
* will be passed as the first argument of the listener.
* @type {boolean}
* @protected
*/
		_this.shouldUseFacade_ = false;
		return _this;
	}

	/**
* Adds a handler to given holder variable. If the holder doesn't have a
* value yet, it will receive the handler directly. If the holder is an array,
* the value will just be added to it. Otherwise, the holder will be set to a
* new array containing its previous value plus the new handler.
* @param {*} holder
* @param {!function()|Object} handler
* @return {*} The holder's new value.
* @protected
*/

	_createClass(EventEmitter, [{
		key: 'addHandler_',
		value: function addHandler_(holder, handler) {
			if (!holder) {
				holder = handler;
			} else {
				if (!Array.isArray(holder)) {
					holder = [holder];
				}
				holder.push(handler);
			}
			return holder;
		}

		/**
* Adds a listener to the end of the listeners array for the specified events.
* @param {!(Array|string)} event
* @param {!Function} listener
* @param {boolean} defaultListener Flag indicating if this listener is a default
*   action for this event. Default actions are run last, and only if no previous
*   listener call `preventDefault()` on the received event facade.
* @return {!EventHandle} Can be used to remove the listener.
*/

	}, {
		key: 'addListener',
		value: function addListener(event, listener, defaultListener) {
			this.validateListener_(listener);

			var events = this.toEventsArray_(event);
			for (var i = 0; i < events.length; i++) {
				this.addSingleListener_(events[i], listener, defaultListener);
			}

			return new _EventHandle2.default(this, event, listener);
		}

		/**
* Adds a listener to the end of the listeners array for a single event.
* @param {string} event
* @param {!Function} listener
* @param {boolean} defaultListener Flag indicating if this listener is a default
*   action for this event. Default actions are run last, and only if no previous
*   listener call `preventDefault()` on the received event facade.
* @param {Function=} origin The original function that was added as a
*   listener, if there is any.
* @protected
*/

	}, {
		key: 'addSingleListener_',
		value: function addSingleListener_(event, listener, defaultListener, origin) {
			this.runListenerHandlers_(event);
			if (defaultListener || origin) {
				listener = {
					default: defaultListener,
					fn: listener,
					origin: origin
				};
			}
			this.events_ = this.events_ || {};
			this.events_[event] = this.addHandler_(this.events_[event], listener);
		}

		/**
* Builds facade for the given event.
* @param {string} event
* @return {Object}
* @protected
*/

	}, {
		key: 'buildFacade_',
		value: function buildFacade_(event) {
			if (this.getShouldUseFacade()) {
				var facade = {
					preventDefault: function preventDefault() {
						facade.preventedDefault = true;
					},
					target: this,
					type: event
				};
				return facade;
			}
		}

		/**
* Disposes of this instance's object references.
* @override
*/

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.events_ = null;
		}

		/**
* Execute each of the listeners in order with the supplied arguments.
* @param {string} event
* @param {*} opt_args [arg1], [arg2], [...]
* @return {boolean} Returns true if event had listeners, false otherwise.
*/

	}, {
		key: 'emit',
		value: function emit(event) {
			var listeners = this.getRawListeners_(event);
			if (listeners.length === 0) {
				return false;
			}

			var args = _metal.array.slice(arguments, 1); // eslint-disable-line
			this.runListeners_(listeners, args, this.buildFacade_(event));
			return true;
		}

		/**
* Gets the listener objects for the given event, if there are any.
* @param {string} event
* @return {!Array}
* @protected
*/

	}, {
		key: 'getRawListeners_',
		value: function getRawListeners_(event) {
			var directListeners = toArray(this.events_ && this.events_[event]);
			return directListeners.concat(toArray(this.events_ && this.events_['*']));
		}

		/**
* Gets the configuration option which determines if an event facade should
* be sent as a param of listeners when emitting events. If set to true, the
* facade will be passed as the first argument of the listener.
* @return {boolean}
*/

	}, {
		key: 'getShouldUseFacade',
		value: function getShouldUseFacade() {
			return this.shouldUseFacade_;
		}

		/**
* Returns an array of listeners for the specified event.
* @param {string} event
* @return {Array} Array of listeners.
*/

	}, {
		key: 'listeners',
		value: function listeners(event) {
			return this.getRawListeners_(event).map(function (listener) {
				return listener.fn ? listener.fn : listener;
			});
		}

		/**
* Adds a listener that will be invoked a fixed number of times for the
* events. After each event is triggered the specified amount of times, the
* listener is removed for it.
* @param {!(Array|string)} event
* @param {number} amount The amount of times this event should be listened
* to.
* @param {!Function} listener
* @return {!EventHandle} Can be used to remove the listener.
*/

	}, {
		key: 'many',
		value: function many(event, amount, listener) {
			var events = this.toEventsArray_(event);
			for (var i = 0; i < events.length; i++) {
				this.many_(events[i], amount, listener);
			}

			return new _EventHandle2.default(this, event, listener);
		}

		/**
* Adds a listener that will be invoked a fixed number of times for a single
* event. After the event is triggered the specified amount of times, the
* listener is removed.
* @param {string} event
* @param {number} amount The amount of times this event should be listened
* to.
* @param {!Function} listener
* @protected
*/

	}, {
		key: 'many_',
		value: function many_(event, amount, listener) {
			var self = this;

			if (amount <= 0) {
				return;
			}

			/**
	*
	*/
			function handlerInternal() {
				if (--amount === 0) {
					self.removeListener(event, handlerInternal);
				}
				listener.apply(self, arguments); // eslint-disable-line
			}

			self.addSingleListener_(event, handlerInternal, false, listener);
		}

		/**
* Checks if a listener object matches the given listener function. To match,
* it needs to either point to that listener or have it as its origin.
* @param {!Object} listenerObj
* @param {!Function} listener
* @return {boolean}
* @protected
*/

	}, {
		key: 'matchesListener_',
		value: function matchesListener_(listenerObj, listener) {
			var fn = listenerObj.fn || listenerObj;
			return fn === listener || listenerObj.origin && listenerObj.origin === listener // eslint-disable-line
			;
		}

		/**
* Removes a listener for the specified events.
* Caution: changes array indices in the listener array behind the listener.
* @param {!(Array|string)} event
* @param {!Function} listener
* @return {!Object} Returns emitter, so calls can be chained.
*/

	}, {
		key: 'off',
		value: function off(event, listener) {
			this.validateListener_(listener);
			if (!this.events_) {
				return this;
			}

			var events = this.toEventsArray_(event);
			for (var i = 0; i < events.length; i++) {
				this.events_[events[i]] = this.removeMatchingListenerObjs_(toArray(this.events_[events[i]]), listener);
			}

			return this;
		}

		/**
* Adds a listener to the end of the listeners array for the specified events.
* @param {!(Array|string)} events
* @param {!Function} listener
* @return {!EventHandle} Can be used to remove the listener.
*/

	}, {
		key: 'on',
		value: function on() {
			return this.addListener.apply(this, arguments); // eslint-disable-line
		}

		/**
* Adds handler that gets triggered when an event is listened to on this
* instance.
* @param {!function()} handler
*/

	}, {
		key: 'onListener',
		value: function onListener(handler) {
			this.listenerHandlers_ = this.addHandler_(this.listenerHandlers_, handler); // eslint-disable-line
		}

		/**
* Adds a one time listener for the events. This listener is invoked only the
* next time each event is fired, after which it is removed.
* @param {!(Array|string)} events
* @param {!Function} listener
* @return {!EventHandle} Can be used to remove the listener.
*/

	}, {
		key: 'once',
		value: function once(events, listener) {
			return this.many(events, 1, listener);
		}

		/**
* Removes all listeners, or those of the specified events. It's not a good
* idea to remove listeners that were added elsewhere in the code,
* especially when it's on an emitter that you didn't create.
* @param {(Array|string)=} event
* @return {!Object} Returns emitter, so calls can be chained.
*/

	}, {
		key: 'removeAllListeners',
		value: function removeAllListeners(event) {
			if (this.events_) {
				if (event) {
					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.events_[events[i]] = null;
					}
				} else {
					this.events_ = null;
				}
			}
			return this;
		}

		/**
* Removes all listener objects from the given array that match the given
* listener function.
* @param {Array.<Object>} listenerObjs
* @param {!Function} listener
* @return {Array.<Object>|Object} The new listeners array for this event.
* @protected
*/

	}, {
		key: 'removeMatchingListenerObjs_',
		value: function removeMatchingListenerObjs_(listenerObjs, listener) {
			var finalListeners = [];
			for (var i = 0; i < listenerObjs.length; i++) {
				if (!this.matchesListener_(listenerObjs[i], listener)) {
					finalListeners.push(listenerObjs[i]);
				}
			}
			return finalListeners.length > 0 ? finalListeners : null;
		}

		/**
* Removes a listener for the specified events.
* Caution: changes array indices in the listener array behind the listener.
* @param {!(Array|string)} events
* @param {!Function} listener
* @return {!Object} Returns emitter, so calls can be chained.
*/

	}, {
		key: 'removeListener',
		value: function removeListener() {
			return this.off.apply(this, arguments); // eslint-disable-line
		}

		/**
* Runs the handlers when an event is listened to.
* @param {string} event
* @protected
*/

	}, {
		key: 'runListenerHandlers_',
		value: function runListenerHandlers_(event) {
			var handlers = this.listenerHandlers_;
			if (handlers) {
				handlers = toArray(handlers);
				for (var i = 0; i < handlers.length; i++) {
					handlers[i](event);
				}
			}
		}

		/**
* Runs the given listeners.
* @param {!Array} listeners
* @param {!Array} args
* @param {Object} facade
* @protected
*/

	}, {
		key: 'runListeners_',
		value: function runListeners_(listeners, args, facade) {
			if (facade) {
				args.push(facade);
			}

			var defaultListeners = [];
			for (var i = 0; i < listeners.length; i++) {
				var listener = listeners[i].fn || listeners[i];
				if (listeners[i].default) {
					defaultListeners.push(listener);
				} else {
					listener.apply(this, args);
				}
			}
			if (!facade || !facade.preventedDefault) {
				for (var j = 0; j < defaultListeners.length; j++) {
					defaultListeners[j].apply(this, args);
				}
			}
		}

		/**
* Sets the configuration option which determines if an event facade should
* be sent as a param of listeners when emitting events. If set to true, the
* facade will be passed as the first argument of the listener.
* @param {boolean} shouldUseFacade
* @return {!Object} Returns emitter, so calls can be chained.
*/

	}, {
		key: 'setShouldUseFacade',
		value: function setShouldUseFacade(shouldUseFacade) {
			this.shouldUseFacade_ = shouldUseFacade;
			return this;
		}

		/**
* Converts the parameter to an array if only one event is given. Reuses the
* same array each time this conversion is done, to avoid using more memory
* than necessary.
* @param  {!(Array|string)} events
* @return {!Array}
* @protected
*/

	}, {
		key: 'toEventsArray_',
		value: function toEventsArray_(events) {
			if ((0, _metal.isString)(events)) {
				singleArray_[0] = events;
				events = singleArray_;
			}
			return events;
		}

		/**
* Checks if the given listener is valid, throwing an exception when it's not.
* @param  {*} listener
* @protected
*/

	}, {
		key: 'validateListener_',
		value: function validateListener_(listener) {
			if (!(0, _metal.isFunction)(listener)) {
				throw new TypeError('Listener must be a function');
			}
		}
	}]);

	return EventEmitter;
}(_metal.Disposable);

/**
 * Converts to an array
 * @param {Object} val
 * @return {Array}
 */

function toArray(val) {
	val = val || [];
	return Array.isArray(val) ? val : [val];
}

exports.default = EventEmitter;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventEmitterProxy utility. It's responsible for linking two EventEmitter
 * instances together, emitting events from the first emitter through the
 * second one. That means that listening to a supported event on the target
 * emitter will mean listening to it on the origin emitter as well.
 * @extends {Disposable}
 */
var EventEmitterProxy = function(_Disposable) {
	_inherits(EventEmitterProxy, _Disposable);

	/**
* @param {EventEmitter} originEmitter Events originated on this emitter
* will be fired for the target emitter's listeners as well.
* @param {EventEmitter} targetEmitter Event listeners attached to this emitter
* will also be triggered when the event is fired by the origin emitter.
* @param {Object} blacklist Optional blacklist of events that should not be
* proxied.
* @param {Object} whitelist
*/
	function EventEmitterProxy(originEmitter, targetEmitter, blacklist, whitelist) {
		_classCallCheck(this, EventEmitterProxy);

		/**
* Map of events that should not be proxied.
* @type {Object}
* @protected
*/
		var _this = _possibleConstructorReturn(this, (EventEmitterProxy.__proto__ || Object.getPrototypeOf(EventEmitterProxy)).call(this));

		_this.blacklist_ = blacklist;

		/**
* The origin emitter. This emitter's events will be proxied through the
* target emitter.
* @type {EventEmitter}
* @protected
*/
		_this.originEmitter_ = originEmitter;

		/**
* A list of events that are pending to be listened by an actual origin
* emitter. Events are stored here when the origin doesn't exist, so they
* can be set on a new origin when one is set.
* @type {Array}
* @protected
*/
		_this.pendingEvents_ = null;

		/**
* Holds a map of events from the origin emitter that are already being proxied.
* @type {Object<string, !EventHandle>}
* @protected
*/
		_this.proxiedEvents_ = null;

		/**
* The target emitter. This emitter will emit all events that come from
* the origin emitter.
* @type {EventEmitter}
* @protected
*/
		_this.targetEmitter_ = targetEmitter;

		/**
* Map of events that should be proxied. If whitelist is set blacklist is ignored.
* @type {Object}
* @protected
*/
		_this.whitelist_ = whitelist;

		_this.startProxy_();
		return _this;
	}

	/**
* Adds the given listener for the given event.
* @param {string} event
* @param {!function()} listener
* @return {!EventHandle} The listened event's handle.
* @protected
*/

	_createClass(EventEmitterProxy, [{
		key: 'addListener_',
		value: function addListener_(event, listener) {
			return this.originEmitter_.on(event, listener);
		}

		/**
* @inheritDoc
*/

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.removeListeners_();
			this.proxiedEvents_ = null;
			this.originEmitter_ = null;
			this.targetEmitter_ = null;
		}

		/**
* Emits the specified event type on the target emitter.
* @protected
*/

	}, {
		key: 'emitOnTarget_',
		value: function emitOnTarget_() {
			var _targetEmitter_;

			(_targetEmitter_ = this.targetEmitter_).emit.apply(_targetEmitter_, arguments);
		}

		/**
* Proxies the given event from the origin to the target emitter.
* @param {string} event
*/

	}, {
		key: 'proxyEvent',
		value: function proxyEvent(event) {
			if (this.shouldProxyEvent_(event)) {
				this.tryToAddListener_(event);
			}
		}

		/**
* Removes the proxy listener for all events.
* @protected
*/

	}, {
		key: 'removeListeners_',
		value: function removeListeners_() {
			if (this.proxiedEvents_) {
				var events = Object.keys(this.proxiedEvents_);
				for (var i = 0; i < events.length; i++) {
					this.proxiedEvents_[events[i]].removeListener();
				}
				this.proxiedEvents_ = null;
			}
			this.pendingEvents_ = null;
		}

		/**
* Changes the origin emitter. This automatically detaches any events that
* were already being proxied from the previous emitter, and starts proxying
* them on the new emitter instead.
* @param {!EventEmitter} originEmitter
*/

	}, {
		key: 'setOriginEmitter',
		value: function setOriginEmitter(originEmitter) {
			var _this2 = this;

			var events = this.originEmitter_ && this.proxiedEvents_ ? Object.keys(this.proxiedEvents_) : this.pendingEvents_;
			this.originEmitter_ = originEmitter;
			if (events) {
				this.removeListeners_();
				events.forEach(function (event) {
					return _this2.proxyEvent(event);
				});
			}
		}

		/**
* Checks if the given event should be proxied.
* @param {string} event
* @return {boolean}
* @protected
*/

	}, {
		key: 'shouldProxyEvent_',
		value: function shouldProxyEvent_(event) {
			if (this.whitelist_ && !this.whitelist_[event]) {
				return false;
			}
			if (this.blacklist_ && this.blacklist_[event]) {
				return false;
			}
			return !this.proxiedEvents_ || !this.proxiedEvents_[event];
		}

		/**
* Starts proxying all events from the origin to the target emitter.
* @protected
*/

	}, {
		key: 'startProxy_',
		value: function startProxy_() {
			this.targetEmitter_.onListener(this.proxyEvent.bind(this));
		}

		/**
* Adds a listener to the origin emitter, if it exists. Otherwise, stores
* the pending listener so it can be used on a future origin emitter.
* @param {string} event
* @protected
*/

	}, {
		key: 'tryToAddListener_',
		value: function tryToAddListener_(event) {
			if (this.originEmitter_) {
				this.proxiedEvents_ = this.proxiedEvents_ || {};
				this.proxiedEvents_[event] = this.addListener_(event, this.emitOnTarget_.bind(this, event));
			} else {
				this.pendingEvents_ = this.pendingEvents_ || [];
				this.pendingEvents_.push(event);
			}
		}
	}]);

	return EventEmitterProxy;
}(_metal.Disposable);

exports.default = EventEmitterProxy;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventHandler utility. It's useful for easily removing a group of
 * listeners from different EventEmitter instances.
 * @extends {Disposable}
 */
var EventHandler = function(_Disposable) {
	_inherits(EventHandler, _Disposable);

	/**
* EventHandler constructor
*/
	function EventHandler() {
		_classCallCheck(this, EventHandler);

		/**
* An array that holds the added event handles, so the listeners can be
* removed later.
* @type {Array.<EventHandle>}
* @protected
*/
		var _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this));

		_this.eventHandles_ = [];
		return _this;
	}

	/**
* Adds event handles to be removed later through the `removeAllListeners`
* method.
* @param {...(!EventHandle)} var_args
*/

	_createClass(EventHandler, [{
		key: 'add',
		value: function add() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			for (var i = 0; i < arguments.length; i++) {
				this.eventHandles_.push(args[i]);
			}
		}

		/**
* Disposes of this instance's object references.
* @override
*/

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.eventHandles_ = null;
		}

		/**
* Removes all listeners that have been added through the `add` method.
*/

	}, {
		key: 'removeAllListeners',
		value: function removeAllListeners() {
			for (var i = 0; i < this.eventHandles_.length; i++) {
				this.eventHandles_[i].removeListener();
			}

			this.eventHandles_ = [];
		}
	}]);

	return EventHandler;
}(_metal.Disposable);

exports.default = EventHandler;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(22);

var _metal = __webpack_require__(1);

var _sync = __webpack_require__(48);

var _metalDom = __webpack_require__(11);

var _ComponentDataManager = __webpack_require__(25);

var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);

var _ComponentRenderer = __webpack_require__(26);

var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

var _metalEvents = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Component collects common behaviors to be followed by UI components, such
 * as Lifecycle, CSS classes management, events encapsulation and support for
 * different types of rendering.
 * Rendering logic can be done by either:
 *     - Listening to the `render` event inside the `created` lifecycle function
 *       and adding the rendering logic to the listener.
 *     - Using an existing implementation of `ComponentRenderer` like `Soy`,
 *       and following its patterns.
 *     - Building your own implementation of a `ComponentRenderer`.
 * Specifying the renderer that will be used can be done by setting the RENDERER
 * static variable to the renderer's constructor function.
 *
 * Example:
 *
 * <code>
 * class CustomComponent extends Component {
 *   created() {
 *   }
 *
 *   rendered() {
 *   }
 *
 *   willAttach() {
 *   }
 *
 *   attached() {
 *   }
 *
 *   willReceiveState() {
 *   }
 *
 *   // willReceiveProps is only available in JSX components
 *   willReceiveProps() {
 *   }
 *
 *   shouldUpdate() {
 *   }
 *
 *   willUpdate() {
 *   }
 *
 *   willDetach() {
 *   }
 *
 *   detached() {
 *   }
 *
 *   disposed() {
 *   }
 * }
 *
 * CustomComponent.RENDERER = MyRenderer;
 *
 * CustomComponent.STATE = {
 *   title: { value: 'Title' },
 *   fontSize: { value: '10px' }
 * };
 * </code>
 *
 * @extends {State}
 */
var Component = function(_EventEmitter) {
	_inherits(Component, _EventEmitter);

	/**
* Constructor function for `Component`.
* @param {Object=} config An object with the initial values for this
*     component's state.
* @param {boolean|string|Element=} parentElement The element where the
*     component should be rendered. Can be given as a selector or an element.
*     If `false` is passed, the component won't be rendered automatically
*     after created.
* @constructor
*/
	function Component(config, parentElement) {
		_classCallCheck(this, Component);

		/**
* Instance of `DomEventEmitterProxy` which proxies events from the component's
* element to the component itself.
* @type {!DomEventEmitterProxy}
* @protected
*/
		var _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));

		_this.elementEventProxy_ = new _metalDom.DomEventEmitterProxy(null, _this, proxyBlackList_);

		/**
* The `EventHandler` instance for events attached from the `events` state key.
* @type {EventHandler}
* @protected
*/
		_this.eventsStateKeyHandler_ = null;

		/**
* Stores the pending callback function for when `forceUpdate` is used
* to trigger a rerender.
* @type {?function}
*/
		_this.forceUpdateCallback_ = null;

		/**
* Whether the element is in document.
* @type {boolean}
*/
		_this.inDocument = false;

		/**
* The initial config option passed to this constructor.
* @type {!Object}
* @protected
*/
		_this.initialConfig_ = config || {};

		/**
* Indicates whether the component should be rendered as a Portal, outside
* of the parent component.
* @type {string|Element|boolean}
*/
		_this.portalElement = null;

		/**
* Whether the element was rendered.
* @type {boolean}
*/
		_this.wasRendered = false;

		/**
* The component's element will be appended to the element this variable is
* set to, unless the user specifies another parent when calling `render` or
* `attach`.
* @type {!Element}
*/
		_this.DEFAULT_ELEMENT_PARENT = typeof document !== 'undefined' ? document.body : null;

		_this.setShouldUseFacade(true);
		_this.element = _this.initialConfig_.element;

		_this.setUpRenderer_();
		_this.setUpDataManager_();
		_this.setUpSyncUpdates_();

		_this.setUpPortal_(_this.initialConfig_.portalElement);

		_this.on('stateWillChange', _this.handleStateWillChange_);
		_this.on('stateChanged', _this.handleComponentStateChanged_);
		_this.on('eventsChanged', _this.onEventsChanged_);
		_this.addListenersFromObj_(_this.dataManager_.get(_this, 'events'));

		_this.created();
		_this.componentCreated_ = true;
		if (parentElement !== false) {
			_this.renderComponent(parentElement);
		}
		return _this;
	}

	/**
* Getter logic for the element property.
* @return {Element}
*/

	_createClass(Component, [{
		key: 'addListenersFromObj_',

		/**
* Adds the listeners specified in the given object.
* @param {!Object} obj
* @protected
*/
		value: function addListenersFromObj_(obj) {
			var _eventsStateKeyHandle;

			if (!this.eventsStateKeyHandler_) {
				this.eventsStateKeyHandler_ = new _metalEvents.EventHandler();
			}
			var handles = (0, _events.addListenersFromObj)(this, obj);
			(_eventsStateKeyHandle = this.eventsStateKeyHandler_).add.apply(_eventsStateKeyHandle, _toConsumableArray(handles));
		}

		/**
* Invokes the attached Lifecycle. When attached, the component element is
* appended to the DOM and any other action to be performed must be
* implemented in this method, such as, binding DOM events. A component can
* be re-attached multiple times.
* @param {(string|Element)=} parentElement Optional parent element
*     to render the component.
* @param {(string|Element)=} siblingElement Optional sibling element
*     to render the component before it. Relevant when the component needs
*     to be rendered before an existing element in the DOM.
* @protected
* @chainable
* @return {Component}
*/

	}, {
		key: 'attach',
		value: function attach(parentElement, siblingElement) {
			if (!this.inDocument) {
				this.emit('willAttach');
				this.willAttach();
				this.attachElement(parentElement, siblingElement);
				this.inDocument = true;
				this.attachData_ = {
					parent: parentElement,
					sibling: siblingElement
				};
				this.emit('attached', this.attachData_);
				this.attached();
			}
			return this;
		}

		/**
* Lifecycle. When attached, the component element is appended to the DOM
* and any other action to be performed must be implemented in this method,
* such as, binding DOM events. A component can be re-attached multiple
* times, therefore the undo behavior for any action performed in this phase
* must be implemented on the detach phase.
*/

	}, {
		key: 'attached',
		value: function attached() {}

		/**
* Attaches the component element into the DOM.
* @param {(string|Element)=} parentElement Optional parent element
*     to render the component.
* @param {(string|Element)=} siblingElement Optional sibling element
*     to render the component before it. Relevant when the component needs
*     to be rendered before an existing element in the DOM, e.g.
*     `component.attach(null, existingElement)`.
*/

	}, {
		key: 'attachElement',
		value: function attachElement(parentElement, siblingElement) {
			var element = this.element;
			if (element && (siblingElement || !element.parentNode)) {
				var parent = (0, _metalDom.toElement)(parentElement) || this.DEFAULT_ELEMENT_PARENT; // eslint-disable-line
				parent.insertBefore(element, (0, _metalDom.toElement)(siblingElement));
			}
		}

		/**
* Lifecycle. This is called when the component has just been created, before
* it's rendered.
*/

	}, {
		key: 'created',
		value: function created() {}

		/**
* Listens to a delegate event on the component's element.
* @param {string} eventName The name of the event to listen to.
* @param {string} selector The selector that matches the child elements that
*   the event should be triggered for.
* @param {!function(!Object)} callback Function to be called when the event is
*   triggered. It will receive the normalized event object.
* @return {!EventHandle} Can be used to remove the listener.
*/

	}, {
		key: 'delegate',
		value: function delegate(eventName, selector, callback) {
			return this.on('delegate:' + eventName + ':' + selector, callback);
		}

		/**
* Invokes the detached Lifecycle. When detached, the component element is
* removed from the DOM and any other action to be performed must be
* implemented in this method, such as, unbinding DOM events. A component
* can be detached multiple times.
* @chainable
* @return {Component}
*/

	}, {
		key: 'detach',
		value: function detach() {
			if (this.inDocument) {
				this.emit('willDetach');
				this.willDetach();
				if (this.element && this.element.parentNode) {
					this.element.parentNode.removeChild(this.element);
				}
				this.inDocument = false;
				this.detached();
			}
			this.emit('detached');
			return this;
		}

		/**
* Lifecycle. When detached, the component element is removed from the DOM
* and any other action to be performed must be implemented in this method,
* such as, unbinding DOM events. A component can be detached multiple
* times, therefore the undo behavior for any action performed in this phase
* must be implemented on the attach phase.
*/

	}, {
		key: 'detached',
		value: function detached() {}

		/**
* Lifecycle. Called when the component is disposed. Should be overridden by
* sub classes to dispose of any internal data or events.
*/

	}, {
		key: 'disposed',
		value: function disposed() {}

		/**
* @inheritDoc
*/

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.detach();
			this.disposed();
			this.emit('disposed');

			this.elementEventProxy_.dispose();
			this.elementEventProxy_ = null;

			this.dataManager_.dispose(this);
			this.dataManager_ = null;

			this.renderer_.dispose(this);
			this.renderer_ = null;

			_get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'disposeInternal', this).call(this);
		}

		/**
* Forces an update that ignores the `shouldUpdate` lifecycle method for
* components whose render depends on external variables.
* @param {function()} callback
*/

	}, {
		key: 'forceUpdate',
		value: function forceUpdate(callback) {
			this.forceUpdateCallback_ = callback;

			this.updateRenderer_({
				forceUpdate: true
			});
		}

		/**
* Gets data about where this component was attached at.
* @return {!Object}
*/

	}, {
		key: 'getAttachData',
		value: function getAttachData() {
			return this.attachData_;
		}

		/**
* Gets the `ComponentDataManager` being used.
* @return {!ComponentDataManager}
*/

	}, {
		key: 'getDataManager',
		value: function getDataManager() {
			return this.dataManager_;
		}

		/**
* Gets the configuration object that was passed to this component's constructor.
* @return {!Object}
*/

	}, {
		key: 'getInitialConfig',
		value: function getInitialConfig() {
			return this.initialConfig_;
		}

		/**
* Gets portalElement based on selector. If an id is passed and the element
* does not exist, the element is created with that id and appended to the body.
*
* @param {string|Element} portalElementSelector
* @return {?Element}
*/

	}, {
		key: 'getPortalElement_',
		value: function getPortalElement_(portalElementSelector) {
			var portalElement = (0, _metalDom.toElement)(portalElementSelector);

			if (portalElement) {
				return portalElement;
			}

			if (portalElementSelector.indexOf('#') === 0 && portalElementSelector.indexOf(' ') === -1) {
				portalElement = document.createElement('div');
				portalElement.setAttribute('id', portalElementSelector.slice(1));

				(0, _metalDom.enterDocument)(portalElement);
			}

			return portalElement;
		}

		/**
* Gets state data for this component.
* @return {!Object}
*/

	}, {
		key: 'getState',
		value: function getState() {
			return this.dataManager_.getState(this);
		}

		/**
* Gets the keys for the state data.
* @return {!Array<string>}
*/

	}, {
		key: 'getStateKeys',
		value: function getStateKeys() {
			return this.dataManager_.getStateKeys(this);
		}

		/**
* Gets the `ComponentRenderer` instance being used.
* @return {!ComponentRenderer}
*/

	}, {
		key: 'getRenderer',
		value: function getRenderer() {
			return this.renderer_;
		}

		/**
* Handles a change in the component's element.
* @param {Element} prevVal
* @param {Element} newVal
* @protected
*/

	}, {
		key: 'handleComponentElementChanged_',
		value: function handleComponentElementChanged_(prevVal, newVal) {
			this.elementEventProxy_.setOriginEmitter(newVal);
			if (this.componentCreated_) {
				this.emit('elementChanged', {
					prevVal: prevVal,
					newVal: newVal
				});
				if (newVal && this.wasRendered) {
					this.syncVisible(this.dataManager_.get(this, 'visible'));
				}
			}
		}

		/**
* Handles state batch changes. Calls any existing `sync` functions that
* match the changed state keys.
* @param {Event} event
* @protected
*/

	}, {
		key: 'handleComponentStateChanged_',
		value: function handleComponentStateChanged_(event) {
			if (!this.hasSyncUpdates()) {
				this.updateRenderer_(event);
			}
			(0, _sync.syncState)(this, event.changes);
			this.emit('stateSynced', event);
		}

		/**
* Handles a `stateKeyChanged` event. This is only called for components that
* have requested updates to happen synchronously.
* @param {!{key: string, newVal: *, prevVal: *}} data
* @protected
*/

	}, {
		key: 'handleComponentStateKeyChanged_',
		value: function handleComponentStateKeyChanged_(data) {
			this.updateRenderer_({
				changes: _defineProperty({}, data.key, data)
			});
		}

		/**
* Fires before state batch changes. Provides hook point for modifying
*     state.
* @param {Event} event
* @protected
*/

	}, {
		key: 'handleStateWillChange_',
		value: function handleStateWillChange_(event) {
			this.willReceiveState(event.changes);
		}

		/**
* Checks if this component has sync updates enabled.
* @return {boolean}
*/

	}, {
		key: 'hasSyncUpdates',
		value: function hasSyncUpdates() {
			return this.syncUpdates_;
		}

		/**
* Informs that the component that the rendered has finished rendering it. The
* renderer is the one responsible for calling this when appropriate. This
* will emit events and run the appropriate lifecycle for the first render.
*/

	}, {
		key: 'informRendered',
		value: function informRendered() {
			var firstRender = !this.hasRendererRendered_;
			this.hasRendererRendered_ = true;

			if (this.forceUpdateCallback_) {
				this.forceUpdateCallback_();
				this.forceUpdateCallback_ = null;
			}

			this.rendered(firstRender);
			this.emit('rendered', firstRender);
		}

		/**
* Informs the component that the renderer is about to update. Calls the
* component's `willUpdate` lifecycle method.
* @param {Object} changes
*/

	}, {
		key: 'informWillUpdate',
		value: function informWillUpdate() {
			this.willUpdate.apply(this, arguments);
		}

		/**
* Checks if the given function is a component constructor.
* @param {!function()} fn Any function
* @return {boolean}
*/

	}, {
		key: 'mergeElementClasses_',

		/**
* Merges two values for the ELEMENT_CLASSES property into a single one.
* @param {string} class1
* @param {string} class2
* @return {string} The merged value.
* @protected
*/
		value: function mergeElementClasses_(class1, class2) {
			return class1 ? class1 + ' ' + (class2 || '') : class2;
		}

		/**
* Fired when the `events` state value is changed.
* @param {!Object} event
* @protected
*/

	}, {
		key: 'onEventsChanged_',
		value: function onEventsChanged_(event) {
			this.eventsStateKeyHandler_.removeAllListeners();
			this.addListenersFromObj_(event.newVal);
		}

		/**
* Creates and renders a component for the given constructor function. This
* will always make sure that the constructor runs without rendering the
* component, having the `render` step happen only after it has finished.
* @param {!function()} Ctor The component's constructor function.
* @param {Object|Element=} configOrElement Optional config data or parent
*     for the component.
* @param {Element=} element Optional parent for the component.
* @return {!Component} The rendered component's instance.
*/

	}, {
		key: 'renderComponent',

		/**
* Renders the component into the DOM via its `ComponentRenderer`. Stores the
* given parent element to be used when the renderer is done (`informRendered`).
* @param {(string|Element|boolean)=} parentElement Optional parent element
*     to render the component. If set to `false`, the element won't be
*     attached to any element after rendering. In this case, `attach` should
*     be called manually later to actually attach it to the dom.
*/
		value: function renderComponent(parentElement) {
			if (!this.hasRendererRendered_) {
				if (!(0, _metal.isServerSide)() && window.__METAL_DEV_TOOLS_HOOK__) {
					window.__METAL_DEV_TOOLS_HOOK__(this);
				}
				this.getRenderer().render(this);
			}
			this.emit('render');
			(0, _sync.syncState)(this);
			this.attach(parentElement);
			this.wasRendered = true;
		}

		/**
* Setter logic for the element property.
* @param {?string|Element} val
*/

	}, {
		key: 'setState',

		/**
* Sets the value of all the specified state keys.
* @param {!Object.<string,*>} state A map of state keys to the values they
*   should be set to.
* @param {function()=} callback An optional function that will be run
*   after the next batched update is triggered.
*/
		value: function setState(state, callback) {
			this.dataManager_.setState(this, state, callback);
		}

		/**
* Setter for the `elementClasses` data property. Appends given value with
* the one specified in `ELEMENT_CLASSES`.
* @param {string} val
* @return {string}
* @protected
*/

	}, {
		key: 'setterElementClassesFn_',
		value: function setterElementClassesFn_(val) {
			var elementClasses = (0, _metal.getStaticProperty)(this.constructor, 'ELEMENT_CLASSES', this.mergeElementClasses_);
			if (elementClasses) {
				val += ' ' + elementClasses;
			}
			return val.trim();
		}

		/**
* Sets up the component's data manager.
* @protected
*/

	}, {
		key: 'setUpDataManager_',
		value: function setUpDataManager_() {
			this.dataManager_ = (0, _metal.getStaticProperty)(this.constructor, 'DATA_MANAGER');
			this.dataManager_.setUp(this, _metal.object.mixin({}, this.renderer_.getExtraDataConfig(this), Component.DATA) // eslint-disable-line
			);
		}

		/**
* Overwrites element property if portalElement is passed. Creates
* a nested placeholder so that portalElement is not removed from the
* DOM when component first renders. When portalElement is equal to true,
* component is appeneded to the body.
*
* @param {string|Element|boolean} portalElement
*/

	}, {
		key: 'setUpPortal_',
		value: function setUpPortal_(portalElement) {
			if (!portalElement || !(0, _metal.isElement)(portalElement) && !(0, _metal.isString)(portalElement) && !(0, _metal.isBoolean)(portalElement)) {
				return;
			} else if ((0, _metal.isBoolean)(portalElement) && portalElement) {
				portalElement = 'body';
			}

			if ((0, _metal.isServerSide)()) {
				this.portalElement = true;
				return;
			}

			portalElement = this.getPortalElement_(portalElement);

			if (portalElement) {
				var placeholder = document.createElement('div');

				portalElement.appendChild(placeholder);

				this.element = placeholder;
				this.portalElement = portalElement;
			}
		}

		/**
* Sets up the component's renderer.
* @protected
*/

	}, {
		key: 'setUpRenderer_',
		value: function setUpRenderer_() {
			this.renderer_ = (0, _metal.getStaticProperty)(this.constructor, 'RENDERER');
			this.renderer_.setUp(this);
		}

		/**
* Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.
* @protected
*/

	}, {
		key: 'setUpSyncUpdates_',
		value: function setUpSyncUpdates_() {
			this.syncUpdates_ = (0, _metal.getStaticProperty)(this.constructor, 'SYNC_UPDATES');
			if (this.hasSyncUpdates()) {
				this.on('stateKeyChanged', this.handleComponentStateKeyChanged_.bind(this));
			}
		}

		/**
* Skips renderer updates until `stopSkipUpdates` is called.
*/

	}, {
		key: 'startSkipUpdates',
		value: function startSkipUpdates() {
			this.skipUpdates_ = true;
		}

		/**
* Stops skipping renderer updates.
*/

	}, {
		key: 'stopSkipUpdates',
		value: function stopSkipUpdates() {
			this.skipUpdates_ = false;
		}

		/**
* State synchronization logic for `visible` state key.
* Updates the element's display value according to its visibility.
* @param {boolean} newVal
*/

	}, {
		key: 'syncVisible',
		value: function syncVisible(newVal) {
			if (this.element) {
				this.element.style.display = newVal ? '' : 'none';
			}
		}

		/**
* Lifecycle. Called whenever the component has just been rendered.
* @param {boolean} firstRender Flag indicating if this was the component's
*     first render.
*/

	}, {
		key: 'rendered',
		value: function rendered() {}

		/**
* Calls "update" on the renderer, passing it the changed data.
* @param {!{changes: !Object}} data
* @protected
*/

	}, {
		key: 'updateRenderer_',
		value: function updateRenderer_(data) {
			if (!data.forceUpdate) {
				this.forceUpdateCallback_ = null;
			}

			if (!this.skipUpdates_ && this.hasRendererRendered_) {
				this.getRenderer().update(this, data);
			}
		}

		/**
* Validator logic for the `events` state key.
* @param {Object} val
* @return {boolean}
* @protected
*/

	}, {
		key: 'validatorEventsFn_',
		value: function validatorEventsFn_(val) {
			return !(0, _metal.isDefAndNotNull)(val) || (0, _metal.isObject)(val);
		}

		/**
* Lifecycle. Fires before the component has been attached to the DOM.
*/

	}, {
		key: 'willAttach',
		value: function willAttach() {}

		/**
* Lifecycle. Fires before component is detached from the DOM.
*/

	}, {
		key: 'willDetach',
		value: function willDetach() {}

		/**
* Lifecycle. Called when the component is about to receive state changes.
* Provides a hook point for modifying state that can be used in the next
* rerender.
* @param {Object} changes Changes made to this.state
*/

	}, {
		key: 'willReceiveState',
		value: function willReceiveState() {}

		/**
* Lifecycle. Called when the component's renderer is about to update.
* @param {Object} changes
*/

	}, {
		key: 'willUpdate',
		value: function willUpdate() {}
	}, {
		key: 'element',
		get: function get() {
			return this.elementValue_;
		},
		set: function set(val) {
			if (!(0, _metal.isElement)(val) && !(0, _metal.isString)(val) && (0, _metal.isDefAndNotNull)(val)) {
				return;
			}

			if (val) {
				val = (0, _metalDom.toElement)(val) || this.elementValue_;
			}

			if (this.elementValue_ !== val) {
				var prev = this.elementValue_;
				this.elementValue_ = val;
				this.handleComponentElementChanged_(prev, val);
			}
		}
	}], [{
		key: 'isComponentCtor',
		value: function isComponentCtor(fn) {
			return fn.prototype && fn.prototype[Component.COMPONENT_FLAG];
		}
	}, {
		key: 'render',
		value: function render(Ctor, configOrElement, element) {
			var config = configOrElement;
			if ((0, _metal.isElement)(configOrElement)) {
				config = null;
				element = configOrElement;
			}
			var instance = new Ctor(config, false);
			instance.renderComponent(element);
			return instance;
		}

		/**
* Creates and renders a component for the given constructor function as
* string. This will always make sure that the constructor runs without
* rendering the component, having the `render` step happen only after it
* has finished.
* @param {!function()} Ctor The component's constructor function.
* @param {Object|Element=} configOrElement Optional config data or
*     parent for the component.
* @return {!String} The rendered component's content as string.
*/

	}, {
		key: 'renderToString',
		value: function renderToString(Ctor, configOrElement) {
			var rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;
			switch (rendererName) {
				case 'jsx':
				case 'soy':
				case 'incremental-dom':
					{
						if (typeof IncrementalDOM === 'undefined') {
							throw new Error('Error. Trying to render incremental dom ' + 'based component to string requires IncrementalDOM ' + 'implementation to be loaded.');
						}
						// Incremental dom patches for components or nested components are
						// isolated inside the component element. The following code intercepts
						// incremental dom patches and collect results into temporary stack in
						// order to successfully collect the final string of the outermost
						// component after all nested components stack rendered.
						var interceptedComponentStrings = [];
						var patch = IncrementalDOM.patch;
						var patchInterceptor = function patchInterceptor() {
							var currentElement = patch.apply(undefined, arguments);
							interceptedComponentStrings.push(currentElement.innerHTML);
							IncrementalDOM.patch = patch;
						};
						IncrementalDOM.patch = patchInterceptor;
						Component.render(Ctor, configOrElement).dispose();
						return interceptedComponentStrings[0];
					}
				default:
					throw new Error('Error. Trying to render non incremental dom ' + 'based component to string.');
			}
		}
	}]);

	return Component;
}(_metalEvents.EventEmitter);

/**
 * Component data definition.
 * @type {Object}
 * @static
 */

Component.DATA = {
	/**
* Objects describing children elements that were passed to be rendered inside
* this component.
* @type {!Array<!Object>}
*/
	children: {
		validator: Array.isArray,
		value: []
	},

	/**
* CSS classes to be applied to the element.
* @type {string}
*/
	elementClasses: {
		setter: 'setterElementClassesFn_',
		validator: _metal.isString,
		value: ''
	},

	/**
* Listeners that should be attached to this component. Should be provided as
* an object, where the keys are event names and the values are the listener
* functions (or function names).
* @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}
*/
	events: {
		validator: 'validatorEventsFn_',
		value: null
	},

	/**
* Indicates if the component is visible or not.
* @type {boolean}
*/
	visible: {
		validator: _metal.isBoolean,
		value: true
	}
};

/**
 * Name of the flag used to identify component constructors via their prototype.
 * @type {string}
 */
Component.COMPONENT_FLAG = '__metal_component__';

/**
 * The `ComponentDataManager` class that should be used. This class will be
 * responsible for handling the component's data. Each component may have its
 * own implementation.
 * @type {!ComponentDataManager}
 */
Component.DATA_MANAGER = _ComponentDataManager2.default;

/**
 * CSS classes to be applied to the element.
 * @type {string}
 */
Component.ELEMENT_CLASSES = '';

/**
 * The `ComponentRenderer` that should be used. Components need to set this
 * to a subclass of `ComponentRenderer` that has the rendering logic, like
 * `SoyRenderer`.
 * @type {!ComponentRenderer}
 */
Component.RENDERER = _ComponentRenderer2.default;

/**
 * Flag indicating if component updates will happen synchronously. Updates are
 * done asynchronously by default, which allows changes to be batched and
 * applied together.
 * @type {boolean}
 */
Component.SYNC_UPDATES = false;

/**
 * Sets a prototype flag to easily determine if a given constructor is for
 * a component or not.
 */
Component.prototype[Component.COMPONENT_FLAG] = true;

var proxyBlackList_ = {
	eventsChanged: true,
	stateChanged: true,
	stateKeyChanged: true
};

exports.default = Component;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.syncState = syncState;

var _metal = __webpack_require__(1);

var SYNC_FNS_KEY = '__METAL_SYNC_FNS__';

/**
 * Gets the `sync` methods for this component's state. Caches the results in
 * the component's constructor whenever possible, so that this doesn't need to
 * be calculated again. It's not possible to cache the results when at least
 * one sync method is defined in the instance itself instead of in its
 * prototype, as it may be bound to the instance (not reusable by others).
 * @param {!Component} component
 * @return {!Object}
 * @private
 */
function getSyncFns_(component) {
	var ctor = component.constructor;
	if (ctor.hasOwnProperty(SYNC_FNS_KEY)) {
		return ctor[SYNC_FNS_KEY];
	}

	var fns = {};
	var keys = component.getDataManager().getSyncKeys(component);
	var canCache = true;
	for (var i = 0; i < keys.length; i++) {
		var name = 'sync' + keys[i].charAt(0).toUpperCase() + keys[i].slice(1);
		var fn = component[name];
		if (fn) {
			fns[keys[i]] = fn;
			canCache = canCache && component.constructor.prototype[name];
		}
	}

	if (canCache) {
		ctor[SYNC_FNS_KEY] = fns;
	}
	return fns;
}

/**
 * Calls "sync" functions for the given component's state.
 * @param {!Component} component
 * @param {Object=} changes When given, only the properties inside it will
 *     be synced. Otherwise all state properties will be synced.
 */
function syncState(component, changes) {
	var syncFns = getSyncFns_(component);
	var keys = Object.keys(changes || syncFns);
	for (var i = 0; i < keys.length; i++) {
		var fn = syncFns[keys[i]];
		if ((0, _metal.isFunction)(fn)) {
			var change = changes && changes[keys[i]];
			var manager = component.getDataManager();
			fn.call(component, change ? change.newVal : manager.get(component, keys[i]), change ? change.prevVal : undefined);
		}
	}
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.customEvents = undefined;
exports.addClasses = addClasses;
exports.closest = closest;
exports.append = append;
exports.buildFragment = buildFragment;
exports.contains = contains;
exports.delegate = delegate;
exports.isNodeListLike = isNodeListLike;
exports.enterDocument = enterDocument;
exports.exitDocument = exitDocument;
exports.hasClass = hasClass;
exports.isEmpty = isEmpty;
exports.match = match;
exports.next = next;
exports.on = on;
exports.once = once;
exports.parent = parent;
exports.prepend = prepend;
exports.registerCustomEvent = registerCustomEvent;
exports.removeChildren = removeChildren;
exports.removeClasses = removeClasses;
exports.replace = replace;
exports.supportsEvent = supportsEvent;
exports.toElement = toElement;
exports.toggleClasses = toggleClasses;
exports.triggerEvent = triggerEvent;

var _metal = __webpack_require__(1);

var _domData = __webpack_require__(15);

var _domData2 = _interopRequireDefault(_domData);

var _DomDelegatedEventHandle = __webpack_require__(50);

var _DomDelegatedEventHandle2 = _interopRequireDefault(_DomDelegatedEventHandle);

var _DomEventHandle = __webpack_require__(23);

var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var elementsByTag_ = {};
var supportCache_ = {};
var customEvents = exports.customEvents = {};

var LAST_CONTAINER = '__metal_last_container__';
var USE_CAPTURE = {
	blur: true,
	error: true,
	focus: true,
	invalid: true,
	load: true,
	scroll: true
};

/**
 * Adds the requested CSS classes to an element.
 * @param {!Element|!Nodelist} elements The element or elements to add CSS classes to.
 * @param {string} classes CSS classes to add.
 */
function addClasses(elements, classes) {
	if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
		return;
	}

	if (!elements.length) {
		elements = [elements];
	}

	for (var i = 0; i < elements.length; i++) {
		if ('classList' in elements[i]) {
			addClassesWithNative_(elements[i], classes);
		} else {
			addClassesWithoutNative_(elements[i], classes);
		}
	}
}

/**
 * Adds the requested CSS classes to an element using classList.
 * @param {!Element} element The element to add CSS classes to.
 * @param {string} classes CSS classes to add.
 * @private
 */
function addClassesWithNative_(element, classes) {
	classes.split(' ').forEach(function (className) {
		if (className) {
			element.classList.add(className);
		}
	});
}

/**
 * Adds the requested CSS classes to an element without using classList.
 * @param {!Element} element The element to add CSS classes to.
 * @param {string} classes CSS classes to add.
 * @private
 */
function addClassesWithoutNative_(element, classes) {
	var elementClassName = ' ' + element.className + ' ';
	var classesToAppend = '';

	classes = classes.split(' ');

	for (var i = 0; i < classes.length; i++) {
		var className = classes[i];

		if (elementClassName.indexOf(' ' + className + ' ') === -1) {
			classesToAppend += ' ' + className;
		}
	}

	if (classesToAppend) {
		element.className = element.className + classesToAppend;
	}
}

/**
 * Adds an event listener to the given element, to be triggered via delegate.
 * @param {!Element} element
 * @param {string} eventName
 * @param {!function()} listener
 * @private
 */
function addElementListener_(element, eventName, listener) {
	addToArr_(_domData2.default.get(element, 'listeners', {}), eventName, listener);
}

/**
 * Adds an event listener to the given element, to be triggered via delegate
 * selectors.
 * @param {!Element} element
 * @param {string} eventName
 * @param {string} selector
 * @param {!function()} listener
 * @private
 */
function addSelectorListener_(element, eventName, selector, listener) {
	var delegatingData = _domData2.default.get(element, 'delegating', {});
	addToArr_(delegatingData[eventName].selectors, selector, listener);
}

/**
 * Adds a value to an array inside an object, creating it first if it doesn't
 * yet exist.
 * @param {!Array} arr
 * @param {string} key
 * @param {*} value
 * @private
 */
function addToArr_(arr, key, value) {
	if (!arr[key]) {
		arr[key] = [];
	}
	arr[key].push(value);
}

/**
 * Attaches a delegate listener, unless there's already one attached.
 * @param {!Element} element
 * @param {string} eventName
 * @private
 */
function attachDelegateEvent_(element, eventName) {
	var delegatingData = _domData2.default.get(element, 'delegating', {});
	if (!delegatingData[eventName]) {
		delegatingData[eventName] = {
			handle: on(element, eventName, handleDelegateEvent_, !!USE_CAPTURE[eventName]),
			selectors: {}
		};
	}
}

/**
 * Gets the closest element up the tree from the given element (including
 * itself) that matches the specified selector, or null if none match.
 * @param {Element} element
 * @param {string} selector
 * @return {Element}
 */
function closest(element, selector) {
	while (element && !match(element, selector)) {
		element = element.parentNode;
	}
	return element;
}

/**
 * Appends a child node with text or other nodes to a parent node. If
 * child is a HTML string it will be automatically converted to a document
 * fragment before appending it to the parent.
 * @param {!Element} parent The node to append nodes to.
 * @param {!(Element|NodeList|string)} child The thing to append to the parent.
 * @return {!Element} The appended child.
 */
function append(parent, child) {
	if ((0, _metal.isString)(child)) {
		child = buildFragment(child);
	}
	if (isNodeListLike(child)) {
		var childArr = Array.prototype.slice.call(child);
		for (var i = 0; i < childArr.length; i++) {
			parent.appendChild(childArr[i]);
		}
	} else {
		parent.appendChild(child);
	}
	return child;
}

/**
 * Helper for converting a HTML string into a document fragment.
 * @param {string} htmlString The HTML string to convert.
 * @return {!Element} The resulting document fragment.
 */
function buildFragment(htmlString) {
	var tempDiv = document.createElement('div');
	tempDiv.innerHTML = '<br>' + htmlString;
	tempDiv.removeChild(tempDiv.firstChild);

	var fragment = document.createDocumentFragment();
	while (tempDiv.firstChild) {
		fragment.appendChild(tempDiv.firstChild);
	}
	return fragment;
}

/**
 * Checks if the first element contains the second one.
 * @param {!Element} element1
 * @param {!Element} element2
 * @return {boolean}
 */
function contains(element1, element2) {
	if ((0, _metal.isDocument)(element1)) {
		// document.contains is not defined on IE9, so call it on documentElement instead.
		return element1.documentElement.contains(element2);
	} else {
		return element1.contains(element2);
	}
}

/**
 * Listens to the specified event on the given DOM element, but only calls the
 * given callback listener when it's triggered by elements that match the
 * given selector or target element.
 * @param {!Element} element The DOM element the event should be listened on.
 * @param {string} eventName The name of the event to listen to.
 * @param {!Element|string} selectorOrTarget Either an element or css selector
 *     that should match the event for the listener to be triggered.
 * @param {!function(!Object)} callback Function to be called when the event
 *     is triggered. It will receive the normalized event object.
 * @param {boolean=} defaultListener Optional flag indicating if this is a default
 *     listener. That means that it would only be executed after all non
 *     default listeners, and only if the event isn't prevented via
 *     `preventDefault`.
 * @return {!EventHandle} Can be used to remove the listener.
 */
function delegate(element, eventName, selectorOrTarget, callback, defaultListener) {
	var customConfig = customEvents[eventName];
	if (customConfig && customConfig.delegate) {
		eventName = customConfig.originalEvent;
		callback = customConfig.handler.bind(customConfig, callback);
	}

	if (defaultListener) {
		// Wrap callback so we don't set property directly on it.
		callback = callback.bind();
		callback.defaultListener_ = true;
	}

	attachDelegateEvent_(element, eventName);
	if ((0, _metal.isString)(selectorOrTarget)) {
		addSelectorListener_(element, eventName, selectorOrTarget, callback);
	} else {
		addElementListener_(selectorOrTarget, eventName, callback);
	}

	return new _DomDelegatedEventHandle2.default((0, _metal.isString)(selectorOrTarget) ? element : selectorOrTarget, eventName, callback, (0, _metal.isString)(selectorOrTarget) ? selectorOrTarget : null);
}

/**
 * Verifies if the element is able to trigger the Click event,
 * simulating browsers behaviour, avoiding event listeners to be called by triggerEvent method.
 * @param {Element} node Element to be checked.
 * @param {string} eventName The event name.
 * @param {Object=} eventObj
 * @private
 * @return {boolean}
 */
function isAbleToInteractWith_(node, eventName, eventObj) {
	if (eventObj && eventName === 'click' && eventObj.button === 2) {
		// Firefox triggers "click" events on the document for right clicks. This
		// causes our delegate logic to trigger it for regular elements too, which
		// shouldn't happen. Ignoring them here.
		return false;
	}

	var matchesSelector = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'];
	if (eventName === 'click' && matchesSelector.indexOf(node.tagName) > -1) {
		return !(node.disabled || parent(node, 'fieldset[disabled]'));
	}
	return true;
}

/**
 * Returns true if the specified value is a NodeList or like one.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is like a NodeList.
 */
function isNodeListLike(val) {
	return (0, _metal.isDefAndNotNull)(val) && typeof val.length === 'number' && typeof val.item === 'function';
}

/**
 * Inserts node in document as last element.
 * @param {Element} node Element to remove children from.
 */
function enterDocument(node) {
	node && append(document.body, node);
}

/**
 * Removes node from document.
 * @param {Element} node Element to remove children from.
 */
function exitDocument(node) {
	if (node && node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

/**
 * This is called when an event is triggered by a delegate listener. All
 * matching listeners of this event type from `target` to `currentTarget` will
 * be triggered.
 * @param {!Event} event The event payload.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function handleDelegateEvent_(event) {
	normalizeDelegateEvent_(event);
	var ret = true;
	var container = event.currentTarget;
	var defFns = [];

	ret &= triggerDelegatedListeners_(container, event, defFns);
	ret &= triggerDefaultDelegatedListeners_(defFns, event);

	event.delegateTarget = null;
	event[LAST_CONTAINER] = container;
	return ret;
}

/**
 * Checks if the given element has the requested css class.
 * @param {!Element} element
 * @param {string} className
 * @return {boolean}
 */
function hasClass(element, className) {
	if ('classList' in element) {
		return hasClassWithNative_(element, className);
	} else {
		return hasClassWithoutNative_(element, className);
	}
}

/**
 * Checks if the given element has the requested css class using classList.
 * @param {!Element} element
 * @param {string} className
 * @return {boolean}
 * @private
 */
function hasClassWithNative_(element, className) {
	return className.indexOf(' ') === -1 && element.classList.contains(className);
}

/**
 * Checks if the given element has the requested css class without using classList.
 * @param {!Element} element
 * @param {string} className
 * @return {boolean}
 * @private
 */
function hasClassWithoutNative_(element, className) {
	return (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0 && className.split(' ').length === 1;
}

/**
 * Checks if the given element is empty or not.
 * @param {!Element} element
 * @return {boolean}
 */
function isEmpty(element) {
	return element.childNodes.length === 0;
}

/**
 * Check if an element matches a given selector.
 * @param {Element} element
 * @param {string} selector
 * @return {boolean}
 */
function match(element, selector) {
	if (!element || element.nodeType !== 1) {
		return false;
	}

	var p = Element.prototype;
	var m = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;
	if (m) {
		return m.call(element, selector);
	}

	return matchFallback_(element, selector);
}

/**
 * Check if an element matches a given selector, using an internal implementation
 * instead of calling existing javascript functions.
 * @param {Element} element
 * @param {string} selector
 * @return {boolean}
 * @private
 */
function matchFallback_(element, selector) {
	var nodes = document.querySelectorAll(selector, element.parentNode);
	for (var i = 0; i < nodes.length; ++i) {
		if (nodes[i] === element) {
			return true;
		}
	}
	return false;
}

/**
 * Returns the next sibling of the given element that matches the specified
 * selector, or null if there is none.
 * @param {!Element} element
 * @param {?string} selector
 * @return {Element|null}
 */
function next(element, selector) {
	do {
		element = element.nextSibling;
		if (element && match(element, selector)) {
			return element;
		}
	} while (element);
	return null;
}

/**
 * Normalizes the event payload for delegate listeners.
 * @param {!Event} event
 * @private
 */
function normalizeDelegateEvent_(event) {
	event.stopPropagation = stopPropagation_;
	event.stopImmediatePropagation = stopImmediatePropagation_;
}

/**
 * Listens to the specified event on the given DOM element. This function normalizes
 * DOM event payloads and functions so they'll work the same way on all supported
 * browsers.
 * @param {!Element|string} element The DOM element to listen to the event on, or
 *   a selector that should be delegated on the entire document.
 * @param {string} eventName The name of the event to listen to.
 * @param {!function(!Object)} callback Function to be called when the event is
 *   triggered. It will receive the normalized event object.
 * @param {boolean} capture Flag indicating if listener should be triggered
 *   during capture phase, instead of during the bubbling phase. Defaults to false.
 * @return {!DomEventHandle} Can be used to remove the listener.
 */
function on(element, eventName, callback, capture) {
	if ((0, _metal.isString)(element)) {
		return delegate(document, eventName, element, callback);
	}
	var customConfig = customEvents[eventName];
	if (customConfig && customConfig.event) {
		eventName = customConfig.originalEvent;
		callback = customConfig.handler.bind(customConfig, callback);
	}
	element.addEventListener(eventName, callback, capture);
	return new _DomEventHandle2.default(element, eventName, callback, capture);
}

/**
 * Listens to the specified event on the given DOM element once. This
 * function normalizes DOM event payloads and functions so they'll work the
 * same way on all supported browsers.
 * @param {!Element} element The DOM element to listen to the event on.
 * @param {string} eventName The name of the event to listen to.
 * @param {!function(!Object)} callback Function to be called when the event
 *   is triggered. It will receive the normalized event object.
 * @return {!DomEventHandle} Can be used to remove the listener.
 */
function once(element, eventName, callback) {
	var domEventHandle = on(element, eventName, function() {
		domEventHandle.removeListener();
		return callback.apply(this, arguments); // eslint-disable-line
	});
	return domEventHandle;
}

/**
 * Gets the first parent from the given element that matches the specified
 * selector, or null if none match.
 * @param {!Element} element
 * @param {string} selector
 * @return {Element}
 */
function parent(element, selector) {
	return closest(element.parentNode, selector);
}

/**
 * Inserts a node before first child of the parent. If child is a HTML string
 * it will be converted to document fragment before prepending it to the parent.
 * @param {!Element} parent The node to prepend to.
 * @param {!(Element|NodeList|string)} child The thing to prepend to the parent.
 * @return {!Element} The prepended child.
 */
function prepend(parent, child) {
	if ((0, _metal.isString)(child)) {
		child = buildFragment(child);
	}

	if (!isNodeListLike(child) && !(0, _metal.isDefAndNotNull)(parent.firstChild)) {
		return append(parent, child);
	}

	if (isNodeListLike(child)) {
		var childArr = Array.prototype.slice.call(child);
		for (var i = childArr.length - 1; i >= 0; i--) {
			parent.insertBefore(childArr[i], parent.firstChild);
		}
	} else {
		parent.insertBefore(child, parent.firstChild);
	}

	return child;
}

/**
 * Registers a custom event.
 * @param {string} eventName The name of the custom event.
 * @param {!Object} customConfig An object with information about how the event
 *   should be handled.
 */
function registerCustomEvent(eventName, customConfig) {
	customEvents[eventName] = customConfig;
}

/**
 * Removes all the child nodes on a DOM node.
 * @param {Element} node Element to remove children from.
 */
function removeChildren(node) {
	var child = void 0;
	while (child = node.firstChild) {
		node.removeChild(child);
	}
}

/**
 * Removes the requested CSS classes from an element.
 * @param {!Element|!NodeList} elements The element or elements to remove CSS classes from.
 * @param {string} classes CSS classes to remove.
 */
function removeClasses(elements, classes) {
	if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
		return;
	}

	if (!elements.length) {
		elements = [elements];
	}

	for (var i = 0; i < elements.length; i++) {
		if ('classList' in elements[i]) {
			removeClassesWithNative_(elements[i], classes);
		} else {
			removeClassesWithoutNative_(elements[i], classes);
		}
	}
}

/**
 * Removes the requested CSS classes from an element using classList.
 * @param {!Element} element The element to remove CSS classes from.
 * @param {string} classes CSS classes to remove.
 * @private
 */
function removeClassesWithNative_(element, classes) {
	classes.split(' ').forEach(function (className) {
		if (className) {
			element.classList.remove(className);
		}
	});
}

/**
 * Removes the requested CSS classes from an element without using classList.
 * @param {!Element} element The element to remove CSS classes from.
 * @param {string} classes CSS classes to remove.
 * @private
 */
function removeClassesWithoutNative_(element, classes) {
	var elementClassName = ' ' + element.className + ' ';

	classes = classes.split(' ');

	for (var i = 0; i < classes.length; i++) {
		elementClassName = elementClassName.replace(' ' + classes[i] + ' ', ' ');
	}

	element.className = elementClassName.trim();
}

/**
 * Replaces the first element with the second.
 * @param {Element} element1
 * @param {Element} element2
 */
function replace(element1, element2) {
	if (element1 && element2 && element1 !== element2 && element1.parentNode) {
		element1.parentNode.insertBefore(element2, element1);
		element1.parentNode.removeChild(element1);
	}
}

/**
 * The function that replaces `stopImmediatePropagation_` for events.
 * @private
 */
function stopImmediatePropagation_() {
	var event = this; // eslint-disable-line
	event.stopped = true;
	event.stoppedImmediate = true;
	Event.prototype.stopImmediatePropagation.call(event);
}

/**
 * The function that replaces `stopPropagation` for events.
 * @private
 */
function stopPropagation_() {
	var event = this; // eslint-disable-line
	event.stopped = true;
	Event.prototype.stopPropagation.call(event);
}

/**
 * Checks if the given element supports the given event type.
 * @param {!Element|string} element The DOM element or element tag name to check.
 * @param {string} eventName The name of the event to check.
 * @return {boolean}
 */
function supportsEvent(element, eventName) {
	if (customEvents[eventName]) {
		return true;
	}

	if ((0, _metal.isString)(element)) {
		if (!elementsByTag_[element]) {
			elementsByTag_[element] = document.createElement(element);
		}
		element = elementsByTag_[element];
	}

	var tag = element.tagName;
	if (!supportCache_[tag] || !supportCache_[tag].hasOwnProperty(eventName)) {
		supportCache_[tag] = supportCache_[tag] || {};
		supportCache_[tag][eventName] = 'on' + eventName in element;
	}
	return supportCache_[tag][eventName];
}

/**
 * This triggers all default matched delegated listeners of a given event type.
 * @param {!Array} defFns Array to collect default listeners in, instead
 * @param {!Event} event
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerDefaultDelegatedListeners_(defFns, event) {
	var ret = true;

	for (var i = 0; i < defFns.length && !event.defaultPrevented; i++) {
		event.delegateTarget = defFns[i].element;
		ret &= defFns[i].fn(event);
	}

	return ret;
}

/**
 * This triggers all matched delegated listeners of a given event type when its
 * delegated target is able to interact.
 * @param {!Element} container
 * @param {!Event} event
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerDelegatedListeners_(container, event, defaultFns) {
	var ret = true;
	var currElement = event.target;
	var limit = container.parentNode;

	while (currElement && currElement !== limit && !event.stopped) {
		if (isAbleToInteractWith_(currElement, event.type, event)) {
			event.delegateTarget = currElement;
			ret &= triggerElementListeners_(currElement, event, defaultFns);
			ret &= triggerSelectorListeners_(container, currElement, event, defaultFns);
		}
		currElement = currElement.parentNode;
	}

	return ret;
}

/**
 * Converts the given argument to a DOM element. Strings are assumed to
 * be selectors, and so a matched element will be returned. If the arg
 * is already a DOM element it will be the return value.
 * @param {string|Element|Document} selectorOrElement
 * @return {Element} The converted element, or null if none was found.
 */
function toElement(selectorOrElement) {
	if ((0, _metal.isElement)(selectorOrElement) || (0, _metal.isDocument)(selectorOrElement) || (0, _metal.isDocumentFragment)(selectorOrElement)) {
		return selectorOrElement;
	} else if ((0, _metal.isString)(selectorOrElement)) {
		if (selectorOrElement[0] === '#' && selectorOrElement.indexOf(' ') === -1) {
			return document.getElementById(selectorOrElement.substr(1));
		} else {
			return document.querySelector(selectorOrElement);
		}
	} else {
		return null;
	}
}

/**
 * Adds or removes one or more classes from an element. If any of the classes
 * is present, it will be removed from the element, or added otherwise.
 * @param {!Element} element The element which classes will be toggled.
 * @param {string} classes The classes which have to added or removed from the element.
 */
function toggleClasses(element, classes) {
	if (!(0, _metal.isObject)(element) || !(0, _metal.isString)(classes)) {
		return;
	}

	if ('classList' in element) {
		toggleClassesWithNative_(element, classes);
	} else {
		toggleClassesWithoutNative_(element, classes);
	}
}

/**
 * Adds or removes one or more classes from an element using classList.
 * If any of the classes is present, it will be removed from the element,
 * or added otherwise.
 * @param {!Element} element The element which classes will be toggled.
 * @param {string} classes The classes which have to added or removed from the element.
 * @private
 */
function toggleClassesWithNative_(element, classes) {
	classes.split(' ').forEach(function (className) {
		element.classList.toggle(className);
	});
}

/**
 * Adds or removes one or more classes from an element without using classList.
 * If any of the classes is present, it will be removed from the element,
 * or added otherwise.
 * @param {!Element} element The element which classes will be toggled.
 * @param {string} classes The classes which have to added or removed from the element.
 * @private
 */
function toggleClassesWithoutNative_(element, classes) {
	var elementClassName = ' ' + element.className + ' ';

	classes = classes.split(' ');

	for (var i = 0; i < classes.length; i++) {
		var className = ' ' + classes[i] + ' ';
		var classIndex = elementClassName.indexOf(className);

		if (classIndex === -1) {
			elementClassName = '' + elementClassName + classes[i] + ' ';
		} else {
			var before = elementClassName.substring(0, classIndex);
			var after = elementClassName.substring(classIndex + className.length); // eslint-disable-line
			elementClassName = before + ' ' + after;
		}
	}

	element.className = elementClassName.trim();
}

/**
 * Triggers all listeners for the given event type that are stored in the
 * specified element.
 * @param {!Element} element
 * @param {!Event} event
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerElementListeners_(element, event, defaultFns) {
	var lastContainer = event[LAST_CONTAINER];
	if (!(0, _metal.isDef)(lastContainer) || !contains(lastContainer, element)) {
		var listeners = _domData2.default.get(element, 'listeners', {})[event.type];
		return triggerListeners_(listeners, event, element, defaultFns);
	}
	return true;
}

/**
 * Triggers the specified event on the given element.
 * NOTE: This should mostly be used for testing, not on real code.
 * @param {!Element} element The node that should trigger the event.
 * @param {string} eventName The name of the event to be triggred.
 * @param {Object=} eventObj An object with data that should be on the
 *   triggered event's payload.
 */
function triggerEvent(element, eventName, eventObj) {
	if (isAbleToInteractWith_(element, eventName, eventObj)) {
		var payload = document.createEvent('HTMLEvents');
		payload.initEvent(eventName, true, true);
		_metal.object.mixin(payload, eventObj);
		element.dispatchEvent(payload);
	}
}

/**
 * Triggers the given listeners array.
 * @param {Array<!function()>} listeners
 * @param {!Event} event
 * @param {!Element} element
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerListeners_(listeners, event, element, defaultFns) {
	var ret = true;
	listeners = listeners || [];
	for (var i = 0; i < listeners.length && !event.stoppedImmediate; i++) {
		if (listeners[i].defaultListener_) {
			defaultFns.push({
				element: element,
				fn: listeners[i]
			});
		} else {
			ret &= listeners[i](event);
		}
	}
	return ret;
}

/**
 * Triggers all selector listeners for the given event.
 * @param {!Element} container
 * @param {!Element} element
 * @param {!Event} event
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerSelectorListeners_(container, element, event, defaultFns) {
	var ret = true;
	var data = _domData2.default.get(container, 'delegating', {});
	var map = data[event.type].selectors;
	var selectors = Object.keys(map);
	for (var i = 0; i < selectors.length && !event.stoppedImmediate; i++) {
		if (match(element, selectors[i])) {
			var listeners = map[selectors[i]];
			ret &= triggerListeners_(listeners, event, element, defaultFns);
		}
	}
	return ret;
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

var _domData = __webpack_require__(15);

var _domData2 = _interopRequireDefault(_domData);

var _metalEvents = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is a special EventHandle, that is responsible for dom delegated events
 * (only the ones that receive a target element, not a selector string).
 * @extends {EventHandle}
 */
var DomDelegatedEventHandle = function(_EventHandle) {
	_inherits(DomDelegatedEventHandle, _EventHandle);

	/**
* The constructor for `DomDelegatedEventHandle`.
* @param {!Event} emitter Element the event was subscribed to.
* @param {string} event The name of the event that was subscribed to.
* @param {!Function} listener The listener subscribed to the event.
* @param {string=} selector An optional selector used when delegating
*     the event.
* @constructor
*/
	function DomDelegatedEventHandle(emitter, event, listener, selector) {
		_classCallCheck(this, DomDelegatedEventHandle);

		var _this = _possibleConstructorReturn(this, (DomDelegatedEventHandle.__proto__ || Object.getPrototypeOf(DomDelegatedEventHandle)).call(this, emitter, event, listener));

		_this.selector_ = selector;
		return _this;
	}

	/**
* @inheritDoc
*/

	_createClass(DomDelegatedEventHandle, [{
		key: 'removeListener',
		value: function removeListener() {
			var delegating = _domData2.default.get(this.emitter_, 'delegating', {});
			var listeners = _domData2.default.get(this.emitter_, 'listeners', {});
			var selector = this.selector_;
			var arr = (0, _metal.isString)(selector) ? delegating[this.event_].selectors : listeners;
			var key = (0, _metal.isString)(selector) ? selector : this.event_;

			_metal.array.remove(arr[key] || [], this.listener_);
			if (arr[key] && arr[key].length === 0) {
				delete arr[key];
			}
		}
	}]);

	return DomDelegatedEventHandle;
}(_metalEvents.EventHandle);

exports.default = DomDelegatedEventHandle;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _dom = __webpack_require__(7);

var _metalEvents = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * DomEventEmitterProxy utility. It extends `EventEmitterProxy` to also accept
 * dom elements as origin emitters.
 * @extends {EventEmitterProxy}
 */
var DomEventEmitterProxy = function(_EventEmitterProxy) {
	_inherits(DomEventEmitterProxy, _EventEmitterProxy);

	function DomEventEmitterProxy() {
		_classCallCheck(this, DomEventEmitterProxy);

		return _possibleConstructorReturn(this, (DomEventEmitterProxy.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy)).apply(this, arguments));
	}

	_createClass(DomEventEmitterProxy, [{
		key: 'addListener_',

		/**
* Adds the given listener for the given event.
* @param {string} event
* @param {!function()} listener
* @return {!EventHandle} The listened event's handle.
* @protected
* @override
*/
		value: function addListener_(event, listener) {
			if (this.originEmitter_.addEventListener) {
				if (this.isDelegateEvent_(event)) {
					var index = event.indexOf(':', 9);
					var eventName = event.substring(9, index);
					var selector = event.substring(index + 1);
					return (0, _dom.delegate)(this.originEmitter_, eventName, selector, listener); // eslint-disable-line
				} else {
					return (0, _dom.on)(this.originEmitter_, event, listener);
				}
			} else {
				return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'addListener_', this).call(this, event, listener);
			}
		}

		/**
* Checks if the given event is of the delegate type.
* @param {string} event
* @return {boolean}
* @protected
*/

	}, {
		key: 'isDelegateEvent_',
		value: function isDelegateEvent_(event) {
			return event.substr(0, 9) === 'delegate:';
		}

		/**
* Checks if the given event is supported by the origin element.
* @param {string} event
* @protected
* @return {boolean}
*/

	}, {
		key: 'isSupportedDomEvent_',
		value: function isSupportedDomEvent_(event) {
			if (!this.originEmitter_ || !this.originEmitter_.addEventListener) {
				return true;
			}
			return this.isDelegateEvent_(event) && event.indexOf(':', 9) !== -1 || (0, _dom.supportsEvent)(this.originEmitter_, event);
		}

		/**
* Checks if the given event should be proxied.
* @param {string} event
* @return {boolean}
* @protected
* @override
*/

	}, {
		key: 'shouldProxyEvent_',
		value: function shouldProxyEvent_(event) {
			return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'shouldProxyEvent_', this).call(this, event) && this.isSupportedDomEvent_(event); // eslint-disable-line
		}
	}]);

	return DomEventEmitterProxy;
}(_metalEvents.EventEmitterProxy);

exports.default = DomEventEmitterProxy;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

var _dom = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility functions for running javascript code in the global scope.
 */
var globalEval = function() {
	function globalEval() {
		_classCallCheck(this, globalEval);
	}

	_createClass(globalEval, null, [{
		key: 'run',

		/**
* Evaluates the given string in the global scope.
* @param {string} text
* @param {function()=} appendFn Optional function to append the node
*   into document.
* @return {Element} script
*/
		value: function run(text, appendFn) {
			var script = document.createElement('script');
			script.text = text;
			if (appendFn) {
				appendFn(script);
			} else {
				document.head.appendChild(script);
			}
			(0, _dom.exitDocument)(script);
			return script;
		}

		/**
* Evaluates the given javascript file in the global scope.
* @param {string} src The file's path.
* @param {function()=} defaultFn Optional function to be called
*   when the script has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
* @return {Element} script
*/

	}, {
		key: 'runFile',
		value: function runFile(src, defaultFn, appendFn) {
			var script = document.createElement('script');
			script.src = src;

			var callback = function callback() {
				(0, _dom.exitDocument)(script);
				defaultFn && defaultFn();
			};
			(0, _dom.once)(script, 'load', callback);
			(0, _dom.once)(script, 'error', callback);

			if (appendFn) {
				appendFn(script);
			} else {
				document.head.appendChild(script);
			}

			return script;
		}

		/**
* Evaluates the code referenced by the given script element.
* @param {!Element} script
* @param {function()=} defaultFn Optional function to be called
*   when the script has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
* @return {Element} script
*/

	}, {
		key: 'runScript',
		value: function runScript(script, defaultFn, appendFn) {
			var callback = function callback() {
				defaultFn && defaultFn();
			};
			if (script.type && script.type !== 'text/javascript') {
				_metal.async.nextTick(callback);
				return;
			}
			(0, _dom.exitDocument)(script);
			if (script.src) {
				return globalEval.runFile(script.src, defaultFn, appendFn);
			} else {
				_metal.async.nextTick(callback);
				return globalEval.run(script.text, appendFn);
			}
		}

		/**
* Evaluates any script tags present in the given element.
* @param {!Element} element
* @param {function()=} defaultFn Optional function to be called
*   when the script has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
*/

	}, {
		key: 'runScriptsInElement',
		value: function runScriptsInElement(element, defaultFn, appendFn) {
			var scripts = element.querySelectorAll('script');
			if (scripts.length) {
				globalEval.runScriptsInOrder(scripts, 0, defaultFn, appendFn);
			} else if (defaultFn) {
				_metal.async.nextTick(defaultFn);
			}
		}

		/**
* Runs the given scripts elements in the order that they appear.
* @param {!NodeList} scripts
* @param {number} index
* @param {function()=} defaultFn Optional function to be called
*   when the script has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
*/

	}, {
		key: 'runScriptsInOrder',
		value: function runScriptsInOrder(scripts, index, defaultFn, appendFn) {
			globalEval.runScript(scripts.item(index), function() {
				if (index < scripts.length - 1) {
					globalEval.runScriptsInOrder(scripts, index + 1, defaultFn, appendFn); // eslint-disable-line
				} else if (defaultFn) {
					_metal.async.nextTick(defaultFn);
				}
			}, appendFn);
		}
	}]);

	return globalEval;
}();

exports.default = globalEval;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

var _dom = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility functions for running styles.
 */
var globalEvalStyles = function() {
	function globalEvalStyles() {
		_classCallCheck(this, globalEvalStyles);
	}

	_createClass(globalEvalStyles, null, [{
		key: 'run',

		/**
* Evaluates the given style.
* @param {string} text
* @param {function()=} appendFn Optional function to append the node
*   into document.
* @return {Element} style
*/
		value: function run(text, appendFn) {
			var style = document.createElement('style');
			style.innerHTML = text;
			if (appendFn) {
				appendFn(style);
			} else {
				document.head.appendChild(style);
			}
			return style;
		}

		/**
* Evaluates the given style file.
* @param {string} href The file's path.
* @param {function()=} defaultFn Optional function to be called
*   when the styles has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
* @return {Element} style
*/

	}, {
		key: 'runFile',
		value: function runFile(href, defaultFn, appendFn) {
			var link = document.createElement('link');
			link.rel = 'stylesheet';
			link.href = href;
			globalEvalStyles.runStyle(link, defaultFn, appendFn);
			return link;
		}

		/**
* Evaluates the code referenced by the given style/link element.
* @param {!Element} style
* @param {function()=} defaultFn Optional function to be called
*   when the script has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
*  @return {Element} style
*/

	}, {
		key: 'runStyle',
		value: function runStyle(style, defaultFn, appendFn) {
			var callback = function callback() {
				defaultFn && defaultFn();
			};
			if (style.rel && style.rel !== 'stylesheet') {
				_metal.async.nextTick(callback);
				return;
			}

			if (style.tagName === 'STYLE') {
				_metal.async.nextTick(callback);
			} else {
				(0, _dom.once)(style, 'load', callback);
				(0, _dom.once)(style, 'error', callback);
			}

			if (appendFn) {
				appendFn(style);
			} else {
				document.head.appendChild(style);
			}

			return style;
		}

		/**
* Evaluates any style present in the given element.
* @param {!Element} element
* @param {function()=} defaultFn Optional function to be called when the
*   style has been run.
* @param {function()=} appendFn Optional function to append the node
*   into document.
*/

	}, {
		key: 'runStylesInElement',
		value: function runStylesInElement(element, defaultFn, appendFn) {
			var styles = element.querySelectorAll('style,link');
			if (styles.length === 0 && defaultFn) {
				_metal.async.nextTick(defaultFn);
				return;
			}

			var loadCount = 0;
			var callback = function callback() {
				if (defaultFn && ++loadCount === styles.length) {
					_metal.async.nextTick(defaultFn);
				}
			};
			for (var i = 0; i < styles.length; i++) {
				globalEvalStyles.runStyle(styles[i], callback, appendFn);
			}
		}
	}]);

	return globalEvalStyles;
}();

exports.default = globalEvalStyles;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _metal = __webpack_require__(1);

var _dom = __webpack_require__(7);

var _features = __webpack_require__(24);

var _features2 = _interopRequireDefault(_features);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Register custom events for event delegation.
 */
function registerEvents() {
	var mouseEventMap = {
		mouseenter: 'mouseover',
		mouseleave: 'mouseout',
		pointerenter: 'pointerover',
		pointerleave: 'pointerout'
	};
	Object.keys(mouseEventMap).forEach(function (eventName) {
		(0, _dom.registerCustomEvent)(eventName, {
			delegate: true,
			handler: function handler(callback, event) {
				var related = event.relatedTarget;
				var target = event.delegateTarget;
				// eslint-disable-next-line
				if (!related || related !== target && !(0, _dom.contains)(target, related)) {
					event.customType = eventName;
					return callback(event);
				}
			},
			originalEvent: mouseEventMap[eventName]
		});
	});

	var animationEventMap = {
		animation: 'animationend',
		transition: 'transitionend'
	};
	Object.keys(animationEventMap).forEach(function (eventType) {
		var eventName = animationEventMap[eventType];
		(0, _dom.registerCustomEvent)(eventName, {
			event: true,
			delegate: true,
			handler: function handler(callback, event) {
				event.customType = eventName;
				return callback(event);
			},
			originalEvent: _features2.default.checkAnimationEventName()[eventType]
		});
	});
}

if (!(0, _metal.isServerSide)()) {
	registerEvents();
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The component registry is used to register components, so they can
 * be accessible by name.
 * @type {Object}
 */
var ComponentRegistry = function() {
	function ComponentRegistry() {
		_classCallCheck(this, ComponentRegistry);
	}

	_createClass(ComponentRegistry, null, [{
		key: 'getConstructor',

		/**
* Gets the constructor function for the given component name, or
* undefined if it hasn't been registered yet.
* @param {string} name The component's name.
* @return {?function()}
* @static
*/
		value: function getConstructor(name) {
			var constructorFn = ComponentRegistry.components_[name];
			if (!constructorFn) {
				console.error('There\'s no constructor registered for the component named ' + name + '.\n\t\t\t\tComponents need to be registered via ComponentRegistry.register.');
			}
			return constructorFn;
		}

		/**
* Registers a component, so it can be found by its name.
* @param {!Function} constructorFn The component's constructor function.
* @param {string=} name Name of the registered component. If none is given
*   the name defined by the NAME static variable will be used instead. If that
*   isn't set as well, the name of the constructor function will be used.
* @static
*/

	}, {
		key: 'register',
		value: function register(constructorFn, name) {
			if (!name) {
				if (constructorFn.hasOwnProperty('NAME')) {
					name = constructorFn.NAME;
				} else {
					name = (0, _metal.getFunctionName)(constructorFn);
				}
			}
			constructorFn.NAME = name;
			ComponentRegistry.components_[name] = constructorFn;
		}
	}]);

	return ComponentRegistry;
}();

/**
 * Holds all registered components, indexed by their names.
 * @type {!Object<string, function()>}
 * @protected
 * @static
 */

ComponentRegistry.components_ = {};

exports.default = ComponentRegistry;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(12);

(function () {
this.CLOSURE_NO_DEPS = true;
this.goog = this.goog || {};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
* @fileoverview Bootstrap for the Google JS Library (Closure).
*
* In uncompiled mode base.js will write out Closure's deps file, unless the
* global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
* include their own deps file(s) from different locations.
*
* @author arv@google.com (Erik Arvidsson)
*
* @provideGoog
*/

/**
* @define {boolean} Overridden to true by the compiler when
*     --process_closure_primitives is specified.
*/
var COMPILED = false;

/**
* Base namespace for the Closure library.  Checks to see goog is already
* defined in the current scope before assigning to prevent clobbering if
* base.js is loaded more than once.
*
* @const
*/
var goog = this.goog || {};

/**
* Reference to the global context.  In most cases this will be 'window'.
*/
goog.global = this;

/**
* A hook for overriding the define values in uncompiled mode.
*
* In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
* loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
* {@code goog.define} will use the value instead of the default value.  This
* allows flags to be overwritten without compilation (this is normally
* accomplished with the compiler's "define" flag).
*
* Example:
* <pre>
*   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
* </pre>
*
* @type {Object<string, (string|number|boolean)>|undefined}
*/
goog.global.CLOSURE_UNCOMPILED_DEFINES;

/**
* A hook for overriding the define values in uncompiled or compiled mode,
* like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
* uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
*
* Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
* string literals or the compiler will emit an error.
*
* While any @define value may be set, only those set with goog.define will be
* effective for uncompiled code.
*
* Example:
* <pre>
*   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
* </pre>
*
* @type {Object<string, (string|number|boolean)>|undefined}
*/
goog.global.CLOSURE_DEFINES;

/**
* Returns true if the specified value is not undefined.
* WARNING: Do not use this to test if an object has a property. Use the in
* operator instead.
*
* @param {?} val Variable to test.
* @return {boolean} Whether variable is defined.
*/
goog.isDef = function(val) {
	// void 0 always evaluates to undefined and hence we do not need to depend on
	// the definition of the global variable named 'undefined'.
	return val !== void 0;
};

/**
* Builds an object structure for the provided namespace path, ensuring that
* names that already exist are not overwritten. For example:
* "a.b.c" -> a = {};a.b={};a.b.c={};
* Used by goog.provide and goog.exportSymbol.
* @param {string} name name of the object that this file defines.
* @param {*=} opt_object the object to expose at the end of the path.
* @param {Object=} opt_objectToExportTo The object to add the path to; default
*     is |goog.global|.
* @private
*/
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
	var parts = name.split('.');
	var cur = opt_objectToExportTo || goog.global;

	// Internet Explorer exhibits strange behavior when throwing errors from
	// methods externed in this manner.  See the testExportSymbolExceptions in
	// base_test.html for an example.
	if (!(parts[0] in cur) && cur.execScript) {
	  cur.execScript('var ' + parts[0]);
	}

	// Certain browsers cannot parse code in the form for((a in b); c;);
	// This pattern is produced by the JSCompiler when it collapses the
	// statement above into the conditional loop below. To prevent this from
	// happening, use a for-loop and reserve the init logic as below.

	// Parentheses added to eliminate strict JS warning in Firefox.
	for (var part; parts.length && (part = parts.shift());) {
	  if (!parts.length && goog.isDef(opt_object)) {
		// last part and we have an object; use it
		cur[part] = opt_object;
	  } else if (cur[part]) {
		cur = cur[part];
	  } else {
		cur = cur[part] = {};
	  }
	}
};

/**
* Defines a named value. In uncompiled mode, the value is retrieved from
* CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
* has the property specified, and otherwise used the defined defaultValue.
* When compiled the default can be overridden using the compiler
* options or the value set in the CLOSURE_DEFINES object.
*
* @param {string} name The distinguished name to provide.
* @param {string|number|boolean} defaultValue
*/
goog.define = function(name, defaultValue) {
	var value = defaultValue;
	if (!COMPILED) {
	  if (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
		value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
	  } else if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, name)) {
		value = goog.global.CLOSURE_DEFINES[name];
	  }
	}
	goog.exportPath_(name, value);
};

/**
* @define {boolean} DEBUG is provided as a convenience so that debugging code
* that should not be included in a production js_binary can be easily stripped
* by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
* toString() methods should be declared inside an "if (goog.DEBUG)" conditional
* because they are generally used for debugging purposes and it is difficult
* for the JSCompiler to statically determine whether they are used.
*/
goog.define('goog.DEBUG', true);

/**
* @define {string} LOCALE defines the locale being used for compilation. It is
* used to select locale specific data to be compiled in js binary. BUILD rule
* can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
* option.
*
* Take into account that the locale code format is important. You should use
* the canonical Unicode format with hyphen as a delimiter. Language must be
* lowercase, Language Script - Capitalized, Region - UPPERCASE.
* There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
*
* See more info about locale codes here:
* http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
*
* For language codes you should use values defined by ISO 693-1. See it here
* http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
* this rule: the Hebrew language. For legacy reasons the old code (iw) should
* be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
*/
goog.define('goog.LOCALE', 'en'); // default to en

/**
* @define {boolean} Whether this code is running on trusted sites.
*
* On untrusted sites, several native functions can be defined or overridden by
* external libraries like Prototype, Datejs, and JQuery and setting this flag
* to false forces closure to use its own implementations when possible.
*
* If your JavaScript can be loaded by a third party site and you are wary about
* relying on non-standard implementations, specify
* "--define goog.TRUSTED_SITE=false" to the JSCompiler.
*/
goog.define('goog.TRUSTED_SITE', true);

/**
* @define {boolean} Whether a project is expected to be running in strict mode.
*
* This define can be used to trigger alternate implementations compatible with
* running in EcmaScript Strict mode or warn about unavailable functionality.
* @see https://goo.gl/g5EoHI
*
*/
goog.define('goog.STRICT_MODE_COMPATIBLE', false);

/**
* @define {boolean} Whether code that calls {@link goog.setTestOnly} should
*     be disallowed in the compilation unit.
*/
goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);

/**
* @define {boolean} Whether to use a Chrome app CSP-compliant method for
*     loading scripts via goog.require. @see appendScriptSrcNode_.
*/
goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);

/**
* Defines a namespace in Closure.
*
* A namespace may only be defined once in a codebase. It may be defined using
* goog.provide() or goog.module().
*
* The presence of one or more goog.provide() calls in a file indicates
* that the file defines the given objects/namespaces.
* Provided symbols must not be null or undefined.
*
* In addition, goog.provide() creates the object stubs for a namespace
* (for example, goog.provide("goog.foo.bar") will create the object
* goog.foo.bar if it does not already exist).
*
* Build tools also scan for provide/require/module statements
* to discern dependencies, build dependency files (see deps.js), etc.
*
* @see goog.require
* @see goog.module
* @param {string} name Namespace provided by this file in the form
*     "goog.package.part".
*/
goog.provide = function(name) {
	if (!COMPILED) {
	  // Ensure that the same namespace isn't provided twice.
	  // A goog.module/goog.provide maps a goog.require to a specific file
	  if (goog.isProvided_(name)) {
		throw Error('Namespace "' + name + '" already declared.');
	  }
	}

	goog.constructNamespace_(name);
};

/**
* @param {string} name Namespace provided by this file in the form
*     "goog.package.part".
* @param {Object=} opt_obj The object to embed in the namespace.
* @private
*/
goog.constructNamespace_ = function(name, opt_obj) {
	if (!COMPILED) {
	  delete goog.implicitNamespaces_[name];

	  var namespace = name;
	  while (namespace = namespace.substring(0, namespace.lastIndexOf('.'))) {
		if (goog.getObjectByName(namespace)) {
		  break;
		}
		goog.implicitNamespaces_[namespace] = true;
	  }
	}

	goog.exportPath_(name, opt_obj);
};

/**
* Module identifier validation regexp.
* Note: This is a conservative check, it is very possible to be more lenient,
*   the primary exclusion here is "/" and "\" and a leading ".", these
*   restrictions are intended to leave the door open for using goog.require
*   with relative file paths rather than module identifiers.
* @private
*/
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;

/**
* Defines a module in Closure.
*
* Marks that this file must be loaded as a module and claims the namespace.
*
* A namespace may only be defined once in a codebase. It may be defined using
* goog.provide() or goog.module().
*
* goog.module() has three requirements:
* - goog.module may not be used in the same file as goog.provide.
* - goog.module must be the first statement in the file.
* - only one goog.module is allowed per file.
*
* When a goog.module annotated file is loaded, it is enclosed in
* a strict function closure. This means that:
* - any variables declared in a goog.module file are private to the file
* (not global), though the compiler is expected to inline the module.
* - The code must obey all the rules of "strict" JavaScript.
* - the file will be marked as "use strict"
*
* NOTE: unlike goog.provide, goog.module does not declare any symbols by
* itself. If declared symbols are desired, use
* goog.module.declareLegacyNamespace().
*
*
* See the public goog.module proposal: http://goo.gl/Va1hin
*
* @param {string} name Namespace provided by this file in the form
*     "goog.package.part", is expected but not required.
*/
goog.module = function(name) {
	if (!goog.isString(name) || !name || name.search(goog.VALID_MODULE_RE_) == -1) {
	  throw Error('Invalid module identifier');
	}
	if (!goog.isInModuleLoader_()) {
	  throw Error('Module ' + name + ' has been loaded incorrectly.');
	}
	if (goog.moduleLoaderState_.moduleName) {
	  throw Error('goog.module may only be called once per module.');
	}

	// Store the module name for the loader.
	goog.moduleLoaderState_.moduleName = name;
	if (!COMPILED) {
	  // Ensure that the same namespace isn't provided twice.
	  // A goog.module/goog.provide maps a goog.require to a specific file
	  if (goog.isProvided_(name)) {
		throw Error('Namespace "' + name + '" already declared.');
	  }
	  delete goog.implicitNamespaces_[name];
	}
};

/**
* @param {string} name The module identifier.
* @return {?} The module exports for an already loaded module or null.
*
* Note: This is not an alternative to goog.require, it does not
* indicate a hard dependency, instead it is used to indicate
* an optional dependency or to access the exports of a module
* that has already been loaded.
* @suppress {missingProvide}
*/
goog.module.get = function(name) {
	return goog.module.getInternal_(name);
};

/**
* @param {string} name The module identifier.
* @return {?} The module exports for an already loaded module or null.
* @private
*/
goog.module.getInternal_ = function(name) {
	if (!COMPILED) {
	  if (goog.isProvided_(name)) {
		// goog.require only return a value with-in goog.module files.
		return name in goog.loadedModules_ ? goog.loadedModules_[name] : goog.getObjectByName(name);
	  } else {
		return null;
	  }
	}
};

/**
* @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}
*/
goog.moduleLoaderState_ = null;

/**
* @private
* @return {boolean} Whether a goog.module is currently being initialized.
*/
goog.isInModuleLoader_ = function() {
	return goog.moduleLoaderState_ != null;
};

/**
* Provide the module's exports as a globally accessible object under the
* module's declared name.  This is intended to ease migration to goog.module
* for files that have existing usages.
* @suppress {missingProvide}
*/
goog.module.declareLegacyNamespace = function() {
	if (!COMPILED && !goog.isInModuleLoader_()) {
	  throw new Error('goog.module.declareLegacyNamespace must be called from ' + 'within a goog.module');
	}
	if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
	  throw Error('goog.module must be called prior to ' + 'goog.module.declareLegacyNamespace.');
	}
	goog.moduleLoaderState_.declareLegacyNamespace = true;
};

/**
* Marks that the current file should only be used for testing, and never for
* live code in production.
*
* In the case of unit tests, the message may optionally be an exact namespace
* for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
* provide (if not explicitly defined in the code).
*
* @param {string=} opt_message Optional message to add to the error that's
*     raised when used in production code.
*/
goog.setTestOnly = function(opt_message) {
	if (goog.DISALLOW_TEST_ONLY_CODE) {
	  opt_message = opt_message || '';
	  throw Error('Importing test-only code into non-debug environment' + (opt_message ? ': ' + opt_message : '.'));
	}
};

if (!COMPILED) {
	/**
	 * Check if the given name has been goog.provided. This will return false for
	 * names that are available only as implicit namespaces.
	 * @param {string} name name of the object to look for.
	 * @return {boolean} Whether the name has been provided.
	 * @private
	 */
	goog.isProvided_ = function(name) {
	  return name in goog.loadedModules_ || !goog.implicitNamespaces_[name] && goog.isDefAndNotNull(goog.getObjectByName(name));
	};

	/**
	 * Namespaces implicitly defined by goog.provide. For example,
	 * goog.provide('goog.events.Event') implicitly declares that 'goog' and
	 * 'goog.events' must be namespaces.
	 *
	 * @type {!Object<string, (boolean|undefined)>}
	 * @private
	 */
	goog.implicitNamespaces_ = { 'goog.module': true };

	// NOTE: We add goog.module as an implicit namespace as goog.module is defined
	// here and because the existing module package has not been moved yet out of
	// the goog.module namespace. This satisifies both the debug loader and
	// ahead-of-time dependency management.
}

/**
* Returns an object based on its fully qualified external name.  The object
* is not found if null or undefined.  If you are using a compilation pass that
* renames property names beware that using this function will not find renamed
* properties.
*
* @param {string} name The fully qualified name.
* @param {Object=} opt_obj The object within which to look; default is
*     |goog.global|.
* @return {?} The value (object or primitive) or, if not found, null.
*/
goog.getObjectByName = function(name, opt_obj) {
	var parts = name.split('.');
	var cur = opt_obj || goog.global;
	for (var part; part = parts.shift();) {
	  if (goog.isDefAndNotNull(cur[part])) {
		cur = cur[part];
	  } else {
		return null;
	  }
	}
	return cur;
};

/**
* Globalizes a whole namespace, such as goog or goog.lang.
*
* @param {!Object} obj The namespace to globalize.
* @param {Object=} opt_global The object to add the properties to.
* @deprecated Properties may be explicitly exported to the global scope, but
*     this should no longer be done in bulk.
*/
goog.globalize = function(obj, opt_global) {
	var global = opt_global || goog.global;
	for (var x in obj) {
	  global[x] = obj[x];
	}
};

/**
* Adds a dependency from a file to the files it requires.
* @param {string} relPath The path to the js file.
* @param {!Array<string>} provides An array of strings with
*     the names of the objects this file provides.
* @param {!Array<string>} requires An array of strings with
*     the names of the objects this file requires.
* @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
*     how the file must be loaded.  The boolean 'true' is equivalent
*     to {'module': 'goog'} for backwards-compatibility.  Valid properties
*     and values include {'module': 'goog'} and {'lang': 'es6'}.
*/
goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {
	if (goog.DEPENDENCIES_ENABLED) {
	  var provide, require;
	  var path = relPath.replace(/\\/g, '/');
	  var deps = goog.dependencies_;
	  if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
		opt_loadFlags = opt_loadFlags ? { 'module': 'goog' } : {};
	  }
	  for (var i = 0; provide = provides[i]; i++) {
		deps.nameToPath[provide] = path;
		deps.pathIsModule[path] = opt_loadFlags['module'] == 'goog';
	  }
	  for (var j = 0; require = requires[j]; j++) {
		if (!(path in deps.requires)) {
		  deps.requires[path] = {};
		}
		deps.requires[path][require] = true;
	  }
	}
};

// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
//
// User-defined namespaces may need their own deps file. For a reference on
// creating a deps file, see:
// Externally: https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.

/**
* @define {boolean} Whether to enable the debug loader.
*
* If enabled, a call to goog.require() will attempt to load the namespace by
* appending a script tag to the DOM (if the namespace has been registered).
*
* If disabled, goog.require() will simply assert that the namespace has been
* provided (and depend on the fact that some outside tool correctly ordered
* the script).
*/
goog.define('goog.ENABLE_DEBUG_LOADER', true);

/**
* @param {string} msg
* @private
*/
goog.logToConsole_ = function(msg) {
	if (goog.global.console) {
	  goog.global.console['error'](msg);
	}
};

/**
* Implements a system for the dynamic resolution of dependencies that works in
* parallel with the BUILD system. Note that all calls to goog.require will be
* stripped by the JSCompiler when the --process_closure_primitives option is
* used.
* @see goog.provide
* @param {string} name Namespace to include (as was given in goog.provide()) in
*     the form "goog.package.part".
* @return {?} If called within a goog.module file, the associated namespace or
*     module otherwise null.
*/
goog.require = function(name) {
	// If the object already exists we do not need do do anything.
	if (!COMPILED) {
	  if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
		goog.maybeProcessDeferredDep_(name);
	  }

	  if (goog.isProvided_(name)) {
		if (goog.isInModuleLoader_()) {
		  return goog.module.getInternal_(name);
		} else {
		  return null;
		}
	  }

	  if (goog.ENABLE_DEBUG_LOADER) {
		var path = goog.getPathFromDeps_(name);
		if (path) {
		  goog.writeScripts_(path);
		  return null;
		}
	  }

	  var errorMessage = 'goog.require could not find: ' + name;
	  goog.logToConsole_(errorMessage);

	  throw Error(errorMessage);
	}
};

/**
* Path for included scripts.
* @type {string}
*/
goog.basePath = '';

/**
* A hook for overriding the base path.
* @type {string|undefined}
*/
goog.global.CLOSURE_BASE_PATH;

/**
* Whether to write out Closure's deps file. By default, the deps are written.
* @type {boolean|undefined}
*/
goog.global.CLOSURE_NO_DEPS;

/**
* A function to import a single script. This is meant to be overridden when
* Closure is being run in non-HTML contexts, such as web workers. It's defined
* in the global scope so that it can be set before base.js is loaded, which
* allows deps.js to be imported properly.
*
* The function is passed the script source, which is a relative URI. It should
* return true if the script was imported, false otherwise.
* @type {(function(string): boolean)|undefined}
*/
goog.global.CLOSURE_IMPORT_SCRIPT;

/**
* Null function used for default values of callbacks, etc.
* @return {void} Nothing.
*/
goog.nullFunction = function() {};

/**
* When defining a class Foo with an abstract method bar(), you can do:
* Foo.prototype.bar = goog.abstractMethod
*
* Now if a subclass of Foo fails to override bar(), an error will be thrown
* when bar() is invoked.
*
* Note: This does not take the name of the function to override as an argument
* because that would make it more difficult to obfuscate our JavaScript code.
*
* @type {!Function}
* @throws {Error} when invoked to indicate the method should be overridden.
*/
goog.abstractMethod = function() {
	throw Error('unimplemented abstract method');
};

/**
* Adds a {@code getInstance} static method that always returns the same
* instance object.
* @param {!Function} ctor The constructor for the class to add the static
*     method to.
*/
goog.addSingletonGetter = function(ctor) {
	ctor.getInstance = function() {
	  if (ctor.instance_) {
		return ctor.instance_;
	  }
	  if (goog.DEBUG) {
		// NOTE: JSCompiler can't optimize away Array#push.
		goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
	  }
	  return ctor.instance_ = new ctor();
	};
};

/**
* All singleton classes that have been instantiated, for testing. Don't read
* it directly, use the {@code goog.testing.singleton} module. The compiler
* removes this variable if unused.
* @type {!Array<!Function>}
* @private
*/
goog.instantiatedSingletons_ = [];

/**
* @define {boolean} Whether to load goog.modules using {@code eval} when using
* the debug loader.  This provides a better debugging experience as the
* source is unmodified and can be edited using Chrome Workspaces or similar.
* However in some environments the use of {@code eval} is banned
* so we provide an alternative.
*/
goog.define('goog.LOAD_MODULE_USING_EVAL', true);

/**
* @define {boolean} Whether the exports of goog.modules should be sealed when
* possible.
*/
goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);

/**
* The registry of initialized modules:
* the module identifier to module exports map.
* @private @const {!Object<string, ?>}
*/
goog.loadedModules_ = {};

/**
* True if goog.dependencies_ is available.
* @const {boolean}
*/
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;

if (goog.DEPENDENCIES_ENABLED) {
	/**
	 * This object is used to keep track of dependencies and other data that is
	 * used for loading scripts.
	 * @private
	 * @type {{
	 *   pathIsModule: !Object<string, boolean>,
	 *   nameToPath: !Object<string, string>,
	 *   requires: !Object<string, !Object<string, boolean>>,
	 *   visited: !Object<string, boolean>,
	 *   written: !Object<string, boolean>,
	 *   deferred: !Object<string, string>
	 * }}
	 */
	goog.dependencies_ = {
	  pathIsModule: {}, // 1 to 1

	  nameToPath: {}, // 1 to 1

	  requires: {}, // 1 to many

	  // Used when resolving dependencies to prevent us from visiting file twice.
	  visited: {},

	  written: {}, // Used to keep track of script files we have written.

	  deferred: {} // Used to track deferred module evaluations in old IEs
	};

	/**
	 * Tries to detect whether is in the context of an HTML document.
	 * @return {boolean} True if it looks like HTML document.
	 * @private
	 */
	goog.inHtmlDocument_ = function() {
	  /** @type {Document} */
	  var doc = goog.global.document;
	  return doc != null && 'write' in doc; // XULDocument misses write.
	};

	/**
	 * Tries to detect the base path of base.js script that bootstraps Closure.
	 * @private
	 */
	goog.findBasePath_ = function() {
	  if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {
		goog.basePath = goog.global.CLOSURE_BASE_PATH;
		return;
	  } else if (!goog.inHtmlDocument_()) {
		return;
	  }
	  /** @type {Document} */
	  var doc = goog.global.document;
	  var scripts = doc.getElementsByTagName('SCRIPT');
	  // Search backwards since the current script is in almost all cases the one
	  // that has base.js.
	  for (var i = scripts.length - 1; i >= 0; --i) {
		var script = /** @type {!HTMLScriptElement} */scripts[i];
		var src = script.src;
		var qmark = src.lastIndexOf('?');
		var l = qmark == -1 ? src.length : qmark;
		if (src.substr(l - 7, 7) == 'base.js') {
		  goog.basePath = src.substr(0, l - 7);
		  return;
		}
	  }
	};

	/**
	 * Imports a script if, and only if, that script hasn't already been imported.
	 * (Must be called at execution time)
	 * @param {string} src Script source.
	 * @param {string=} opt_sourceText The optionally source text to evaluate
	 * @private
	 */
	goog.importScript_ = function(src, opt_sourceText) {
	  var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
	  if (importScript(src, opt_sourceText)) {
		goog.dependencies_.written[src] = true;
	  }
	};

	/** @const @private {boolean} */
	goog.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document && goog.global.document.all);

	/**
	 * Given a URL initiate retrieval and execution of the module.
	 * @param {string} src Script source URL.
	 * @private
	 */
	goog.importModule_ = function(src) {
	  // In an attempt to keep browsers from timing out loading scripts using
	  // synchronous XHRs, put each load in its own script block.
	  var bootstrap = 'goog.retrieveAndExecModule_("' + src + '");';

	  if (goog.importScript_('', bootstrap)) {
		goog.dependencies_.written[src] = true;
	  }
	};

	/** @private {!Array<string>} */
	goog.queuedModules_ = [];

	/**
	 * Return an appropriate module text. Suitable to insert into
	 * a script tag (that is unescaped).
	 * @param {string} srcUrl
	 * @param {string} scriptText
	 * @return {string}
	 * @private
	 */
	goog.wrapModule_ = function(srcUrl, scriptText) {
	  if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
		return '' + 'goog.loadModule(function(exports) {' + '"use strict";' + scriptText + '\n' + // terminate any trailing single line comment.
		';return exports' + '});' + '\n//# sourceURL=' + srcUrl + '\n';
	  } else {
		return '' + 'goog.loadModule(' + goog.global.JSON.stringify(scriptText + '\n//# sourceURL=' + srcUrl + '\n') + ');';
	  }
	};

	// On IE9 and earlier, it is necessary to handle
	// deferred module loads. In later browsers, the
	// code to be evaluated is simply inserted as a script
	// block in the correct order. To eval deferred
	// code at the right time, we piggy back on goog.require to call
	// goog.maybeProcessDeferredDep_.
	//
	// The goog.requires are used both to bootstrap
	// the loading process (when no deps are available) and
	// declare that they should be available.
	//
	// Here we eval the sources, if all the deps are available
	// either already eval'd or goog.require'd.  This will
	// be the case when all the dependencies have already
	// been loaded, and the dependent module is loaded.
	//
	// But this alone isn't sufficient because it is also
	// necessary to handle the case where there is no root
	// that is not deferred.  For that there we register for an event
	// and trigger goog.loadQueuedModules_ handle any remaining deferred
	// evaluations.

	/**
	 * Handle any remaining deferred goog.module evals.
	 * @private
	 */
	goog.loadQueuedModules_ = function() {
	  var count = goog.queuedModules_.length;
	  if (count > 0) {
		var queue = goog.queuedModules_;
		goog.queuedModules_ = [];
		for (var i = 0; i < count; i++) {
		  var path = queue[i];
		  goog.maybeProcessDeferredPath_(path);
		}
	  }
	};

	/**
	 * Eval the named module if its dependencies are
	 * available.
	 * @param {string} name The module to load.
	 * @private
	 */
	goog.maybeProcessDeferredDep_ = function(name) {
	  if (goog.isDeferredModule_(name) && goog.allDepsAreAvailable_(name)) {
		var path = goog.getPathFromDeps_(name);
		goog.maybeProcessDeferredPath_(goog.basePath + path);
	  }
	};

	/**
	 * @param {string} name The module to check.
	 * @return {boolean} Whether the name represents a
	 *     module whose evaluation has been deferred.
	 * @private
	 */
	goog.isDeferredModule_ = function(name) {
	  var path = goog.getPathFromDeps_(name);
	  if (path && goog.dependencies_.pathIsModule[path]) {
		var abspath = goog.basePath + path;
		return abspath in goog.dependencies_.deferred;
	  }
	  return false;
	};

	/**
	 * @param {string} name The module to check.
	 * @return {boolean} Whether the name represents a
	 *     module whose declared dependencies have all been loaded
	 *     (eval'd or a deferred module load)
	 * @private
	 */
	goog.allDepsAreAvailable_ = function(name) {
	  var path = goog.getPathFromDeps_(name);
	  if (path && path in goog.dependencies_.requires) {
		for (var requireName in goog.dependencies_.requires[path]) {
		  if (!goog.isProvided_(requireName) && !goog.isDeferredModule_(requireName)) {
			return false;
		  }
		}
	  }
	  return true;
	};

	/**
	 * @param {string} abspath
	 * @private
	 */
	goog.maybeProcessDeferredPath_ = function(abspath) {
	  if (abspath in goog.dependencies_.deferred) {
		var src = goog.dependencies_.deferred[abspath];
		delete goog.dependencies_.deferred[abspath];
		goog.globalEval(src);
	  }
	};

	/**
	 * Load a goog.module from the provided URL.  This is not a general purpose
	 * code loader and does not support late loading code, that is it should only
	 * be used during page load. This method exists to support unit tests and
	 * "debug" loaders that would otherwise have inserted script tags. Under the
	 * hood this needs to use a synchronous XHR and is not recommeneded for
	 * production code.
	 *
	 * The module's goog.requires must have already been satisified; an exception
	 * will be thrown if this is not the case. This assumption is that no
	 * "deps.js" file exists, so there is no way to discover and locate the
	 * module-to-be-loaded's dependencies and no attempt is made to do so.
	 *
	 * There should only be one attempt to load a module.  If
	 * "goog.loadModuleFromUrl" is called for an already loaded module, an
	 * exception will be throw.
	 *
	 * @param {string} url The URL from which to attempt to load the goog.module.
	 */
	goog.loadModuleFromUrl = function(url) {
	  // Because this executes synchronously, we don't need to do any additional
	  // bookkeeping. When "goog.loadModule" the namespace will be marked as
	  // having been provided which is sufficient.
	  goog.retrieveAndExecModule_(url);
	};

	/**
	 * @param {function(?):?|string} moduleDef The module definition.
	 */
	goog.loadModule = function(moduleDef) {
	  // NOTE: we allow function definitions to be either in the from
	  // of a string to eval (which keeps the original source intact) or
	  // in a eval forbidden environment (CSP) we allow a function definition
	  // which in its body must call {@code goog.module}, and return the exports
	  // of the module.
	  var previousState = goog.moduleLoaderState_;
	  try {
		goog.moduleLoaderState_ = {
		  moduleName: undefined,
		  declareLegacyNamespace: false
		};
		var exports;
		if (goog.isFunction(moduleDef)) {
		  exports = moduleDef.call(goog.global, {});
		} else if (goog.isString(moduleDef)) {
		  exports = goog.loadModuleFromSource_.call(goog.global, moduleDef);
		} else {
		  throw Error('Invalid module definition');
		}

		var moduleName = goog.moduleLoaderState_.moduleName;
		if (!goog.isString(moduleName) || !moduleName) {
		  throw Error('Invalid module name \"' + moduleName + '\"');
		}

		// Don't seal legacy namespaces as they may be uses as a parent of
		// another namespace
		if (goog.moduleLoaderState_.declareLegacyNamespace) {
		  goog.constructNamespace_(moduleName, exports);
		} else if (goog.SEAL_MODULE_EXPORTS && Object.seal) {
		  Object.seal(exports);
		}

		goog.loadedModules_[moduleName] = exports;
	  } finally {
		goog.moduleLoaderState_ = previousState;
	  }
	};

	/**
	 * @private @const {function(string):?}
	 *
	 * The new type inference warns because this function has no formal
	 * parameters, but its jsdoc says that it takes one argument.
	 * (The argument is used via arguments[0], but NTI does not detect this.)
	 * @suppress {newCheckTypes}
	 */
	goog.loadModuleFromSource_ = function() {
	  // NOTE: we avoid declaring parameters or local variables here to avoid
	  // masking globals or leaking values into the module definition.
	  'use strict';

	  var exports = {};
	  eval(arguments[0]);
	  return exports;
	};

	/**
	 * Writes a new script pointing to {@code src} directly into the DOM.
	 *
	 * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
	 * the fallback mechanism.
	 *
	 * @param {string} src The script URL.
	 * @private
	 */
	goog.writeScriptSrcNode_ = function(src) {
	  goog.global.document.write('<script type="text/javascript" src="' + src + '"></' + 'script>');
	};

	/**
	 * Appends a new script node to the DOM using a CSP-compliant mechanism. This
	 * method exists as a fallback for document.write (which is not allowed in a
	 * strict CSP context, e.g., Chrome apps).
	 *
	 * NOTE: This method is not analogous to using document.write to insert a
	 * <script> tag; specifically, the user agent will execute a script added by
	 * document.write immediately after the current script block finishes
	 * executing, whereas the DOM-appended script node will not be executed until
	 * the entire document is parsed and executed. That is to say, this script is
	 * added to the end of the script execution queue.
	 *
	 * The page must not attempt to call goog.required entities until after the
	 * document has loaded, e.g., in or after the window.onload callback.
	 *
	 * @param {string} src The script URL.
	 * @private
	 */
	goog.appendScriptSrcNode_ = function(src) {
	  /** @type {Document} */
	  var doc = goog.global.document;
	  var scriptEl =
	  /** @type {HTMLScriptElement} */doc.createElement('script');
	  scriptEl.type = 'text/javascript';
	  scriptEl.src = src;
	  scriptEl.defer = false;
	  scriptEl.async = false;
	  doc.head.appendChild(scriptEl);
	};

	/**
	 * The default implementation of the import function. Writes a script tag to
	 * import the script.
	 *
	 * @param {string} src The script url.
	 * @param {string=} opt_sourceText The optionally source text to evaluate
	 * @return {boolean} True if the script was imported, false otherwise.
	 * @private
	 */
	goog.writeScriptTag_ = function(src, opt_sourceText) {
	  if (goog.inHtmlDocument_()) {
		/** @type {!HTMLDocument} */
		var doc = goog.global.document;

		// If the user tries to require a new symbol after document load,
		// something has gone terribly wrong. Doing a document.write would
		// wipe out the page. This does not apply to the CSP-compliant method
		// of writing script tags.
		if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && doc.readyState == 'complete') {
		  // Certain test frameworks load base.js multiple times, which tries
		  // to write deps.js each time. If that happens, just fail silently.
		  // These frameworks wipe the page between each load of base.js, so this
		  // is OK.
		  var isDeps = /\bdeps.js$/.test(src);
		  if (isDeps) {
			return false;
		  } else {
			throw Error('Cannot write "' + src + '" after document load');
		  }
		}

		var isOldIE = goog.IS_OLD_IE_;

		if (opt_sourceText === undefined) {
		  if (!isOldIE) {
			if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
			  goog.appendScriptSrcNode_(src);
			} else {
			  goog.writeScriptSrcNode_(src);
			}
		  } else {
			var state = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ";
			doc.write('<script type="text/javascript" src="' + src + '"' + state + '></' + 'script>');
		  }
		} else {
		  doc.write('<script type="text/javascript">' + opt_sourceText + '</' + 'script>');
		}
		return true;
	  } else {
		return false;
	  }
	};

	/** @private {number} */
	goog.lastNonModuleScriptIndex_ = 0;

	/**
	 * A readystatechange handler for legacy IE
	 * @param {!HTMLScriptElement} script
	 * @param {number} scriptIndex
	 * @return {boolean}
	 * @private
	 */
	goog.onScriptLoad_ = function(script, scriptIndex) {
	  // for now load the modules when we reach the last script,
	  // later allow more inter-mingling.
	  if (script.readyState == 'complete' && goog.lastNonModuleScriptIndex_ == scriptIndex) {
		goog.loadQueuedModules_();
	  }
	  return true;
	};

	/**
	 * Resolves dependencies based on the dependencies added using addDependency
	 * and calls importScript_ in the correct order.
	 * @param {string} pathToLoad The path from which to start discovering
	 *     dependencies.
	 * @private
	 */
	goog.writeScripts_ = function(pathToLoad) {
	  /** @type {!Array<string>} The scripts we need to write this time. */
	  var scripts = [];
	  var seenScript = {};
	  var deps = goog.dependencies_;

	  /** @param {string} path */
	  function visitNode(path) {
		if (path in deps.written) {
		  return;
		}

		// We have already visited this one. We can get here if we have cyclic
		// dependencies.
		if (path in deps.visited) {
		  return;
		}

		deps.visited[path] = true;

		if (path in deps.requires) {
		  for (var requireName in deps.requires[path]) {
			// If the required name is defined, we assume that it was already
			// bootstrapped by other means.
			if (!goog.isProvided_(requireName)) {
			  if (requireName in deps.nameToPath) {
				visitNode(deps.nameToPath[requireName]);
			  } else {
				throw Error('Undefined nameToPath for ' + requireName);
			  }
			}
		  }
		}

		if (!(path in seenScript)) {
		  seenScript[path] = true;
		  scripts.push(path);
		}
	  }

	  visitNode(pathToLoad);

	  // record that we are going to load all these scripts.
	  for (var i = 0; i < scripts.length; i++) {
		var path = scripts[i];
		goog.dependencies_.written[path] = true;
	  }

	  // If a module is loaded synchronously then we need to
	  // clear the current inModuleLoader value, and restore it when we are
	  // done loading the current "requires".
	  var moduleState = goog.moduleLoaderState_;
	  goog.moduleLoaderState_ = null;

	  for (var i = 0; i < scripts.length; i++) {
		var path = scripts[i];
		if (path) {
		  if (!deps.pathIsModule[path]) {
			goog.importScript_(goog.basePath + path);
		  } else {
			goog.importModule_(goog.basePath + path);
		  }
		} else {
		  goog.moduleLoaderState_ = moduleState;
		  throw Error('Undefined script input');
		}
	  }

	  // restore the current "module loading state"
	  goog.moduleLoaderState_ = moduleState;
	};

	/**
	 * Looks at the dependency rules and tries to determine the script file that
	 * fulfills a particular rule.
	 * @param {string} rule In the form goog.namespace.Class or project.script.
	 * @return {?string} Url corresponding to the rule, or null.
	 * @private
	 */
	goog.getPathFromDeps_ = function(rule) {
	  if (rule in goog.dependencies_.nameToPath) {
		return goog.dependencies_.nameToPath[rule];
	  } else {
		return null;
	  }
	};

	goog.findBasePath_();

	// Allow projects to manage the deps files themselves.
	if (!goog.global.CLOSURE_NO_DEPS) {
	  goog.importScript_(goog.basePath + 'deps.js');
	}
}

/**
* Normalize a file path by removing redundant ".." and extraneous "." file
* path components.
* @param {string} path
* @return {string}
* @private
*/
goog.normalizePath_ = function(path) {
	var components = path.split('/');
	var i = 0;
	while (i < components.length) {
	  if (components[i] == '.') {
		components.splice(i, 1);
	  } else if (i && components[i] == '..' && components[i - 1] && components[i - 1] != '..') {
		components.splice(--i, 2);
	  } else {
		i++;
	  }
	}
	return components.join('/');
};

/**
* Loads file by synchronous XHR. Should not be used in production environments.
* @param {string} src Source URL.
* @return {string} File contents.
* @private
*/
goog.loadFileSync_ = function(src) {
	if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
	  return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
	} else {
	  /** @type {XMLHttpRequest} */
	  var xhr = new goog.global['XMLHttpRequest']();
	  xhr.open('get', src, false);
	  xhr.send();
	  return xhr.responseText;
	}
};

/**
* Retrieve and execute a module.
* @param {string} src Script source URL.
* @private
*/
goog.retrieveAndExecModule_ = function(src) {
	if (!COMPILED) {
	  // The full but non-canonicalized URL for later use.
	  var originalPath = src;
	  // Canonicalize the path, removing any /./ or /../ since Chrome's debugging
	  // console doesn't auto-canonicalize XHR loads as it does <script> srcs.
	  src = goog.normalizePath_(src);

	  var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;

	  var scriptText = goog.loadFileSync_(src);

	  if (scriptText != null) {
		var execModuleScript = goog.wrapModule_(src, scriptText);
		var isOldIE = goog.IS_OLD_IE_;
		if (isOldIE) {
		  goog.dependencies_.deferred[originalPath] = execModuleScript;
		  goog.queuedModules_.push(originalPath);
		} else {
		  importScript(src, execModuleScript);
		}
	  } else {
		throw new Error('load of ' + src + 'failed');
	  }
	}
};

//==============================================================================
// Language Enhancements
//==============================================================================

/**
* This is a "fixed" version of the typeof operator.  It differs from the typeof
* operator in such a way that null returns 'null' and arrays return 'array'.
* @param {?} value The value to get the type of.
* @return {string} The name of the type.
*/
goog.typeOf = function(value) {
	var s = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	if (s == 'object') {
	  if (value) {
		// Check these first, so we can avoid calling Object.prototype.toString if
		// possible.
		//
		// IE improperly marshals typeof across execution contexts, but a
		// cross-context object will still return false for "instanceof Object".
		if (value instanceof Array) {
		  return 'array';
		} else if (value instanceof Object) {
		  return s;
		}

		// HACK: In order to use an Object prototype method on the arbitrary
		//   value, the compiler requires the value be cast to type Object,
		//   even though the ECMA spec explicitly allows it.
		var className = Object.prototype.toString.call(
		/** @type {!Object} */value);
		// In Firefox 3.6, attempting to access iframe window objects' length
		// property throws an NS_ERROR_FAILURE, so we need to special-case it
		// here.
		if (className == '[object Window]') {
		  return 'object';
		}

		// We cannot always use constructor == Array or instanceof Array because
		// different frames have different Array objects. In IE6, if the iframe
		// where the array was created is destroyed, the array loses its
		// prototype. Then dereferencing val.splice here throws an exception, so
		// we can't use goog.isFunction. Calling typeof directly returns 'unknown'
		// so that will work. In this case, this function will return false and
		// most array functions will still work because the array is still
		// array-like (supports length and []) even though it has lost its
		// prototype.
		// Mark Miller noticed that Object.prototype.toString
		// allows access to the unforgeable [[Class]] property.
		//  15.2.4.2 Object.prototype.toString ( )
		//  When the toString method is called, the following steps are taken:
		//      1. Get the [[Class]] property of this object.
		//      2. Compute a string value by concatenating the three strings
		//         "[object ", Result(1), and "]".
		//      3. Return Result(2).
		// and this behavior survives the destruction of the execution context.
		if (className == '[object Array]' ||
		// In IE all non value types are wrapped as objects across window
		// boundaries (not iframe though) so we have to do object detection
		// for this edge case.
		typeof value.length == 'number' && typeof value.splice != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')) {
		  return 'array';
		}
		// HACK: There is still an array case that fails.
		//     function ArrayImpostor() {}
		//     ArrayImpostor.prototype = [];
		//     var impostor = new ArrayImpostor;
		// this can be fixed by getting rid of the fast path
		// (value instanceof Array) and solely relying on
		// (value && Object.prototype.toString.vall(value) === '[object Array]')
		// but that would require many more function calls and is not warranted
		// unless closure code is receiving objects from untrusted sources.

		// IE in cross-window calls does not correctly marshal the function type
		// (it appears just as an object) so we cannot use just typeof val ==
		// 'function'. However, if the object has a call property, it is a
		// function.
		if (className == '[object Function]' || typeof value.call != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('call')) {
		  return 'function';
		}
	  } else {
		return 'null';
	  }
	} else if (s == 'function' && typeof value.call == 'undefined') {
	  // In Safari typeof nodeList returns 'function', and on Firefox typeof
	  // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
	  // would like to return object for those and we can detect an invalid
	  // function by making sure that the function object has a call method.
	  return 'object';
	}
	return s;
};

/**
* Returns true if the specified value is null.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is null.
*/
goog.isNull = function(val) {
	return val === null;
};

/**
* Returns true if the specified value is defined and not null.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is defined and not null.
*/
goog.isDefAndNotNull = function(val) {
	// Note that undefined == null.
	return val != null;
};

/**
* Returns true if the specified value is an array.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is an array.
*/
goog.isArray = function(val) {
	return goog.typeOf(val) == 'array';
};

/**
* Returns true if the object looks like an array. To qualify as array like
* the value needs to be either a NodeList or an object with a Number length
* property. As a special case, a function value is not array like, because its
* length property is fixed to correspond to the number of expected arguments.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is an array.
*/
goog.isArrayLike = function(val) {
	var type = goog.typeOf(val);
	// We do not use goog.isObject here in order to exclude function values.
	return type == 'array' || type == 'object' && typeof val.length == 'number';
};

/**
* Returns true if the object looks like a Date. To qualify as Date-like the
* value needs to be an object and have a getFullYear() function.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is a like a Date.
*/
goog.isDateLike = function(val) {
	return goog.isObject(val) && typeof val.getFullYear == 'function';
};

/**
* Returns true if the specified value is a string.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is a string.
*/
goog.isString = function(val) {
	return typeof val == 'string';
};

/**
* Returns true if the specified value is a boolean.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is boolean.
*/
goog.isBoolean = function(val) {
	return typeof val == 'boolean';
};

/**
* Returns true if the specified value is a number.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is a number.
*/
goog.isNumber = function(val) {
	return typeof val == 'number';
};

/**
* Returns true if the specified value is a function.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is a function.
*/
goog.isFunction = function(val) {
	return goog.typeOf(val) == 'function';
};

/**
* Returns true if the specified value is an object.  This includes arrays and
* functions.
* @param {?} val Variable to test.
* @return {boolean} Whether variable is an object.
*/
goog.isObject = function(val) {
	var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	return type == 'object' && val != null || type == 'function';
	// return Object(val) === val also works, but is slower, especially if val is
	// not an object.
};

/**
* Gets a unique ID for an object. This mutates the object so that further calls
* with the same object as a parameter returns the same value. The unique ID is
* guaranteed to be unique across the current session amongst objects that are
* passed into {@code getUid}. There is no guarantee that the ID is unique or
* consistent across sessions. It is unsafe to generate unique ID for function
* prototypes.
*
* @param {Object} obj The object to get the unique ID for.
* @return {number} The unique ID for the object.
*/
goog.getUid = function(obj) {
	// TODO(arv): Make the type stricter, do not accept null.

	// In Opera window.hasOwnProperty exists but always returns false so we avoid
	// using it. As a consequence the unique ID generated for BaseClass.prototype
	// and SubClass.prototype will be the same.
	return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};

/**
* Whether the given object is already assigned a unique ID.
*
* This does not modify the object.
*
* @param {!Object} obj The object to check.
* @return {boolean} Whether there is an assigned unique id for the object.
*/
goog.hasUid = function(obj) {
	return !!obj[goog.UID_PROPERTY_];
};

/**
* Removes the unique ID from an object. This is useful if the object was
* previously mutated using {@code goog.getUid} in which case the mutation is
* undone.
* @param {Object} obj The object to remove the unique ID field from.
*/
goog.removeUid = function(obj) {
	// TODO(arv): Make the type stricter, do not accept null.

	// In IE, DOM nodes are not instances of Object and throw an exception if we
	// try to delete.  Instead we try to use removeAttribute.
	if (obj !== null && 'removeAttribute' in obj) {
	  obj.removeAttribute(goog.UID_PROPERTY_);
	}
	/** @preserveTry */
	try {
	  delete obj[goog.UID_PROPERTY_];
	} catch (ex) {}
};

/**
* Name for unique ID property. Initialized in a way to help avoid collisions
* with other closure JavaScript on the same page.
* @type {string}
* @private
*/
goog.UID_PROPERTY_ = 'closure_uid_' + (Math.random() * 1e9 >>> 0);

/**
* Counter for UID.
* @type {number}
* @private
*/
goog.uidCounter_ = 0;

/**
* Adds a hash code field to an object. The hash code is unique for the
* given object.
* @param {Object} obj The object to get the hash code for.
* @return {number} The hash code for the object.
* @deprecated Use goog.getUid instead.
*/
goog.getHashCode = goog.getUid;

/**
* Removes the hash code field from an object.
* @param {Object} obj The object to remove the field from.
* @deprecated Use goog.removeUid instead.
*/
goog.removeHashCode = goog.removeUid;

/**
* Clones a value. The input may be an Object, Array, or basic type. Objects and
* arrays will be cloned recursively.
*
* WARNINGS:
* <code>goog.cloneObject</code> does not detect reference loops. Objects that
* refer to themselves will cause infinite recursion.
*
* <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
* UIDs created by <code>getUid</code> into cloned results.
*
* @param {*} obj The value to clone.
* @return {*} A clone of the input value.
* @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
*/
goog.cloneObject = function(obj) {
	var type = goog.typeOf(obj);
	if (type == 'object' || type == 'array') {
	  if (obj.clone) {
		return obj.clone();
	  }
	  var clone = type == 'array' ? [] : {};
	  for (var key in obj) {
		clone[key] = goog.cloneObject(obj[key]);
	  }
	  return clone;
	}

	return obj;
};

/**
* A native implementation of goog.bind.
* @param {Function} fn A function to partially apply.
* @param {Object|undefined} selfObj Specifies the object which this should
*     point to when the function is run.
* @param {...*} var_args Additional arguments that are partially applied to the
*     function.
* @return {!Function} A partially-applied form of the function bind() was
*     invoked as a method of.
* @private
* @suppress {deprecated} The compiler thinks that Function.prototype.bind is
*     deprecated because some people have declared a pure-JS version.
*     Only the pure-JS version is truly deprecated.
*/
goog.bindNative_ = function(fn, selfObj, var_args) {
	return (/** @type {!Function} */fn.call.apply(fn.bind, arguments)
	);
};

/**
* A pure-JS implementation of goog.bind.
* @param {Function} fn A function to partially apply.
* @param {Object|undefined} selfObj Specifies the object which this should
*     point to when the function is run.
* @param {...*} var_args Additional arguments that are partially applied to the
*     function.
* @return {!Function} A partially-applied form of the function bind() was
*     invoked as a method of.
* @private
*/
goog.bindJs_ = function(fn, selfObj, var_args) {
	if (!fn) {
	  throw new Error();
	}

	if (arguments.length > 2) {
	  var boundArgs = Array.prototype.slice.call(arguments, 2);
	  return function() {
		// Prepend the bound arguments to the current arguments.
		var newArgs = Array.prototype.slice.call(arguments);
		Array.prototype.unshift.apply(newArgs, boundArgs);
		return fn.apply(selfObj, newArgs);
	  };
	} else {
	  return function() {
		return fn.apply(selfObj, arguments);
	  };
	}
};

/**
* Partially applies this function to a particular 'this object' and zero or
* more arguments. The result is a new function with some arguments of the first
* function pre-filled and the value of this 'pre-specified'.
*
* Remaining arguments specified at call-time are appended to the pre-specified
* ones.
*
* Also see: {@link #partial}.
*
* Usage:
* <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
* barMethBound('arg3', 'arg4');</pre>
*
* @param {?function(this:T, ...)} fn A function to partially apply.
* @param {T} selfObj Specifies the object which this should point to when the
*     function is run.
* @param {...*} var_args Additional arguments that are partially applied to the
*     function.
* @return {!Function} A partially-applied form of the function goog.bind() was
*     invoked as a method of.
* @template T
* @suppress {deprecated} See above.
*/
goog.bind = function(fn, selfObj, var_args) {
	// TODO(nicksantos): narrow the type signature.
	if (Function.prototype.bind &&
	// NOTE(nicksantos): Somebody pulled base.js into the default Chrome
	// extension environment. This means that for Chrome extensions, they get
	// the implementation of Function.prototype.bind that calls goog.bind
	// instead of the native one. Even worse, we don't want to introduce a
	// circular dependency between goog.bind and Function.prototype.bind, so
	// we have to hack this to make sure it works correctly.
	Function.prototype.bind.toString().indexOf('native code') != -1) {
	  goog.bind = goog.bindNative_;
	} else {
	  goog.bind = goog.bindJs_;
	}
	return goog.bind.apply(null, arguments);
};

/**
* Like goog.bind(), except that a 'this object' is not required. Useful when
* the target function is already bound.
*
* Usage:
* var g = goog.partial(f, arg1, arg2);
* g(arg3, arg4);
*
* @param {Function} fn A function to partially apply.
* @param {...*} var_args Additional arguments that are partially applied to fn.
* @return {!Function} A partially-applied form of the function goog.partial()
*     was invoked as a method of.
*/
goog.partial = function(fn, var_args) {
	var args = Array.prototype.slice.call(arguments, 1);
	return function() {
	  // Clone the array (with slice()) and append additional arguments
	  // to the existing arguments.
	  var newArgs = args.slice();
	  newArgs.push.apply(newArgs, arguments);
	  return fn.apply(this, newArgs);
	};
};

/**
* Copies all the members of a source object to a target object. This method
* does not work on all browsers for all objects that contain keys such as
* toString or hasOwnProperty. Use goog.object.extend for this purpose.
* @param {Object} target Target.
* @param {Object} source Source.
*/
goog.mixin = function(target, source) {
	for (var x in source) {
	  target[x] = source[x];
	}

	// For IE7 or lower, the for-in-loop does not contain any properties that are
	// not enumerable on the prototype object (for example, isPrototypeOf from
	// Object.prototype) but also it will not include 'replace' on objects that
	// extend String and change 'replace' (not that it is common for anyone to
	// extend anything except Object).
};

/**
* @return {number} An integer value representing the number of milliseconds
*     between midnight, January 1, 1970 and the current time.
*/
goog.now = goog.TRUSTED_SITE && Date.now || function() {
	// Unary plus operator converts its operand to a number which in
	// the case of
	// a date is done by calling getTime().
	return +new Date();
};

/**
* Evals JavaScript in the global scope.  In IE this uses execScript, other
* browsers use goog.global.eval. If goog.global.eval does not evaluate in the
* global scope (for example, in Safari), appends a script tag instead.
* Throws an exception if neither execScript or eval is defined.
* @param {string} script JavaScript string.
*/
goog.globalEval = function(script) {
	if (goog.global.execScript) {
	  goog.global.execScript(script, 'JavaScript');
	} else if (goog.global.eval) {
	  // Test to see if eval works
	  if (goog.evalWorksForGlobals_ == null) {
		goog.global.eval('var _evalTest_ = 1;');
		if (typeof goog.global['_evalTest_'] != 'undefined') {
		  try {
			delete goog.global['_evalTest_'];
		  } catch (ignore) {
			// Microsoft edge fails the deletion above in strict mode.
		  }
		  goog.evalWorksForGlobals_ = true;
		} else {
		  goog.evalWorksForGlobals_ = false;
		}
	  }

	  if (goog.evalWorksForGlobals_) {
		goog.global.eval(script);
	  } else {
		/** @type {Document} */
		var doc = goog.global.document;
		var scriptElt =
		/** @type {!HTMLScriptElement} */doc.createElement('SCRIPT');
		scriptElt.type = 'text/javascript';
		scriptElt.defer = false;
		// Note(user): can't use .innerHTML since "t('<test>')" will fail and
		// .text doesn't work in Safari 2.  Therefore we append a text node.
		scriptElt.appendChild(doc.createTextNode(script));
		doc.body.appendChild(scriptElt);
		doc.body.removeChild(scriptElt);
	  }
	} else {
	  throw Error('goog.globalEval not available');
	}
};

/**
* Indicates whether or not we can call 'eval' directly to eval code in the
* global scope. Set to a Boolean by the first call to goog.globalEval (which
* empirically tests whether eval works for globals). @see goog.globalEval
* @type {?boolean}
* @private
*/
goog.evalWorksForGlobals_ = null;

/**
* Optional map of CSS class names to obfuscated names used with
* goog.getCssName().
* @private {!Object<string, string>|undefined}
* @see goog.setCssNameMapping
*/
goog.cssNameMapping_;

/**
* Optional obfuscation style for CSS class names. Should be set to either
* 'BY_WHOLE' or 'BY_PART' if defined.
* @type {string|undefined}
* @private
* @see goog.setCssNameMapping
*/
goog.cssNameMappingStyle_;

/**
* Handles strings that are intended to be used as CSS class names.
*
* This function works in tandem with @see goog.setCssNameMapping.
*
* Without any mapping set, the arguments are simple joined with a hyphen and
* passed through unaltered.
*
* When there is a mapping, there are two possible styles in which these
* mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
* of the passed in css name is rewritten according to the map. In the BY_WHOLE
* style, the full css name is looked up in the map directly. If a rewrite is
* not specified by the map, the compiler will output a warning.
*
* When the mapping is passed to the compiler, it will replace calls to
* goog.getCssName with the strings from the mapping, e.g.
*     var x = goog.getCssName('foo');
*     var y = goog.getCssName(this.baseClass, 'active');
*  becomes:
*     var x = 'foo';
*     var y = this.baseClass + '-active';
*
* If one argument is passed it will be processed, if two are passed only the
* modifier will be processed, as it is assumed the first argument was generated
* as a result of calling goog.getCssName.
*
* @param {string} className The class name.
* @param {string=} opt_modifier A modifier to be appended to the class name.
* @return {string} The class name or the concatenation of the class name and
*     the modifier.
*/
goog.getCssName = function(className, opt_modifier) {
	var getMapping = function getMapping(cssName) {
	  return goog.cssNameMapping_[cssName] || cssName;
	};

	var renameByParts = function renameByParts(cssName) {
	  // Remap all the parts individually.
	  var parts = cssName.split('-');
	  var mapped = [];
	  for (var i = 0; i < parts.length; i++) {
		mapped.push(getMapping(parts[i]));
	  }
	  return mapped.join('-');
	};

	var rename;
	if (goog.cssNameMapping_) {
	  rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
	} else {
	  rename = function rename(a) {
		return a;
	  };
	}

	if (opt_modifier) {
	  return className + '-' + rename(opt_modifier);
	} else {
	  return rename(className);
	}
};

/**
* Sets the map to check when returning a value from goog.getCssName(). Example:
* <pre>
* goog.setCssNameMapping({
*   "goog": "a",
*   "disabled": "b",
* });
*
* var x = goog.getCssName('goog');
* // The following evaluates to: "a a-b".
* goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
* </pre>
* When declared as a map of string literals to string literals, the JSCompiler
* will replace all calls to goog.getCssName() using the supplied map if the
* --process_closure_primitives flag is set.
*
* @param {!Object} mapping A map of strings to strings where keys are possible
*     arguments to goog.getCssName() and values are the corresponding values
*     that should be returned.
* @param {string=} opt_style The style of css name mapping. There are two valid
*     options: 'BY_PART', and 'BY_WHOLE'.
* @see goog.getCssName for a description.
*/
goog.setCssNameMapping = function(mapping, opt_style) {
	goog.cssNameMapping_ = mapping;
	goog.cssNameMappingStyle_ = opt_style;
};

/**
* To use CSS renaming in compiled mode, one of the input files should have a
* call to goog.setCssNameMapping() with an object literal that the JSCompiler
* can extract and use to replace all calls to goog.getCssName(). In uncompiled
* mode, JavaScript code should be loaded before this base.js file that declares
* a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
* to ensure that the mapping is loaded before any calls to goog.getCssName()
* are made in uncompiled mode.
*
* A hook for overriding the CSS name mapping.
* @type {!Object<string, string>|undefined}
*/
goog.global.CLOSURE_CSS_NAME_MAPPING;

if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
	// This does not call goog.setCssNameMapping() because the JSCompiler
	// requires that goog.setCssNameMapping() be called with an object literal.
	goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}

/**
* Gets a localized message.
*
* This function is a compiler primitive. If you give the compiler a localized
* message bundle, it will replace the string at compile-time with a localized
* version, and expand goog.getMsg call to a concatenated string.
*
* Messages must be initialized in the form:
* <code>
* var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
* </code>
*
* @param {string} str Translatable string, places holders in the form {$foo}.
* @param {Object<string, string>=} opt_values Maps place holder name to value.
* @return {string} message with placeholders filled.
*/
goog.getMsg = function(str, opt_values) {
	if (opt_values) {
	  str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
		return opt_values != null && key in opt_values ? opt_values[key] : match;
	  });
	}
	return str;
};

/**
* Gets a localized message. If the message does not have a translation, gives a
* fallback message.
*
* This is useful when introducing a new message that has not yet been
* translated into all languages.
*
* This function is a compiler primitive. Must be used in the form:
* <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
* where MSG_A and MSG_B were initialized with goog.getMsg.
*
* @param {string} a The preferred message.
* @param {string} b The fallback message.
* @return {string} The best translated message.
*/
goog.getMsgWithFallback = function(a, b) {
	return a;
};

/**
* Exposes an unobfuscated global namespace path for the given object.
* Note that fields of the exported object *will* be obfuscated, unless they are
* exported in turn via this function or goog.exportProperty.
*
* Also handy for making public items that are defined in anonymous closures.
*
* ex. goog.exportSymbol('public.path.Foo', Foo);
*
* ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
*     public.path.Foo.staticFunction();
*
* ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
*                       Foo.prototype.myMethod);
*     new public.path.Foo().myMethod();
*
* @param {string} publicPath Unobfuscated name to export.
* @param {*} object Object the name should point to.
* @param {Object=} opt_objectToExportTo The object to add the path to; default
*     is goog.global.
*/
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
	goog.exportPath_(publicPath, object, opt_objectToExportTo);
};

/**
* Exports a property unobfuscated into the object's namespace.
* ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
* ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
* @param {Object} object Object whose static property is being exported.
* @param {string} publicName Unobfuscated name to export.
* @param {*} symbol Object the name should point to.
*/
goog.exportProperty = function(object, publicName, symbol) {
	object[publicName] = symbol;
};

/**
* Inherit the prototype methods from one constructor into another.
*
* Usage:
* <pre>
* function ParentClass(a, b) { }
* ParentClass.prototype.foo = function(a) { };
*
* function ChildClass(a, b, c) {
*   ChildClass.base(this, 'constructor', a, b);
* }
* goog.inherits(ChildClass, ParentClass);
*
* var child = new ChildClass('a', 'b', 'see');
* child.foo(); // This works.
* </pre>
*
* @param {!Function} childCtor Child class.
* @param {!Function} parentCtor Parent class.
*/
goog.inherits = function(childCtor, parentCtor) {
	/** @constructor */
	function tempCtor() {}
	tempCtor.prototype = parentCtor.prototype;
	childCtor.superClass_ = parentCtor.prototype;
	childCtor.prototype = new tempCtor();
	/** @override */
	childCtor.prototype.constructor = childCtor;

	/**
	 * Calls superclass constructor/method.
	 *
	 * This function is only available if you use goog.inherits to
	 * express inheritance relationships between classes.
	 *
	 * NOTE: This is a replacement for goog.base and for superClass_
	 * property defined in childCtor.
	 *
	 * @param {!Object} me Should always be "this".
	 * @param {string} methodName The method name to call. Calling
	 *     superclass constructor can be done with the special string
	 *     'constructor'.
	 * @param {...*} var_args The arguments to pass to superclass
	 *     method/constructor.
	 * @return {*} The return value of the superclass method/constructor.
	 */
	childCtor.base = function(me, methodName, var_args) {
	  // Copying using loop to avoid deop due to passing arguments object to
	  // function. This is faster in many JS engines as of late 2014.
	  var args = new Array(arguments.length - 2);
	  for (var i = 2; i < arguments.length; i++) {
		args[i - 2] = arguments[i];
	  }
	  return parentCtor.prototype[methodName].apply(me, args);
	};
};

/**
* Call up to the superclass.
*
* If this is called from a constructor, then this calls the superclass
* constructor with arguments 1-N.
*
* If this is called from a prototype method, then you must pass the name of the
* method as the second argument to this function. If you do not, you will get a
* runtime error. This calls the superclass' method with arguments 2-N.
*
* This function only works if you use goog.inherits to express inheritance
* relationships between your classes.
*
* This function is a compiler primitive. At compile-time, the compiler will do
* macro expansion to remove a lot of the extra overhead that this function
* introduces. The compiler will also enforce a lot of the assumptions that this
* function makes, and treat it as a compiler error if you break them.
*
* @param {!Object} me Should always be "this".
* @param {*=} opt_methodName The method name if calling a super method.
* @param {...*} var_args The rest of the arguments.
* @return {*} The return value of the superclass method.
* @suppress {es5Strict} This method can not be used in strict mode, but
*     all Closure Library consumers must depend on this file.
*/
goog.base = function(me, opt_methodName, var_args) {
	var caller = arguments.callee.caller;

	if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !caller) {
	  throw Error('arguments.caller not defined.  goog.base() cannot be used ' + 'with strict mode code. See ' + 'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
	}

	if (caller.superClass_) {
	  // Copying using loop to avoid deop due to passing arguments object to
	  // function. This is faster in many JS engines as of late 2014.
	  var ctorArgs = new Array(arguments.length - 1);
	  for (var i = 1; i < arguments.length; i++) {
		ctorArgs[i - 1] = arguments[i];
	  }
	  // This is a constructor. Call the superclass constructor.
	  return caller.superClass_.constructor.apply(me, ctorArgs);
	}

	// Copying using loop to avoid deop due to passing arguments object to
	// function. This is faster in many JS engines as of late 2014.
	var args = new Array(arguments.length - 2);
	for (var i = 2; i < arguments.length; i++) {
	  args[i - 2] = arguments[i];
	}
	var foundCaller = false;
	for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
	  if (ctor.prototype[opt_methodName] === caller) {
		foundCaller = true;
	  } else if (foundCaller) {
		return ctor.prototype[opt_methodName].apply(me, args);
	  }
	}

	// If we did not find the caller in the prototype chain, then one of two
	// things happened:
	// 1) The caller is an instance method.
	// 2) This method was not called by the right caller.
	if (me[opt_methodName] === caller) {
	  return me.constructor.prototype[opt_methodName].apply(me, args);
	} else {
	  throw Error('goog.base called from a method of one name ' + 'to a method of a different name');
	}
};

/**
* Allow for aliasing within scope functions.  This function exists for
* uncompiled code - in compiled code the calls will be inlined and the aliases
* applied.  In uncompiled code the function is simply run since the aliases as
* written are valid JavaScript.
*
*
* @param {function()} fn Function to call.  This function can contain aliases
*     to namespaces (e.g. "var dom = goog.dom") or classes
*     (e.g. "var Timer = goog.Timer").
*/
goog.scope = function(fn) {
	fn.call(goog.global);
};

/*
* To support uncompiled, strict mode bundles that use eval to divide source
* like so:
*    eval('someSource;//# sourceUrl sourcefile.js');
* We need to export the globally defined symbols "goog" and "COMPILED".
* Exporting "goog" breaks the compiler optimizations, so we required that
* be defined externally.
* NOTE: We don't use goog.exportSymbol here because we don't want to trigger
* extern generation when that compiler option is enabled.
*/
if (!COMPILED) {
	goog.global['COMPILED'] = COMPILED;
}

goog.provide('goog.string');

/**
* Does simple python-style string substitution.
* subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
* @param {string} str The string containing the pattern.
* @param {...*} var_args The items to substitute into the pattern.
* @return {string} A copy of {@code str} in which each occurrence of
*     {@code %s} has been replaced an argument from {@code var_args}.
*/
goog.string.subs = function(str, var_args) {
	var splitParts = str.split('%s');
	var returnString = '';

	var subsArguments = Array.prototype.slice.call(arguments, 1);
	while (subsArguments.length &&
	// Replace up to the last split part. We are inserting in the
	// positions between split parts.
	splitParts.length > 1) {
	  returnString += splitParts.shift() + subsArguments.shift();
	}

	return returnString + splitParts.join('%s'); // Join unused '%s'
};

/**
* Regular expression that matches an ampersand, for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.AMP_RE_ = /&/g;

/**
* Regular expression that matches a less than sign, for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.LT_RE_ = /</g;

/**
* Regular expression that matches a greater than sign, for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.GT_RE_ = />/g;

/**
* Regular expression that matches a double quote, for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.QUOT_RE_ = /"/g;

/**
* Regular expression that matches a single quote, for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.SINGLE_QUOTE_RE_ = /'/g;

/**
* Regular expression that matches null character, for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.NULL_RE_ = /\x00/g;

/**
* Regular expression that matches a lowercase letter "e", for use in escaping.
* @const {!RegExp}
* @private
*/
goog.string.E_RE_ = /e/g;

/**
* Regular expression that matches any character that needs to be escaped.
* @const {!RegExp}
* @private
*/
goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/;

/**
* Unescapes an HTML string.
*
* @param {string} str The string to unescape.
* @return {string} An unescaped copy of {@code str}.
*/
goog.string.unescapeEntities = function(str) {
	if (goog.string.contains(str, '&')) {
	  // We are careful not to use a DOM if we do not have one or we explicitly
	  // requested non-DOM html unescaping.
	  if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING && 'document' in goog.global) {
		return goog.string.unescapeEntitiesUsingDom_(str);
	  } else {
		// Fall back on pure XML entities
		return goog.string.unescapePureXmlEntities_(str);
	  }
	}
	return str;
};

/**
* Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
* entities. This function is XSS-safe and whitespace-preserving.
* @private
* @param {string} str The string to unescape.
* @param {Document=} opt_document An optional document to use for creating
*     elements. If this is not specified then the default window.document
*     will be used.
* @return {string} The unescaped {@code str} string.
*/
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
	/** @type {!Object<string, string>} */
	var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
	var div;
	if (opt_document) {
	  div = opt_document.createElement('div');
	} else {
	  div = goog.global.document.createElement('div');
	}
	// Match as many valid entity characters as possible. If the actual entity
	// happens to be shorter, it will still work as innerHTML will return the
	// trailing characters unchanged. Since the entity characters do not include
	// open angle bracket, there is no chance of XSS from the innerHTML use.
	// Since no whitespace is passed to innerHTML, whitespace is preserved.
	return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
	  // Check for cached entity.
	  var value = seen[s];
	  if (value) {
		return value;
	  }
	  // Check for numeric entity.
	  if (entity.charAt(0) == '#') {
		// Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
		var n = Number('0' + entity.substr(1));
		if (!isNaN(n)) {
		  value = String.fromCharCode(n);
		}
	  }
	  // Fall back to innerHTML otherwise.
	  if (!value) {
		// Append a non-entity character to avoid a bug in Webkit that parses
		// an invalid entity at the end of innerHTML text as the empty string.
		div.innerHTML = s + ' ';
		// Then remove the trailing character from the result.
		value = div.firstChild.nodeValue.slice(0, -1);
	  }
	  // Cache and return.
	  return seen[s] = value;
	});
};

/**
* Unescapes XML entities.
* @private
* @param {string} str The string to unescape.
* @return {string} An unescaped copy of {@code str}.
*/
goog.string.unescapePureXmlEntities_ = function(str) {
	return str.replace(/&([^;]+);/g, function(s, entity) {
	  switch (entity) {
		case 'amp':
		  return '&';
		case 'lt':
		  return '<';
		case 'gt':
		  return '>';
		case 'quot':
		  return '"';
		default:
		  if (entity.charAt(0) == '#') {
			// Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
			var n = Number('0' + entity.substr(1));
			if (!isNaN(n)) {
			  return String.fromCharCode(n);
			}
		  }
		  // For invalid entities we just return the entity
		  return s;
	  }
	});
};

/**
* Regular expression that matches an HTML entity.
* See also HTML5: Tokenization / Tokenizing character references.
* @private
* @type {!RegExp}
*/
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;

/**
* Determines whether a string contains a substring.
* @param {string} str The string to search.
* @param {string} subString The substring to search for.
* @return {boolean} Whether {@code str} contains {@code subString}.
*/
goog.string.contains = function(str, subString) {
	return str.indexOf(subString) != -1;
};

/**
* Escapes double quote '"' and single quote '\'' characters in addition to
* '&', '<', and '>' so that a string can be included in an HTML tag attribute
* value within double or single quotes.
*
* It should be noted that > doesn't need to be escaped for the HTML or XML to
* be valid, but it has been decided to escape it for consistency with other
* implementations.
*
* With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
* lowercase letter "e".
*
* NOTE(user):
* HtmlEscape is often called during the generation of large blocks of HTML.
* Using statics for the regular expressions and strings is an optimization
* that can more than half the amount of time IE spends in this function for
* large apps, since strings and regexes both contribute to GC allocations.
*
* Testing for the presence of a character before escaping increases the number
* of function calls, but actually provides a speed increase for the average
* case -- since the average case often doesn't require the escaping of all 4
* characters and indexOf() is much cheaper than replace().
* The worst case does suffer slightly from the additional calls, therefore the
* opt_isLikelyToContainHtmlChars option has been included for situations
* where all 4 HTML entities are very likely to be present and need escaping.
*
* Some benchmarks (times tended to fluctuate +-0.05ms):
*                                     FireFox                     IE6
* (no chars / average (mix of cases) / all 4 chars)
* no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
* indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
* indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
*
* An additional advantage of checking if replace actually needs to be called
* is a reduction in the number of object allocations, so as the size of the
* application grows the difference between the various methods would increase.
*
* @param {string} str string to be escaped.
* @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
*     if the character needs replacing - use this option if you expect each of
*     the characters to appear often. Leave false if you expect few html
*     characters to occur in your strings, such as if you are escaping HTML.
* @return {string} An escaped copy of {@code str}.
*/
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

	if (opt_isLikelyToContainHtmlChars) {
	  str = str.replace(goog.string.AMP_RE_, '&amp;').replace(goog.string.LT_RE_, '&lt;').replace(goog.string.GT_RE_, '&gt;').replace(goog.string.QUOT_RE_, '&quot;').replace(goog.string.SINGLE_QUOTE_RE_, '&#39;').replace(goog.string.NULL_RE_, '&#0;');
	  if (goog.string.DETECT_DOUBLE_ESCAPING) {
		str = str.replace(goog.string.E_RE_, '&#101;');
	  }
	  return str;
	} else {
	  // quick test helps in the case when there are no chars to replace, in
	  // worst case this makes barely a difference to the time taken
	  if (!goog.string.ALL_RE_.test(str)) return str;

	  // str.indexOf is faster than regex.test in this case
	  if (str.indexOf('&') != -1) {
		str = str.replace(goog.string.AMP_RE_, '&amp;');
	  }
	  if (str.indexOf('<') != -1) {
		str = str.replace(goog.string.LT_RE_, '&lt;');
	  }
	  if (str.indexOf('>') != -1) {
		str = str.replace(goog.string.GT_RE_, '&gt;');
	  }
	  if (str.indexOf('"') != -1) {
		str = str.replace(goog.string.QUOT_RE_, '&quot;');
	  }
	  if (str.indexOf('\'') != -1) {
		str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');
	  }
	  if (str.indexOf('\x00') != -1) {
		str = str.replace(goog.string.NULL_RE_, '&#0;');
	  }
	  if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {
		str = str.replace(goog.string.E_RE_, '&#101;');
	  }
	  return str;
	}
};

goog.debug = {};

/**
* Returns the type of a value. If a constructor is passed, and a suitable
* string cannot be found, 'unknown type name' will be returned.
*
* <p>Forked rather than moved from {@link goog.asserts.getType_}
* to avoid adding a dependency to goog.asserts.
* @param {*} value A constructor, object, or primitive.
* @return {string} The best display name for the value, or 'unknown type name'.
*/
goog.debug.runtimeType = function(value) {
	if (value instanceof Function) {
	  return value.displayName || value.name || 'unknown type name';
	} else if (value instanceof Object) {
	  return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
	} else {
	  return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
	}
};

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
* @fileoverview Provides a base class for custom Error objects such that the
* stack is correctly maintained.
*
* You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
* sufficient.
*
*/

/**
* Base class for custom error objects.
* @param {*=} opt_msg The message associated with the error.
* @constructor
* @extends {Error}
*/
goog.debug.Error = function(opt_msg) {

	// Attempt to ensure there is a stack trace.
	if (Error.captureStackTrace) {
	  Error.captureStackTrace(this, goog.debug.Error);
	} else {
	  var stack = new Error().stack;
	  if (stack) {
		this.stack = stack;
	  }
	}

	if (opt_msg) {
	  this.message = String(opt_msg);
	}

	/**
	 * Whether to report this error to the server. Setting this to false will
	 * cause the error reporter to not report the error back to the server,
	 * which can be useful if the client knows that the error has already been
	 * logged on the server.
	 * @type {boolean}
	 */
	this.reportErrorToServer = true;
};
goog.inherits(goog.debug.Error, Error);

/** @override */
goog.debug.Error.prototype.name = 'CustomError';

/**
* @fileoverview Definition of goog.dom.NodeType.
*/

goog.dom = {};

/**
* Constants for the nodeType attribute in the Node interface.
*
* These constants match those specified in the Node interface. These are
* usually present on the Node object in recent browsers, but not in older
* browsers (specifically, early IEs) and thus are given here.
*
* In some browsers (early IEs), these are not defined on the Node object,
* so they are provided here.
*
* See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
* @enum {number}
*/
goog.dom.NodeType = {
	ELEMENT: 1,
	ATTRIBUTE: 2,
	TEXT: 3,
	CDATA_SECTION: 4,
	ENTITY_REFERENCE: 5,
	ENTITY: 6,
	PROCESSING_INSTRUCTION: 7,
	COMMENT: 8,
	DOCUMENT: 9,
	DOCUMENT_TYPE: 10,
	DOCUMENT_FRAGMENT: 11,
	NOTATION: 12
};

// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
* @fileoverview Utility functions for supporting Bidi issues.
*/

/**
* Namespace for bidi supporting functions.
*/
goog.provide('goog.i18n.bidi');
goog.provide('goog.i18n.bidi.Dir');
goog.provide('goog.i18n.bidi.DirectionalString');
goog.provide('goog.i18n.bidi.Format');

/**
* @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
* to say that the current locale is a RTL locale.  This should only be used
* if you want to override the default behavior for deciding whether the
* current locale is RTL or not.
*
* {@see goog.i18n.bidi.IS_RTL}
*/
goog.define('goog.i18n.bidi.FORCE_RTL', false);

/**
* Constant that defines whether or not the current locale is a RTL locale.
* If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
* to check that {@link goog.LOCALE} is one of a few major RTL locales.
*
* <p>This is designed to be a maximally efficient compile-time constant. For
* example, for the default goog.LOCALE, compiling
* "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
* is this design consideration that limits the implementation to only
* supporting a few major RTL locales, as opposed to the broader repertoire of
* something like goog.i18n.bidi.isRtlLanguage.
*
* <p>Since this constant refers to the directionality of the locale, it is up
* to the caller to determine if this constant should also be used for the
* direction of the UI.
*
* {@see goog.LOCALE}
*
* @type {boolean}
*
* TODO(user): write a test that checks that this is a compile-time constant.
*/
goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' || goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' || goog.LOCALE.substring(0, 2).toLowerCase() == 'he' || goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' || goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' || goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' || goog.LOCALE.substring(2, 3) == '_') || goog.LOCALE.length >= 3 && goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' || goog.LOCALE.substring(3, 4) == '_');

/**
* Unicode formatting characters and directionality string constants.
* @enum {string}
*/
goog.i18n.bidi.Format = {
	/** Unicode "Left-To-Right Embedding" (LRE) character. */
	LRE: '\u202A',
	/** Unicode "Right-To-Left Embedding" (RLE) character. */
	RLE: '\u202B',
	/** Unicode "Pop Directional Formatting" (PDF) character. */
	PDF: '\u202C',
	/** Unicode "Left-To-Right Mark" (LRM) character. */
	LRM: '\u200E',
	/** Unicode "Right-To-Left Mark" (RLM) character. */
	RLM: '\u200F'
};

/**
* Directionality enum.
* @enum {number}
*/
goog.i18n.bidi.Dir = {
	/**
	 * Left-to-right.
	 */
	LTR: 1,

	/**
	 * Right-to-left.
	 */
	RTL: -1,

	/**
	 * Neither left-to-right nor right-to-left.
	 */
	NEUTRAL: 0
};

/**
* 'right' string constant.
* @type {string}
*/
goog.i18n.bidi.RIGHT = 'right';

/**
* 'left' string constant.
* @type {string}
*/
goog.i18n.bidi.LEFT = 'left';

/**
* 'left' if locale is RTL, 'right' if not.
* @type {string}
*/
goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;

/**
* 'right' if locale is RTL, 'left' if not.
* @type {string}
*/
goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;

/**
* Convert a directionality given in various formats to a goog.i18n.bidi.Dir
* constant. Useful for interaction with different standards of directionality
* representation.
*
* @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
*     in one of the following formats:
*     1. A goog.i18n.bidi.Dir constant.
*     2. A number (positive = LTR, negative = RTL, 0 = neutral).
*     3. A boolean (true = RTL, false = LTR).
*     4. A null for unknown directionality.
* @param {boolean=} opt_noNeutral Whether a givenDir of zero or
*     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
*     order to preserve legacy behavior.
* @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
*     given directionality. If given null, returns null (i.e. unknown).
*/
goog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {
	if (typeof givenDir == 'number') {
	  // This includes the non-null goog.i18n.bidi.Dir case.
	  return givenDir > 0 ? goog.i18n.bidi.Dir.LTR : givenDir < 0 ? goog.i18n.bidi.Dir.RTL : opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
	} else if (givenDir == null) {
	  return null;
	} else {
	  // Must be typeof givenDir == 'boolean'.
	  return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
	}
};

/**
* A practical pattern to identify strong LTR characters. This pattern is not
* theoretically correct according to the Unicode standard. It is simplified for
* performance and small code size.
* @type {string}
* @private
*/
goog.i18n.bidi.ltrChars_ = 'A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF' + '\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';

/**
* A practical pattern to identify strong RTL character. This pattern is not
* theoretically correct according to the Unicode standard. It is simplified
* for performance and small code size.
* @type {string}
* @private
*/
goog.i18n.bidi.rtlChars_ = '\u0591-\u06EF\u06FA-\u07FF\u200F\uFB1D-\uFDFF\uFE70-\uFEFC';

/**
* Simplified regular expression for an HTML tag (opening or closing) or an HTML
* escape. We might want to skip over such expressions when estimating the text
* directionality.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;

/**
* Returns the input text with spaces instead of HTML tags or HTML escapes, if
* opt_isStripNeeded is true. Else returns the input as is.
* Useful for text directionality estimation.
* Note: the function should not be used in other contexts; it is not 100%
* correct, but rather a good-enough implementation for directionality
* estimation purposes.
* @param {string} str The given string.
* @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
*     Default: false (to retain consistency with calling functions).
* @return {string} The given string cleaned of HTML tags / escapes.
* @private
*/
goog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {
	return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;
};

/**
* Regular expression to check for RTL characters.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');

/**
* Regular expression to check for LTR characters.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');

/**
* Test whether the given string has any RTL characters in it.
* @param {string} str The given string that need to be tested.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether the string contains RTL characters.
*/
goog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {
	return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};

/**
* Test whether the given string has any RTL characters in it.
* @param {string} str The given string that need to be tested.
* @return {boolean} Whether the string contains RTL characters.
* @deprecated Use hasAnyRtl.
*/
goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;

/**
* Test whether the given string has any LTR characters in it.
* @param {string} str The given string that need to be tested.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether the string contains LTR characters.
*/
goog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {
	return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};

/**
* Regular expression pattern to check if the first character in the string
* is LTR.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');

/**
* Regular expression pattern to check if the first character in the string
* is RTL.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');

/**
* Check if the first character in the string is RTL or not.
* @param {string} str The given string that need to be tested.
* @return {boolean} Whether the first character in str is an RTL char.
*/
goog.i18n.bidi.isRtlChar = function(str) {
	return goog.i18n.bidi.rtlRe_.test(str);
};

/**
* Check if the first character in the string is LTR or not.
* @param {string} str The given string that need to be tested.
* @return {boolean} Whether the first character in str is an LTR char.
*/
goog.i18n.bidi.isLtrChar = function(str) {
	return goog.i18n.bidi.ltrRe_.test(str);
};

/**
* Check if the first character in the string is neutral or not.
* @param {string} str The given string that need to be tested.
* @return {boolean} Whether the first character in str is a neutral char.
*/
goog.i18n.bidi.isNeutralChar = function(str) {
	return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
};

/**
* Regular expressions to check if a piece of text is of LTR directionality
* on first character with strong directionality.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.ltrDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');

/**
* Regular expressions to check if a piece of text is of RTL directionality
* on first character with strong directionality.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.rtlDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');

/**
* Check whether the first strongly directional character (if any) is RTL.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether RTL directionality is detected using the first
*     strongly-directional character method.
*/
goog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {
	return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};

/**
* Check whether the first strongly directional character (if any) is RTL.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether RTL directionality is detected using the first
*     strongly-directional character method.
* @deprecated Use startsWithRtl.
*/
goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;

/**
* Check whether the first strongly directional character (if any) is LTR.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether LTR directionality is detected using the first
*     strongly-directional character method.
*/
goog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {
	return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};

/**
* Check whether the first strongly directional character (if any) is LTR.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether LTR directionality is detected using the first
*     strongly-directional character method.
* @deprecated Use startsWithLtr.
*/
goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;

/**
* Regular expression to check if a string looks like something that must
* always be LTR even in RTL text, e.g. a URL. When estimating the
* directionality of text containing these, we treat these as weakly LTR,
* like numbers.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;

/**
* Check whether the input string either contains no strongly directional
* characters or looks like a url.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether neutral directionality is detected.
*/
goog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {
	str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
	return goog.i18n.bidi.isRequiredLtrRe_.test(str) || !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
};

/**
* Regular expressions to check if the last strongly-directional character in a
* piece of text is LTR.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + '][^' + goog.i18n.bidi.rtlChars_ + ']*$');

/**
* Regular expressions to check if the last strongly-directional character in a
* piece of text is RTL.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + '][^' + goog.i18n.bidi.ltrChars_ + ']*$');

/**
* Check if the exit directionality a piece of text is LTR, i.e. if the last
* strongly-directional character in the string is LTR.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether LTR exit directionality was detected.
*/
goog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {
	return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};

/**
* Check if the exit directionality a piece of text is LTR, i.e. if the last
* strongly-directional character in the string is LTR.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether LTR exit directionality was detected.
* @deprecated Use endsWithLtr.
*/
goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;

/**
* Check if the exit directionality a piece of text is RTL, i.e. if the last
* strongly-directional character in the string is RTL.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether RTL exit directionality was detected.
*/
goog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {
	return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};

/**
* Check if the exit directionality a piece of text is RTL, i.e. if the last
* strongly-directional character in the string is RTL.
* @param {string} str String being checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether RTL exit directionality was detected.
* @deprecated Use endsWithRtl.
*/
goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;

/**
* A regular expression for matching right-to-left language codes.
* See {@link #isRtlLanguage} for the design.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.rtlLocalesRe_ = new RegExp('^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' + '.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))' + '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)', 'i');

/**
* Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
* - a language code explicitly specifying one of the right-to-left scripts,
*   e.g. "az-Arab", or<p>
* - a language code specifying one of the languages normally written in a
*   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
*   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
* The list of right-to-left scripts appears in the 100-199 range in
* http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
* Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
* Tifinagh, which also have significant modern usage. The rest (Syriac,
* Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
* and are not recognized to save on code size.
* The languages usually written in a right-to-left script are taken as those
* with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
* http://www.iana.org/assignments/language-subtag-registry,
* as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
* Other subtags of the language code, e.g. regions like EG (Egypt), are
* ignored.
* @param {string} lang BCP 47 (a.k.a III) language code.
* @return {boolean} Whether the language code is an RTL language.
*/
goog.i18n.bidi.isRtlLanguage = function(lang) {
	return goog.i18n.bidi.rtlLocalesRe_.test(lang);
};

/**
* Regular expression for bracket guard replacement in text.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;

/**
* Apply bracket guard using LRM and RLM. This is to address the problem of
* messy bracket display frequently happens in RTL layout.
* This function works for plain text, not for HTML. In HTML, the opening
* bracket might be in a different context than the closing bracket (such as
* an attribute value).
* @param {string} s The string that need to be processed.
* @param {boolean=} opt_isRtlContext specifies default direction (usually
*     direction of the UI).
* @return {string} The processed string, with all bracket guarded.
*/
goog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {
	var useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
	var mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
	return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);
};

/**
* Enforce the html snippet in RTL directionality regardless overall context.
* If the html piece was enclosed by tag, dir will be applied to existing
* tag, otherwise a span tag will be added as wrapper. For this reason, if
* html snippet start with with tag, this tag must enclose the whole piece. If
* the tag already has a dir specified, this new one will override existing
* one in behavior (tested on FF and IE).
* @param {string} html The string that need to be processed.
* @return {string} The processed string, with directionality enforced to RTL.
*/
goog.i18n.bidi.enforceRtlInHtml = function(html) {
	if (html.charAt(0) == '<') {
	  return html.replace(/<\w+/, '$& dir=rtl');
	}
	// '\n' is important for FF so that it won't incorrectly merge span groups
	return '\n<span dir=rtl>' + html + '</span>';
};

/**
* Enforce RTL on both end of the given text piece using unicode BiDi formatting
* characters RLE and PDF.
* @param {string} text The piece of text that need to be wrapped.
* @return {string} The wrapped string after process.
*/
goog.i18n.bidi.enforceRtlInText = function(text) {
	return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
};

/**
* Enforce the html snippet in RTL directionality regardless overall context.
* If the html piece was enclosed by tag, dir will be applied to existing
* tag, otherwise a span tag will be added as wrapper. For this reason, if
* html snippet start with with tag, this tag must enclose the whole piece. If
* the tag already has a dir specified, this new one will override existing
* one in behavior (tested on FF and IE).
* @param {string} html The string that need to be processed.
* @return {string} The processed string, with directionality enforced to RTL.
*/
goog.i18n.bidi.enforceLtrInHtml = function(html) {
	if (html.charAt(0) == '<') {
	  return html.replace(/<\w+/, '$& dir=ltr');
	}
	// '\n' is important for FF so that it won't incorrectly merge span groups
	return '\n<span dir=ltr>' + html + '</span>';
};

/**
* Enforce LTR on both end of the given text piece using unicode BiDi formatting
* characters LRE and PDF.
* @param {string} text The piece of text that need to be wrapped.
* @return {string} The wrapped string after process.
*/
goog.i18n.bidi.enforceLtrInText = function(text) {
	return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
};

/**
* Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
* @type {RegExp}
* @private
*/
goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;

/**
* Regular expression for left.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.leftRe_ = /left/gi;

/**
* Regular expression for right.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.rightRe_ = /right/gi;

/**
* Placeholder regular expression for swapping.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.tempRe_ = /%%%%/g;

/**
* Swap location parameters and 'left'/'right' in CSS specification. The
* processed string will be suited for RTL layout. Though this function can
* cover most cases, there are always exceptions. It is suggested to put
* those exceptions in separate group of CSS string.
* @param {string} cssStr CSS spefication string.
* @return {string} Processed CSS specification string.
*/
goog.i18n.bidi.mirrorCSS = function(cssStr) {
	return cssStr.
	// reverse dimensions
	replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2').replace(goog.i18n.bidi.leftRe_, '%%%%'). // swap left and right
	replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
};

/**
* Regular expression for hebrew double quote substitution, finding quote
* directly after hebrew characters.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;

/**
* Regular expression for hebrew single quote substitution, finding quote
* directly after hebrew characters.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;

/**
* Replace the double and single quote directly after a Hebrew character with
* GERESH and GERSHAYIM. In such case, most likely that's user intention.
* @param {string} str String that need to be processed.
* @return {string} Processed string with double/single quote replaced.
*/
goog.i18n.bidi.normalizeHebrewQuote = function(str) {
	return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\u05F4').replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\u05F3');
};

/**
* Regular expression to split a string into "words" for directionality
* estimation based on relative word counts.
* @type {RegExp}
* @private
*/
goog.i18n.bidi.wordSeparatorRe_ = /\s+/;

/**
* Regular expression to check if a string contains any numerals. Used to
* differentiate between completely neutral strings and those containing
* numbers, which are weakly LTR.
*
* Native Arabic digits (\u0660 - \u0669) are not included because although they
* do flow left-to-right inside a number, this is the case even if the  overall
* directionality is RTL, and a mathematical expression using these digits is
* supposed to flow right-to-left overall, including unary plus and minus
* appearing to the right of a number, and this does depend on the overall
* directionality being RTL. The digits used in Farsi (\u06F0 - \u06F9), on the
* other hand, are included, since Farsi math (including unary plus and minus)
* does flow left-to-right.
*
* @type {RegExp}
* @private
*/
goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;

/**
* This constant controls threshold of RTL directionality.
* @type {number}
* @private
*/
goog.i18n.bidi.rtlDetectionThreshold_ = 0.40;

/**
* Estimates the directionality of a string based on relative word counts.
* If the number of RTL words is above a certain percentage of the total number
* of strongly directional words, returns RTL.
* Otherwise, if any words are strongly or weakly LTR, returns LTR.
* Otherwise, returns UNKNOWN, which is used to mean "neutral".
* Numbers are counted as weakly LTR.
* @param {string} str The string to be checked.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
*/
goog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {
	var rtlCount = 0;
	var totalCount = 0;
	var hasWeaklyLtr = false;
	var tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_);
	for (var i = 0; i < tokens.length; i++) {
	  var token = tokens[i];
	  if (goog.i18n.bidi.startsWithRtl(token)) {
		rtlCount++;
		totalCount++;
	  } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {
		hasWeaklyLtr = true;
	  } else if (goog.i18n.bidi.hasAnyLtr(token)) {
		totalCount++;
	  } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {
		hasWeaklyLtr = true;
	  }
	}

	return totalCount == 0 ? hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
};

/**
* Check the directionality of a piece of text, return true if the piece of
* text should be laid out in RTL direction.
* @param {string} str The piece of text that need to be detected.
* @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
*     Default: false.
* @return {boolean} Whether this piece of text should be laid out in RTL.
*/
goog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {
	return goog.i18n.bidi.estimateDirection(str, opt_isHtml) == goog.i18n.bidi.Dir.RTL;
};

/**
* Sets text input element's directionality and text alignment based on a
* given directionality. Does nothing if the given directionality is unknown or
* neutral.
* @param {Element} element Input field element to set directionality to.
* @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
*     given in one of the following formats:
*     1. A goog.i18n.bidi.Dir constant.
*     2. A number (positive = LRT, negative = RTL, 0 = neutral).
*     3. A boolean (true = RTL, false = LTR).
*     4. A null for unknown directionality.
*/
goog.i18n.bidi.setElementDirAndAlign = function(element, dir) {
	if (element) {
	  dir = goog.i18n.bidi.toDir(dir);
	  if (dir) {
		element.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
		element.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
	  }
	}
};

/**
* Sets element dir based on estimated directionality of the given text.
* @param {!Element} element
* @param {string} text
*/
goog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {
	switch (goog.i18n.bidi.estimateDirection(text)) {
	  case goog.i18n.bidi.Dir.LTR:
		element.dir = 'ltr';
		break;
	  case goog.i18n.bidi.Dir.RTL:
		element.dir = 'rtl';
		break;
	  default:
		// Default for no direction, inherit from document.
		element.removeAttribute('dir');
	}
};

/**
* Strings that have an (optional) known direction.
*
* Implementations of this interface are string-like objects that carry an
* attached direction, if known.
* @interface
*/
goog.i18n.bidi.DirectionalString = function() {};

/**
* Interface marker of the DirectionalString interface.
*
* This property can be used to determine at runtime whether or not an object
* implements this interface.  All implementations of this interface set this
* property to {@code true}.
* @type {boolean}
*/
goog.i18n.bidi.DirectionalString.prototype.implementsGoogI18nBidiDirectionalString;

/**
* Retrieves this object's known direction (if any).
* @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.
*/
goog.i18n.bidi.DirectionalString.prototype.getDirection;

// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
* @fileoverview Utilities to check the preconditions, postconditions and
* invariants runtime.
*
* Methods in this package should be given special treatment by the compiler
* for type-inference. For example, <code>goog.asserts.assert(foo)</code>
* will restrict <code>foo</code> to a truthy value.
*
* The compiler has an option to disable asserts. So code like:
* <code>
* var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
* </code>
* will be transformed into:
* <code>
* var x = foo();
* </code>
* The compiler will leave in foo() (because its return value is used),
* but it will remove bar() because it assumes it does not have side-effects.
*
* @author agrieve@google.com (Andrew Grieve)
*/

goog.provide('goog.asserts');

/**
* @define {boolean} Whether to strip out asserts or to leave them in.
*/
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);

/**
* Error object for failed assertions.
* @param {string} messagePattern The pattern that was used to form message.
* @param {!Array<*>} messageArgs The items to substitute into the pattern.
* @constructor
* @extends {goog.debug.Error}
* @final
*/
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
	messageArgs.unshift(messagePattern);
	goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
	// Remove the messagePattern afterwards to avoid permanently modifying the
	// passed in array.
	messageArgs.shift();

	/**
	 * The message pattern used to format the error message. Error handlers can
	 * use this to uniquely identify the assertion.
	 * @type {string}
	 */
	this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);

/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';

/**
* The default error handler.
* @param {!goog.asserts.AssertionError} e The exception to be handled.
*/
goog.asserts.DEFAULT_ERROR_HANDLER = function(e) {
	throw e;
};

/**
* The handler responsible for throwing or logging assertion errors.
* @private {function(!goog.asserts.AssertionError)}
*/
goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;

/**
* Throws an exception with the given message and "Assertion failed" prefixed
* onto it.
* @param {string} defaultMessage The message to use if givenMessage is empty.
* @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
* @param {string|undefined} givenMessage Message supplied by the caller.
* @param {Array<*>} givenArgs The substitution arguments for givenMessage.
* @throws {goog.asserts.AssertionError} When the value is not a number.
* @private
*/
goog.asserts.doAssertFailure_ = function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
	var message = 'Assertion failed';
	if (givenMessage) {
	  message += ': ' + givenMessage;
	  var args = givenArgs;
	} else if (defaultMessage) {
	  message += ': ' + defaultMessage;
	  args = defaultArgs;
	}
	// The '' + works around an Opera 10 bug in the unit tests. Without it,
	// a stack trace is added to var message above. With this, a stack trace is
	// not added until this line (it causes the extra garbage to be added after
	// the assertion message instead of in the middle of it).
	var e = new goog.asserts.AssertionError('' + message, args || []);
	goog.asserts.errorHandler_(e);
};

/**
* Sets a custom error handler that can be used to customize the behavior of
* assertion failures, for example by turning all assertion failures into log
* messages.
* @param {function(!goog.asserts.AssertionError)} errorHandler
*/
goog.asserts.setErrorHandler = function(errorHandler) {
	if (goog.asserts.ENABLE_ASSERTS) {
	  goog.asserts.errorHandler_ = errorHandler;
	}
};

/**
* Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
* true.
* @template T
* @param {T} condition The condition to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {T} The value of the condition.
* @throws {goog.asserts.AssertionError} When the condition evaluates to false.
*/
goog.asserts.assert = function(condition, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !condition) {
	  goog.asserts.doAssertFailure_('', null, opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return condition;
};

/**
* Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
* when we want to add a check in the unreachable area like switch-case
* statement:
*
* <pre>
*  switch(type) {
*    case FOO: doSomething(); break;
*    case BAR: doSomethingElse(); break;
*    default: goog.assert.fail('Unrecognized type: ' + type);
*      // We have only 2 types - "default:" section is unreachable code.
*  }
* </pre>
*
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @throws {goog.asserts.AssertionError} Failure.
*/
goog.asserts.fail = function(opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS) {
	  goog.asserts.errorHandler_(new goog.asserts.AssertionError('Failure' + (opt_message ? ': ' + opt_message : ''), Array.prototype.slice.call(arguments, 1)));
	}
};

/**
* Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {number} The value, guaranteed to be a number when asserts enabled.
* @throws {goog.asserts.AssertionError} When the value is not a number.
*/
goog.asserts.assertNumber = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
	  goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {number} */value
	);
};

/**
* Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {string} The value, guaranteed to be a string when asserts enabled.
* @throws {goog.asserts.AssertionError} When the value is not a string.
*/
goog.asserts.assertString = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
	  goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {string} */value
	);
};

/**
* Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {!Function} The value, guaranteed to be a function when asserts
*     enabled.
* @throws {goog.asserts.AssertionError} When the value is not a function.
*/
goog.asserts.assertFunction = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
	  goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {!Function} */value
	);
};

/**
* Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {!Object} The value, guaranteed to be a non-null object.
* @throws {goog.asserts.AssertionError} When the value is not an object.
*/
goog.asserts.assertObject = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
	  goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {!Object} */value
	);
};

/**
* Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {!Array<?>} The value, guaranteed to be a non-null array.
* @throws {goog.asserts.AssertionError} When the value is not an array.
*/
goog.asserts.assertArray = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
	  goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {!Array<?>} */value
	);
};

/**
* Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {boolean} The value, guaranteed to be a boolean when asserts are
*     enabled.
* @throws {goog.asserts.AssertionError} When the value is not a boolean.
*/
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
	  goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {boolean} */value
	);
};

/**
* Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
* @param {*} value The value to check.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @return {!Element} The value, likely to be a DOM Element when asserts are
*     enabled.
* @throws {goog.asserts.AssertionError} When the value is not an Element.
*/
goog.asserts.assertElement = function(value, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) {
	  goog.asserts.doAssertFailure_('Expected Element but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
	}
	return (/** @type {!Element} */value
	);
};

/**
* Checks if the value is an instance of the user-defined type if
* goog.asserts.ENABLE_ASSERTS is true.
*
* The compiler may tighten the type returned by this function.
*
* @param {?} value The value to check.
* @param {function(new: T, ...)} type A user-defined constructor.
* @param {string=} opt_message Error message in case of failure.
* @param {...*} var_args The items to substitute into the failure message.
* @throws {goog.asserts.AssertionError} When the value is not an instance of
*     type.
* @return {T}
* @template T
*/
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
	if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
	  goog.asserts.doAssertFailure_('Expected instanceof %s but got %s.', [goog.asserts.getType_(type), goog.asserts.getType_(value)], opt_message, Array.prototype.slice.call(arguments, 3));
	}
	return value;
};

/**
* Checks that no enumerable keys are present in Object.prototype. Such keys
* would break most code that use {@code for (var ... in ...)} loops.
*/
goog.asserts.assertObjectPrototypeIsIntact = function() {
	for (var key in Object.prototype) {
	  goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
	}
};

/**
* Returns the type of a value. If a constructor is passed, and a suitable
* string cannot be found, 'unknown type name' will be returned.
* @param {*} value A constructor, object, or primitive.
* @return {string} The best display name for the value, or 'unknown type name'.
* @private
*/
goog.asserts.getType_ = function(value) {
	if (value instanceof Function) {
	  return value.displayName || value.name || 'unknown type name';
	} else if (value instanceof Object) {
	  return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
	} else {
	  return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
	}
};

/**
* @fileoverview Utility for fast string concatenation.
*/

/**
* Utility class to facilitate string concatenation.
*
* @param {*=} opt_a1 Optional first initial item to append.
* @param {...*} var_args Other initial items to
*     append, e.g., new goog.string.StringBuffer('foo', 'bar').
* @constructor
*/
goog.string.StringBuffer = function(opt_a1, var_args) {
	if (opt_a1 != null) {
	  this.append.apply(this, arguments);
	}
};

/**
* Internal buffer for the string to be concatenated.
* @type {string}
* @private
*/
goog.string.StringBuffer.prototype.buffer_ = '';

/**
* Sets the contents of the string buffer object, replacing what's currently
* there.
*
* @param {*} s String to set.
*/
goog.string.StringBuffer.prototype.set = function(s) {
	this.buffer_ = '' + s;
};

/**
* Appends one or more items to the buffer.
*
* Calling this with null, undefined, or empty arguments is an error.
*
* @param {*} a1 Required first string.
* @param {*=} opt_a2 Optional second string.
* @param {...?} var_args Other items to append,
*     e.g., sb.append('foo', 'bar', 'baz').
* @return {!goog.string.StringBuffer} This same StringBuffer object.
* @suppress {duplicate}
*/
goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
	// Use a1 directly to avoid arguments instantiation for single-arg case.
	this.buffer_ += String(a1);
	if (opt_a2 != null) {
	  // second argument is undefined (null == undefined)
	  for (var i = 1; i < arguments.length; i++) {
		this.buffer_ += arguments[i];
	  }
	}
	return this;
};

/**
* Clears the internal buffer.
*/
goog.string.StringBuffer.prototype.clear = function() {
	this.buffer_ = '';
};

/**
* @return {number} the length of the current contents of the buffer.
*/
goog.string.StringBuffer.prototype.getLength = function() {
	return this.buffer_.length;
};

/**
* @return {string} The concatenated string.
* @override
*/
goog.string.StringBuffer.prototype.toString = function() {
	return this.buffer_;
};

// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
* @fileoverview Soy data primitives.
*
* The goal is to encompass data types used by Soy, especially to mark content
* as known to be "safe".
*
* @author gboyer@google.com (Garrett Boyer)
*/

goog.soy = {};
goog.soy.data = {};

/**
* A type of textual content.
*
* This is an enum of type Object so that these values are unforgeable.
*
* @enum {!Object}
*/
goog.soy.data.SanitizedContentKind = {

	/**
	 * A snippet of HTML that does not start or end inside a tag, comment, entity,
	 * or DOCTYPE; and that does not contain any executable code
	 * (JS, {@code <object>}s, etc.) from a different trust domain.
	 */
	HTML: goog.DEBUG ? { sanitizedContentKindHtml: true } : {},

	/**
	 * Executable Javascript code or expression, safe for insertion in a
	 * script-tag or event handler context, known to be free of any
	 * attacker-controlled scripts. This can either be side-effect-free
	 * Javascript (such as JSON) or Javascript that's entirely under Google's
	 * control.
	 */
	JS: goog.DEBUG ? { sanitizedContentJsChars: true } : {},

	/** A properly encoded portion of a URI. */
	URI: goog.DEBUG ? { sanitizedContentUri: true } : {},

	/** A resource URI not under attacker control. */
	TRUSTED_RESOURCE_URI: goog.DEBUG ? { sanitizedContentTrustedResourceUri: true } : {},

	/**
	 * Repeated attribute names and values. For example,
	 * {@code dir="ltr" foo="bar" onclick="trustedFunction()" checked}.
	 */
	ATTRIBUTES: goog.DEBUG ? { sanitizedContentHtmlAttribute: true } : {},

	// TODO: Consider separating rules, declarations, and values into
	// separate types, but for simplicity, we'll treat explicitly blessed
	// SanitizedContent as allowed in all of these contexts.
	/**
	 * A CSS3 declaration, property, value or group of semicolon separated
	 * declarations.
	 */
	STYLE: goog.DEBUG ? { sanitizedContentStyle: true } : {},

	/** A CSS3 style sheet (list of rules). */
	CSS: goog.DEBUG ? { sanitizedContentCss: true } : {},

	/**
	 * Unsanitized plain-text content.
	 *
	 * This is effectively the "null" entry of this enum, and is sometimes used
	 * to explicitly mark content that should never be used unescaped. Since any
	 * string is safe to use as text, being of ContentKind.TEXT makes no
	 * guarantees about its safety in any other context such as HTML.
	 */
	TEXT: goog.DEBUG ? { sanitizedContentKindText: true } : {}
};

/**
* A string-like object that carries a content-type and a content direction.
*
* IMPORTANT! Do not create these directly, nor instantiate the subclasses.
* Instead, use a trusted, centrally reviewed library as endorsed by your team
* to generate these objects. Otherwise, you risk accidentally creating
* SanitizedContent that is attacker-controlled and gets evaluated unescaped in
* templates.
*
* @constructor
*/
goog.soy.data.SanitizedContent = function() {
	throw new Error('Do not instantiate directly');
};

/**
* The context in which this content is safe from XSS attacks.
* @type {goog.soy.data.SanitizedContentKind}
*/
goog.soy.data.SanitizedContent.prototype.contentKind;

/**
* The content's direction; null if unknown and thus to be estimated when
* necessary.
* @type {?goog.i18n.bidi.Dir}
*/
goog.soy.data.SanitizedContent.prototype.contentDir = null;

/**
* The already-safe content.
* @protected {string}
*/
goog.soy.data.SanitizedContent.prototype.content;

/**
* Gets the already-safe content.
* @return {string}
*/
goog.soy.data.SanitizedContent.prototype.getContent = function() {
	return this.content;
};

/** @override */
goog.soy.data.SanitizedContent.prototype.toString = function() {
	return this.content;
};

/**
* Converts sanitized content of kind TEXT or HTML into SafeHtml. HTML content
* is converted without modification, while text content is HTML-escaped.
* @return {!goog.html.SafeHtml}
* @throws {Error} when the content kind is not TEXT or HTML.
*/
goog.soy.data.SanitizedContent.prototype.toSafeHtml = function() {
	if (this.contentKind === goog.soy.data.SanitizedContentKind.TEXT) {
	  return goog.html.SafeHtml.htmlEscape(this.toString());
	}
	if (this.contentKind !== goog.soy.data.SanitizedContentKind.HTML) {
	  throw new Error('Sanitized content was not of kind TEXT or HTML.');
	}
	return goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from('Soy SanitizedContent of kind HTML produces ' + 'SafeHtml-contract-compliant value.'), this.toString(), this.contentDir);
};

/**
* Converts sanitized content of kind URI into SafeUrl without modification.
* @return {!goog.html.SafeUrl}
* @throws {Error} when the content kind is not URI.
*/
goog.soy.data.SanitizedContent.prototype.toSafeUrl = function() {
	if (this.contentKind !== goog.soy.data.SanitizedContentKind.URI) {
	  throw new Error('Sanitized content was not of kind URI.');
	}
	return goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from('Soy SanitizedContent of kind URI produces ' + 'SafeHtml-contract-compliant value.'), this.toString());
};

/**
* Unsanitized plain text string.
*
* While all strings are effectively safe to use as a plain text, there are no
* guarantees about safety in any other context such as HTML. This is
* sometimes used to mark that should never be used unescaped.
*
* @param {*} content Plain text with no guarantees.
* @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
*     unknown and thus to be estimated when necessary. Default: null.
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.UnsanitizedText = function(content, opt_contentDir) {
	// Not calling the superclass constructor which just throws an exception.

	/** @override */
	this.content = String(content);
	this.contentDir = opt_contentDir != null ? opt_contentDir : null;
};
goog.inherits(goog.soy.data.UnsanitizedText, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.UnsanitizedText.prototype.contentKind = goog.soy.data.SanitizedContentKind.TEXT;

/**
* Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
*
* The content is a string of HTML that can safely be embedded in a PCDATA
* context in your app.  If you would be surprised to find that an HTML
* sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
* you wouldn't write a template that produces {@code s} on security or privacy
* grounds, then don't pass {@code s} here. The default content direction is
* unknown, i.e. to be estimated when necessary.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedHtml = function() {
	goog.soy.data.SanitizedHtml.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedHtml, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedHtml.prototype.contentKind = goog.soy.data.SanitizedContentKind.HTML;

/**
* Checks if the value could be used as the Soy type {html}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedHtml.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtml || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeHtml;
};

/**
* Content of type {@link goog.soy.data.SanitizedContentKind.JS}.
*
* The content is JavaScript source that when evaluated does not execute any
* attacker-controlled scripts. The content direction is LTR.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedJs = function() {
	goog.soy.data.SanitizedJs.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedJs, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedJs.prototype.contentKind = goog.soy.data.SanitizedContentKind.JS;

/** @override */
goog.soy.data.SanitizedJs.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

/**
* Checks if the value could be used as the Soy type {js}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedJs.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedJs || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeScript;
};

/**
* Content of type {@link goog.soy.data.SanitizedContentKind.URI}.
*
* The content is a URI chunk that the caller knows is safe to emit in a
* template. The content direction is LTR.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedUri = function() {
	goog.soy.data.SanitizedUri.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedUri, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedUri.prototype.contentKind = goog.soy.data.SanitizedContentKind.URI;

/** @override */
goog.soy.data.SanitizedUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

/**
* Checks if the value could be used as the Soy type {uri}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedUri.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedUri || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeUrl || value instanceof goog.html.TrustedResourceUrl || value instanceof goog.Uri;
};

/**
* Content of type
* {@link goog.soy.data.SanitizedContentKind.TRUSTED_RESOURCE_URI}.
*
* The content is a TrustedResourceUri chunk that is not under attacker control.
* The content direction is LTR.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedTrustedResourceUri = function() {
	goog.soy.data.SanitizedTrustedResourceUri.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedTrustedResourceUri, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedTrustedResourceUri.prototype.contentKind = goog.soy.data.SanitizedContentKind.TRUSTED_RESOURCE_URI;

/** @override */
goog.soy.data.SanitizedTrustedResourceUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

/**
* Converts sanitized content into TrustedResourceUrl without modification.
* @return {!goog.html.TrustedResourceUrl}
*/
goog.soy.data.SanitizedTrustedResourceUri.prototype.toTrustedResourceUrl = function() {
	return goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from('Soy SanitizedContent of kind TRUSTED_RESOURCE_URI produces ' + 'TrustedResourceUrl-contract-compliant value.'), this.toString());
};

/**
* Checks if the value could be used as the Soy type {trusted_resource_uri}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedTrustedResourceUri.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedTrustedResourceUri || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.TrustedResourceUrl;
};

/**
* Content of type {@link goog.soy.data.SanitizedContentKind.ATTRIBUTES}.
*
* The content should be safely embeddable within an open tag, such as a
* key="value" pair. The content direction is LTR.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedHtmlAttribute = function() {
	goog.soy.data.SanitizedHtmlAttribute.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedHtmlAttribute, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedHtmlAttribute.prototype.contentKind = goog.soy.data.SanitizedContentKind.ATTRIBUTES;

/** @override */
goog.soy.data.SanitizedHtmlAttribute.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

/**
* Checks if the value could be used as the Soy type {attribute}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedHtmlAttribute.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtmlAttribute || value instanceof goog.soy.data.UnsanitizedText;
};

/**
* Content of type {@link goog.soy.data.SanitizedContentKind.STYLE}.
*
* The content is non-attacker-exploitable CSS, such as {@code color:#c3d9ff}.
* The content direction is LTR.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedStyle = function() {
	goog.soy.data.SanitizedStyle.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedStyle, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedStyle.prototype.contentKind = goog.soy.data.SanitizedContentKind.STYLE;

/** @override */
goog.soy.data.SanitizedStyle.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

/**
* Checks if the value could be used as the Soy type {css}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedStyle.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedStyle || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeStyle;
};

/**
* Content of type {@link goog.soy.data.SanitizedContentKind.CSS}.
*
* The content is non-attacker-exploitable CSS, such as {@code @import url(x)}.
* The content direction is LTR.
*
* @extends {goog.soy.data.SanitizedContent}
* @constructor
*/
goog.soy.data.SanitizedCss = function() {
	goog.soy.data.SanitizedCss.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedCss, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedCss.prototype.contentKind = goog.soy.data.SanitizedContentKind.CSS;

/** @override */
goog.soy.data.SanitizedCss.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

/**
* Checks if the value could be used as the Soy type {css}.
* @param {*} value
* @return {boolean}
*/
goog.soy.data.SanitizedCss.isCompatibleWith = function(value) {
	return goog.isString(value) || value instanceof goog.soy.data.SanitizedCss || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeStyle || // TODO(jakubvrana): Delete.
	value instanceof goog.html.SafeStyleSheet;
};

/**
* Converts SanitizedCss into SafeStyleSheet.
* Note: SanitizedCss in Soy represents both SafeStyle and SafeStyleSheet in
* Closure. It's about to be split so that SanitizedCss represents only
* SafeStyleSheet.
* @return {!goog.html.SafeStyleSheet}
*/
goog.soy.data.SanitizedCss.prototype.toSafeStyleSheet = function() {
	var value = this.toString();
	// TODO(jakubvrana): Remove this check when there's a separate type for style
	// declaration.
	goog.asserts.assert(/[@{]|^\s*$/.test(value), 'value doesn\'t look like style sheet: ' + value);
	return goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract(goog.string.Const.from('Soy SanitizedCss produces SafeStyleSheet-contract-compliant ' + 'value.'), value);
};
/*
* Copyright 2008 Google Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* @fileoverview
* Utility functions and classes for Soy.
*
* <p>
* The top portion of this file contains utilities for Soy users:<ul>
*   <li> soy.StringBuilder: Compatible with the 'stringbuilder' code style.
* </ul>
*
* <p>
* The bottom portion of this file contains utilities that should only be called
* by Soy-generated JS code. Please do not use these functions directly from
* your hand-writen code. Their names all start with '$$'.
*
*/

// -----------------------------------------------------------------------------
// StringBuilder (compatible with the 'stringbuilder' code style).

(function () {
	var soy = {};
	soy.asserts = {};
	soy.esc = {};
	var soydata = {};

	/**
	 * Utility class to facilitate much faster string concatenation in IE,
	 * using Array.join() rather than the '+' operator. For other browsers
	 * we simply use the '+' operator.
	 *
	 * @param {Object} var_args Initial items to append,
	 *     e.g., new soy.StringBuilder('foo', 'bar').
	 * @constructor
	 */
	soy.StringBuilder = goog.string.StringBuffer;

	// -----------------------------------------------------------------------------
	// soydata: Defines typed strings, e.g. an HTML string {@code "a<b>c"} is
	// semantically distinct from the plain text string {@code "a<b>c"} and smart
	// templates can take that distinction into account.

	/**
	 * A type of textual content.
	 *
	 * This is an enum of type Object so that these values are unforgeable.
	 *
	 * @enum {!Object}
	 */
	soydata.SanitizedContentKind = goog.soy.data.SanitizedContentKind;

	/**
	 * Checks whether a given value is of a given content kind.
	 *
	 * @param {*} value The value to be examined.
	 * @param {soydata.SanitizedContentKind} contentKind The desired content
	 *     kind.
	 * @return {boolean} Whether the given value is of the given kind.
	 * @private
	 */
	soydata.isContentKind = function(value, contentKind) {
	  // TODO(user): This function should really include the assert on
	  // value.constructor that is currently sprinkled at most of the call sites.
	  // Unfortunately, that would require a (debug-mode-only) switch statement.
	  // TODO(user): Perhaps we should get rid of the contentKind property
	  // altogether and only at the constructor.
	  return value != null && value.contentKind === contentKind;
	};

	/**
	 * Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
	 *
	 * The content is a string of HTML that can safely be embedded in a PCDATA
	 * context in your app.  If you would be surprised to find that an HTML
	 * sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
	 * you wouldn't write a template that produces {@code s} on security or privacy
	 * grounds, then don't pass {@code s} here. The default content direction is
	 * unknown, i.e. to be estimated when necessary.
	 *
	 * @constructor
	 * @extends {goog.soy.data.SanitizedHtml}
	 */
	soydata.SanitizedHtml = function() {
	  soydata.SanitizedHtml.base(this, 'constructor'); // Throws an exception.
	};
	goog.inherits(soydata.SanitizedHtml, goog.soy.data.SanitizedHtml);

	/**
	 * Returns a SanitizedHtml object for a particular value. The content direction
	 * is preserved.
	 *
	 * This HTML-escapes the value unless it is already SanitizedHtml or SafeHtml.
	 *
	 * @param {*} value The value to convert. If it is already a SanitizedHtml
	 *     object, it is left alone.
	 * @return {!soydata.SanitizedHtml} A SanitizedHtml object derived from the
	 *     stringified value. It is escaped unless the input is SanitizedHtml or
	 *     SafeHtml.
	 */
	soydata.SanitizedHtml.from = function(value) {
	  // The check is soydata.isContentKind_() inlined for performance.
	  if (value != null && value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
		goog.asserts.assert(value.constructor === goog.soy.data.SanitizedHtml || value.constructor === soydata.SanitizedHtml);
		return (/** @type {!soydata.SanitizedHtml} */value
		);
	  }
	  if (value instanceof goog.html.SafeHtml) {
		return soydata.VERY_UNSAFE.ordainSanitizedHtml(goog.html.SafeHtml.unwrap(value), value.getDirection());
	  }
	  return soydata.VERY_UNSAFE.ordainSanitizedHtml(soy.esc.$$escapeHtmlHelper(String(value)), soydata.getContentDir(value));
	};

	/**
	 * Checks if the value could be used as the Soy type {html}.
	 * @param {*} value
	 * @return {boolean}
	 */
	soydata.SanitizedHtml.isCompatibleWith = function(value) {
	  return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtml || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeHtml;
	};

	/**
	 * Content of type {@link soydata.SanitizedContentKind.URI}.
	 *
	 * The content is a URI chunk that the caller knows is safe to emit in a
	 * template. The content direction is LTR.
	 *
	 * @constructor
	 * @extends {goog.soy.data.SanitizedContent}
	 */
	soydata.SanitizedUri = function() {
	  goog.soy.data.SanitizedContent.call(this); // Throws an exception.
	};
	goog.inherits(soydata.SanitizedUri, goog.soy.data.SanitizedContent);

	/** @override */
	soydata.SanitizedUri.prototype.contentKind = soydata.SanitizedContentKind.URI;

	/** @override */
	soydata.SanitizedUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

	/**
	 * Unsanitized plain text string.
	 *
	 * While all strings are effectively safe to use as a plain text, there are no
	 * guarantees about safety in any other context such as HTML. This is
	 * sometimes used to mark that should never be used unescaped.
	 *
	 * @param {*} content Plain text with no guarantees.
	 * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
	 *     unknown and thus to be estimated when necessary. Default: null.
	 * @constructor
	 * @extends {goog.soy.data.UnsanitizedText}
	 */
	soydata.UnsanitizedText = function(content, opt_contentDir) {
	  /** @override */
	  this.content = String(content);
	  this.contentDir = opt_contentDir != null ? opt_contentDir : null;
	};
	goog.inherits(soydata.UnsanitizedText, goog.soy.data.UnsanitizedText);

	/** @override */
	soydata.UnsanitizedText.prototype.contentKind = soydata.SanitizedContentKind.TEXT;

	/**
	 * Empty string, used as a type in Soy templates.
	 * @enum {string}
	 * @private
	 */
	soydata.$$EMPTY_STRING_ = {
	  VALUE: ''
	};

	/**
	 * Creates a factory for SanitizedContent types.
	 *
	 * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
	 * instantiate Sanitized* classes, without making the Sanitized* constructors
	 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
	 * helps callers and their reviewers easily tell that creating SanitizedContent
	 * is not always safe and calls for careful review.
	 *
	 * @param {function(new: T)} ctor A constructor.
	 * @return {!function(*, ?goog.i18n.bidi.Dir=): T} A factory that takes
	 *     content and an optional content direction and returns a new instance. If
	 *     the content direction is undefined, ctor.prototype.contentDir is used.
	 * @template T
	 * @private
	 */
	soydata.$$makeSanitizedContentFactory_ = function(ctor) {
	  /**
	   * @param {string} content
	   * @constructor
	   * @extends {goog.soy.data.SanitizedContent}
	   */
	  function InstantiableCtor(content) {
		/** @override */
		this.content = content;
	  }
	  InstantiableCtor.prototype = ctor.prototype;
	  /**
	   * Creates a ctor-type SanitizedContent instance.
	   *
	   * @param {*} content The content to put in the instance.
	   * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction. If
	   *     undefined, ctor.prototype.contentDir is used.
	   * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
	   *     of type T above (ctor's type, a descendant of SanitizedContent), but
	   *     there is no way to express that here.
	   */
	  function sanitizedContentFactory(content, opt_contentDir) {
		var result = new InstantiableCtor(String(content));
		if (opt_contentDir !== undefined) {
		  result.contentDir = opt_contentDir;
		}
		return result;
	  }
	  return sanitizedContentFactory;
	};

	/**
	 * Creates a factory for SanitizedContent types that should always have their
	 * default directionality.
	 *
	 * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
	 * instantiate Sanitized* classes, without making the Sanitized* constructors
	 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
	 * helps callers and their reviewers easily tell that creating SanitizedContent
	 * is not always safe and calls for careful review.
	 *
	 * @param {function(new: T, string)} ctor A constructor.
	 * @return {!function(*): T} A factory that takes content and returns a new
	 *     instance (with default directionality, i.e. ctor.prototype.contentDir).
	 * @template T
	 * @private
	 */
	soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_ = function(ctor) {
	  /**
	   * @param {string} content
	   * @constructor
	   * @extends {goog.soy.data.SanitizedContent}
	   */
	  function InstantiableCtor(content) {
		/** @override */
		this.content = content;
	  }
	  InstantiableCtor.prototype = ctor.prototype;
	  /**
	   * Creates a ctor-type SanitizedContent instance.
	   *
	   * @param {*} content The content to put in the instance.
	   * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
	   *     of type T above (ctor's type, a descendant of SanitizedContent), but
	   *     there is no way to express that here.
	   */
	  function sanitizedContentFactory(content) {
		var result = new InstantiableCtor(String(content));
		return result;
	  }
	  return sanitizedContentFactory;
	};

	// -----------------------------------------------------------------------------
	// Sanitized content ordainers. Please use these with extreme caution (with the
	// exception of markUnsanitizedText). A good recommendation is to limit usage
	// of these to just a handful of files in your source tree where usages can be
	// carefully audited.

	/**
	 * Protects a string from being used in an noAutoescaped context.
	 *
	 * This is useful for content where there is significant risk of accidental
	 * unescaped usage in a Soy template. A great case is for user-controlled
	 * data that has historically been a source of vulernabilities.
	 *
	 * @param {*} content Text to protect.
	 * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
	 *     unknown and thus to be estimated when necessary. Default: null.
	 * @return {!soydata.UnsanitizedText} A wrapper that is rejected by the
	 *     Soy noAutoescape print directive.
	 */
	soydata.markUnsanitizedText = function(content, opt_contentDir) {
	  return new soydata.UnsanitizedText(content, opt_contentDir);
	};

	soydata.VERY_UNSAFE = {};

	/**
	* Takes a leap of faith that the provided content is "safe" to use as a URI
	* in a Soy template.
	*
	* This creates a Soy SanitizedContent object which indicates to Soy there is
	* no need to escape it when printed as a URI (e.g. in an href or src
	* attribute), such as if it's already been encoded or  if it's a Javascript:
	* URI.
	*
	* @param {*} content A chunk of URI that the caller knows is safe to
	*     emit in a template.
	* @return {!soydata.SanitizedUri} Sanitized content wrapper that indicates to
	*     Soy not to escape or filter when printed in URI context.
	*/
	soydata.VERY_UNSAFE.ordainSanitizedUri = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedUri);

	// -----------------------------------------------------------------------------
	// Below are private utilities to be used by Soy-generated code only.

	/**
	 * Builds an augmented map. The returned map will contain mappings from both
	 * the base map and the additional map. If the same key appears in both, then
	 * the value from the additional map will be visible, while the value from the
	 * base map will be hidden. The base map will be used, but not modified.
	 *
	 * @param {!Object} baseMap The original map to augment.
	 * @param {!Object} additionalMap A map containing the additional mappings.
	 * @return {!Object} An augmented map containing both the original and
	 *     additional mappings.
	 */
	soy.$$augmentMap = function(baseMap, additionalMap) {
	  return soy.$$assignDefaults(soy.$$assignDefaults({}, additionalMap), baseMap);
	};

	/**
	 * Copies extra properties into an object if they do not already exist. The
	 * destination object is mutated in the process.
	 *
	 * @param {!Object} obj The destination object to update.
	 * @param {!Object} defaults An object with default properties to apply.
	 * @return {!Object} The destination object for convenience.
	 */
	soy.$$assignDefaults = function(obj, defaults) {
	  for (var key in defaults) {
		if (!(key in obj)) {
		  obj[key] = defaults[key];
		}
	  }

	  return obj;
	};

	/**
	 * Checks that the given map key is a string.
	 * @param {*} key Key to check.
	 * @return {string} The given key.
	 */
	soy.$$checkMapKey = function(key) {
	  // TODO: Support map literal with nonstring key.
	  if (typeof key != 'string') {
		throw Error('Map literal\'s key expression must evaluate to string' + ' (encountered type "' + (typeof key === 'undefined' ? 'undefined' : _typeof(key)) + '").');
	  }
	  return key;
	};

	/**
	 * Gets the keys in a map as an array. There are no guarantees on the order.
	 * @param {Object} map The map to get the keys of.
	 * @return {!Array<string>} The array of keys in the given map.
	 */
	soy.$$getMapKeys = function(map) {
	  var mapKeys = [];
	  for (var key in map) {
		mapKeys.push(key);
	  }
	  return mapKeys;
	};

	/**
	 * Returns the argument if it is not null.
	 *
	 * @param {T} val The value to check
	 * @return {T} val if is isn't null
	 * @template T
	 */
	soy.$$checkNotNull = function(val) {
	  if (val == null) {
		throw Error('unexpected null value');
	  }
	  return val;
	};

	/**
	 * Gets a consistent unique id for the given delegate template name. Two calls
	 * to this function will return the same id if and only if the input names are
	 * the same.
	 *
	 * <p> Important: This function must always be called with a string constant.
	 *
	 * <p> If Closure Compiler is not being used, then this is just this identity
	 * function. If Closure Compiler is being used, then each call to this function
	 * will be replaced with a short string constant, which will be consistent per
	 * input name.
	 *
	 * @param {string} delTemplateName The delegate template name for which to get a
	 *     consistent unique id.
	 * @return {string} A unique id that is consistent per input name.
	 *
	 * @consistentIdGenerator
	 */
	soy.$$getDelTemplateId = function(delTemplateName) {
	  return delTemplateName;
	};

	/**
	 * Map from registered delegate template key to the priority of the
	 * implementation.
	 * @type {Object}
	 * @private
	 */
	soy.$$DELEGATE_REGISTRY_PRIORITIES_ = {};

	/**
	 * Map from registered delegate template key to the implementation function.
	 * @type {Object}
	 * @private
	 */
	soy.$$DELEGATE_REGISTRY_FUNCTIONS_ = {};

	/**
	 * Registers a delegate implementation. If the same delegate template key (id
	 * and variant) has been registered previously, then priority values are
	 * compared and only the higher priority implementation is stored (if
	 * priorities are equal, an error is thrown).
	 *
	 * @param {string} delTemplateId The delegate template id.
	 * @param {string} delTemplateVariant The delegate template variant (can be
	 *     empty string).
	 * @param {number} delPriority The implementation's priority value.
	 * @param {Function} delFn The implementation function.
	 */
	soy.$$registerDelegateFn = function(delTemplateId, delTemplateVariant, delPriority, delFn) {

	  var mapKey = 'key_' + delTemplateId + ':' + delTemplateVariant;
	  var currPriority = soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey];
	  if (currPriority === undefined || delPriority > currPriority) {
		// Registering new or higher-priority function: replace registry entry.
		soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey] = delPriority;
		soy.$$DELEGATE_REGISTRY_FUNCTIONS_[mapKey] = delFn;
	  } else if (delPriority == currPriority) {
		// Registering same-priority function: error.
		throw Error('Encountered two active delegates with the same priority ("' + delTemplateId + ':' + delTemplateVariant + '").');
	  } else {
		// Registering lower-priority function: do nothing.
	  }
	};

	/**
	 * Retrieves the (highest-priority) implementation that has been registered for
	 * a given delegate template key (id and variant). If no implementation has
	 * been registered for the key, then the fallback is the same id with empty
	 * variant. If the fallback is also not registered, and allowsEmptyDefault is
	 * true, then returns an implementation that is equivalent to an empty template
	 * (i.e. rendered output would be empty string).
	 *
	 * @param {string} delTemplateId The delegate template id.
	 * @param {string} delTemplateVariant The delegate template variant (can be
	 *     empty string).
	 * @param {boolean} allowsEmptyDefault Whether to default to the empty template
	 *     function if there's no active implementation.
	 * @return {Function} The retrieved implementation function.
	 */
	soy.$$getDelegateFn = function(delTemplateId, delTemplateVariant, allowsEmptyDefault) {

	  var delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':' + delTemplateVariant];
	  if (!delFn && delTemplateVariant != '') {
		// Fallback to empty variant.
		delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':'];
	  }

	  if (delFn) {
		return delFn;
	  } else if (allowsEmptyDefault) {
		return soy.$$EMPTY_TEMPLATE_FN_;
	  } else {
		throw Error('Found no active impl for delegate call to "' + delTemplateId + ':' + delTemplateVariant + '" (and not allowemptydefault="true").');
	  }
	};

	/**
	 * Private helper soy.$$getDelegateFn(). This is the empty template function
	 * that is returned whenever there's no delegate implementation found.
	 *
	 * @param {Object<string, *>=} opt_data
	 * @param {soy.StringBuilder=} opt_sb
	 * @param {Object<string, *>=} opt_ijData
	 * @return {string}
	 * @private
	 */
	soy.$$EMPTY_TEMPLATE_FN_ = function(opt_data, opt_sb, opt_ijData) {
	  return '';
	};

	// -----------------------------------------------------------------------------
	// Basic directives/functions.

	/**
	 * Truncates a string to a given max length (if it's currently longer),
	 * optionally adding ellipsis at the end.
	 *
	 * @param {*} str The string to truncate. Can be other types, but the value will
	 *     be coerced to a string.
	 * @param {number} maxLen The maximum length of the string after truncation
	 *     (including ellipsis, if applicable).
	 * @param {boolean} doAddEllipsis Whether to add ellipsis if the string needs
	 *     truncation.
	 * @return {string} The string after truncation.
	 */
	soy.$$truncate = function(str, maxLen, doAddEllipsis) {

	  str = String(str);
	  if (str.length <= maxLen) {
		return str; // no need to truncate
	  }

	  // If doAddEllipsis, either reduce maxLen to compensate, or else if maxLen is
	  // too small, just turn off doAddEllipsis.
	  if (doAddEllipsis) {
		if (maxLen > 3) {
		  maxLen -= 3;
		} else {
		  doAddEllipsis = false;
		}
	  }

	  // Make sure truncating at maxLen doesn't cut up a unicode surrogate pair.
	  if (soy.$$isHighSurrogate_(str.charAt(maxLen - 1)) && soy.$$isLowSurrogate_(str.charAt(maxLen))) {
		maxLen -= 1;
	  }

	  // Truncate.
	  str = str.substring(0, maxLen);

	  // Add ellipsis.
	  if (doAddEllipsis) {
		str += '...';
	  }

	  return str;
	};

	/**
	 * Private helper for $$truncate() to check whether a char is a high surrogate.
	 * @param {string} ch The char to check.
	 * @return {boolean} Whether the given char is a unicode high surrogate.
	 * @private
	 */
	soy.$$isHighSurrogate_ = function(ch) {
	  return 0xD800 <= ch && ch <= 0xDBFF;
	};

	/**
	 * Private helper for $$truncate() to check whether a char is a low surrogate.
	 * @param {string} ch The char to check.
	 * @return {boolean} Whether the given char is a unicode low surrogate.
	 * @private
	 */
	soy.$$isLowSurrogate_ = function(ch) {
	  return 0xDC00 <= ch && ch <= 0xDFFF;
	};

	// -----------------------------------------------------------------------------
	// Assertion methods used by runtime.

	/**
	 * Checks if the type assertion is true if goog.asserts.ENABLE_ASSERTS is
	 * true. Report errors on runtime types if goog.DEBUG is true.
	 * @param {boolean} condition The type check condition.
	 * @param {string} paramName The Soy name of the parameter.
	 * @param {?} param The JS object for the parameter.
	 * @param {!string} jsDocTypeStr SoyDoc type str.
	 * @return {?} the param value
	 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
	 */
	soy.asserts.assertType = function(condition, paramName, param, jsDocTypeStr) {
	  if (goog.asserts.ENABLE_ASSERTS && !condition) {
		var msg = 'expected param ' + paramName + ' of type ' + jsDocTypeStr + (goog.DEBUG ? ', but got ' + goog.debug.runtimeType(param) : '') + '.';
		goog.asserts.fail(msg);
	  }
	  return param;
	};

	// -----------------------------------------------------------------------------
	// Generated code.

	// START GENERATED CODE FOR ESCAPERS.

	/**
	 * @type {function (*) : string}
	 */
	soy.esc.$$escapeHtmlHelper = function(v) {
	  return goog.string.htmlEscape(String(v));
	};

	/**
	 * Allows only data-protocol image URI's.
	 *
	 * @param {*} value The value to process. May not be a string, but the value
	 *     will be coerced to a string.
	 * @return {!soydata.SanitizedUri} An escaped version of value.
	 */
	soy.$$filterImageDataUri = function(value) {
	  // NOTE: Even if it's a SanitizedUri, we will still filter it.
	  return soydata.VERY_UNSAFE.ordainSanitizedUri(soy.esc.$$filterImageDataUriHelper(value));
	};

	/**
	 * A pattern that vets values produced by the named directives.
	 * @private {!RegExp}
	 */
	soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_ = /^data:image\/(?:bmp|gif|jpe?g|png|tiff|webp);base64,[a-z0-9+\/]+=*$/i;

	/**
	 * A helper for the Soy directive |filterImageDataUri
	 * @param {*} value Can be of any type but will be coerced to a string.
	 * @return {string} The escaped text.
	 */
	soy.esc.$$filterImageDataUriHelper = function(value) {
	  var str = String(value);
	  if (!soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_.test(str)) {
		goog.asserts.fail('Bad value `%s` for |filterImageDataUri', [str]);
		return 'data:image/gif;base64,zSoyz';
	  }
	  return str;
	};

	var incrementaldom = IncrementalDOM;
	var soyIDOM = {};

	/**
	 * Calls an expression in case of a function or outputs it as text content.
	 * @param {string|number|boolean|function()?} expr
	 */
	soyIDOM.renderDynamicContent = function(expr) {
	  if (goog.isFunction(expr)) {
		expr();
	  } else if (expr != null) {
		incrementaldom.text(expr);
	  }
	};

	/**
	 * Prints an expression depending on its type.
	 * @param {!SanitizedHtml|string|number|boolean|function()} expr
	 */
	soyIDOM.print = function(expr) {
	  if (expr instanceof soydata.SanitizedHtml) {
		// For HTML content we need to insert a custom element where we can place
		// the content without incremental dom modifying it.
		var el = incrementaldom.elementOpen('html-blob');
		var content = expr.toString();
		if (el.__innerHTML !== content) {
		  soy.renderHtml(el, expr);
		  el.__innerHTML = content;
		}
		incrementaldom.skip();
		incrementaldom.elementClose('html-blob');
	  } else {
		soyIDOM.renderDynamicContent(expr);
	  }
	};

	goog.loadModule(function () {
	  goog.module('soy.idom');
	  return soyIDOM;
	});

	// END GENERATED CODE

	goog.loadModule(function () {
	  goog.module('soy');
	  return soy;
	});

	goog.loadModule(function () {
	  goog.module('soydata');
	  return soydata;
	});

	goog.loadModule(function () {
	  goog.module('soy.asserts');
	  return soy;
	});
})();

goog.loadModule(function () {
	goog.module('incrementaldom');
	return IncrementalDOM;
});
}).call(typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HTMLParser = __webpack_require__(58);

var _HTMLParser2 = _interopRequireDefault(_HTMLParser);

var _unescape = __webpack_require__(59);

var _unescape2 = _interopRequireDefault(_unescape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parser_ = void 0;

var HTML2IncDom = function() {
	function HTML2IncDom() {
		_classCallCheck(this, HTML2IncDom);
	}

	_createClass(HTML2IncDom, null, [{
		key: 'buildFn',

		/**
* Should convert the given html string to a function with calls to
* incremental dom methods.
* @param {string} html
* @return {!function()} Function with incremental dom calls for building
*     the given html string.
*/
		value: function buildFn(html) {
			return function() {
				return HTML2IncDom.run(html);
			};
		}

		/**
* Gets the html parser being currently used.
* @return {!function()}
*/

	}, {
		key: 'getParser',
		value: function getParser() {
			return parser_ || _HTMLParser2.default;
		}

		/**
* Should convert the given html string to calls to incremental dom methods.
* @param {string} html
*/

	}, {
		key: 'run',
		value: function run(html) {
			HTML2IncDom.getParser()(html, {
				start: function start(tag, attrs, unary) {
					var fn = unary ? IncrementalDOM.elementVoid : IncrementalDOM.elementOpen;
					var args = [tag, null, []];
					for (var i = 0; i < attrs.length; i++) {
						args.push(attrs[i].name, attrs[i].value);
					}
					fn.apply(undefined, args);
				},

				end: function end(tag) {
					IncrementalDOM.elementClose(tag);
				},

				chars: function chars(text) {
					IncrementalDOM.text(text, _unescape2.default);
				}
			});
		}

		/**
* Changes the function that will be used to parse html strings. By default
* this will use the `HTMLParser` function from
* https://github.com/blowsie/Pure-JavaScript-HTML5-Parser. This will accept
* any function that follows that same api, basically accepting the html
* string and an object with `start`, `end` and `chars` functions to be called
* during the parsing.
* @param {!function(string, !Object)} newParser
*/

	}, {
		key: 'setParser',
		value: function setParser(newParser) {
			parser_ = newParser;
		}
	}]);

	return HTML2IncDom;
}();

exports.default = HTML2IncDom;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
/* eslint-disable */

/*
 * HTML5 Parser By Sam Blowes
 *
 * Designed for HTML5 documents
 *
 * Original code by John Resig (ejohn.org)
 * http://ejohn.org/blog/pure-javascript-html-parser/
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * ----------------------------------------------------------------------------
 * License
 * ----------------------------------------------------------------------------
 *
 * This code is triple licensed using Apache Software License 2.0,
 * Mozilla Public License or GNU Public License
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is Simple HTML Parser.
 *
 * The Initial Developer of the Original Code is Erik Arvidsson.
 * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights
 * Reserved.
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * @license
 */

/*
 *
 * ----------------------------------------------------------------------------
 * Usage
 * ----------------------------------------------------------------------------
 *
 * // Use like so:
 * HTMLParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * // or to get an XML string:
 * HTMLtoXML(htmlString);
 *
 * // or to get an XML DOM Document
 * HTMLtoDOM(htmlString);
 *
 * // or to inject into an existing document/DOM node
 * HTMLtoDOM(htmlString, document);
 * HTMLtoDOM(htmlString, document.body);
 *
 */

// Regular Expressions for parsing tags and attributes
var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
	endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/,
	attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;

// Empty Elements - HTML 5
var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,link,meta,param,embed,command,keygen,source,track,wbr');

// Block Elements - HTML 5
var block = makeMap('a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video');

// Inline Elements - HTML 5
var inline = makeMap('abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');

// Attributes that have their values filled in disabled="disabled"
var fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected');

// Special Elements (can contain anything)
var special = makeMap('script,style');

var HTMLParser = function HTMLParser(html, handler) {
	var index,
		chars,
		match,
		stack = [],
		last = html;
	stack.last = function() {
		return this[this.length - 1];
	};

	while (html) {
		chars = true;

		// Make sure we're not in a script or style element
		if (!stack.last() || !special[stack.last()]) {
			// Comment
			if (html.indexOf('<!--') == 0) {
				index = html.indexOf('-->');

				if (index >= 0) {
					if (handler.comment) handler.comment(html.substring(4, index));
					html = html.substring(index + 3);
					chars = false;
				}

				// end tag
			} else if (html.indexOf('</') == 0) {
				match = html.match(endTag);

				if (match) {
					html = html.substring(match[0].length);
					match[0].replace(endTag, parseEndTag);
					chars = false;
				}

				// start tag
			} else if (html.indexOf('<') == 0) {
				match = html.match(startTag);

				if (match) {
					html = html.substring(match[0].length);
					match[0].replace(startTag, parseStartTag);
					chars = false;
				}
			}

			if (chars) {
				index = html.indexOf('<');

				var text = index < 0 ? html : html.substring(0, index);
				html = index < 0 ? '' : html.substring(index);

				if (handler.chars) handler.chars(text);
			}
		} else {
			html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function(all, text) {
				text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
				if (handler.chars) handler.chars(text);

				return '';
			});

			parseEndTag('', stack.last());
		}

		if (html == last) throw 'Parse Error: ' + html;
		last = html;
	}

	// Clean up any remaining tags
	parseEndTag();

	function parseStartTag(tag, tagName, rest, unary) {
		tagName = tagName.toLowerCase();

		if (block[tagName]) {
			// Close last tag if it's inline, except if it's a "span" (since people
			// usually add anything they want to spans, and browsers allow it).
			// Note: this exception for "span" was added manually (i.e. it's not
			// present in the original code).
			while (stack.last() && inline[stack.last()] && stack.last() !== 'span') {
				parseEndTag('', stack.last());
			}
		}

		if (closeSelf[tagName] && stack.last() == tagName) {
			parseEndTag('', tagName);
		}

		unary = empty[tagName] || !!unary;

		if (!unary) stack.push(tagName);

		if (handler.start) {
			var attrs = [];

			rest.replace(attr, function(match, name) {
				var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : '';

				attrs.push({
					name: name,
					value: value,
					escaped: value.replace(/(^|[^\\])"/g, '$1\\"') //"
				});
			});

			if (handler.start) handler.start(tagName, attrs, unary);
		}
	}

	function parseEndTag(tag, tagName) {
		// If no tag name is provided, clean shop
		if (!tagName) var pos = 0;else
			// Find the closest opened tag of the same type
			for (var pos = stack.length - 1; pos >= 0; pos--) {
				if (stack[pos] == tagName) break;
			}if (pos >= 0) {
			// Close all the open elements, up the stack
			for (var i = stack.length - 1; i >= pos; i--) {
				if (handler.end) handler.end(stack[i]);
			} // Remove the open elements from the stack
			stack.length = pos;
		}
	}
};

function makeMap(str) {
	var obj = {},
		items = str.split(',');
	for (var i = 0; i < items.length; i++) {
		obj[items[i]] = true;
	}return obj;
}

exports.default = HTMLParser;

/* eslint-enable */

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} The unescaped {@code str} string.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
function unescape(str) {
	/** @type {!Object<string, string>} */
	var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
	var div = document.createElement('div');

	// Match as many valid entity characters as possible. If the actual entity
	// happens to be shorter, it will still work as innerHTML will return the
	// trailing characters unchanged. Since the entity characters do not include
	// open angle bracket, there is no chance of XSS from the innerHTML use.
	// Since no whitespace is passed to innerHTML, whitespace is preserved.
	return str.replace(HTML_ENTITY_PATTERN_, function(s, entity) {
		// Check for cached entity.
		var value = seen[s];
		if (value) {
			return value;
		}
		// Check for numeric entity.
		if (entity.charAt(0) === '#') {
			// Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
			var n = Number('0' + entity.substr(1));
			if (!isNaN(n)) {
				value = String.fromCharCode(n);
			}
		}
		// Fall back to innerHTML otherwise.
		if (!value) {
			// Append a non-entity character to avoid a bug in Webkit that parses
			// an invalid entity at the end of innerHTML text as the empty string.
			div.innerHTML = s + ' ';
			// Then remove the trailing character from the result.
			value = div.firstChild.nodeValue.slice(0, -1);
		}
		// Cache and return.
		seen[s] = value;
		return value;
	});
}

exports.default = unescape;

/**
 * Regular expression that matches an HTML entity.
 * @type {!RegExp}
 */

var HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(27);

var _changes = __webpack_require__(28);

var _data = __webpack_require__(9);

var _children = __webpack_require__(29);

var _patch2 = __webpack_require__(63);

var _render = __webpack_require__(31);

var _metalComponent = __webpack_require__(2);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IncrementalDomRenderer = function(_ComponentRenderer$co) {
	_inherits(IncrementalDomRenderer, _ComponentRenderer$co);

	function IncrementalDomRenderer() {
		_classCallCheck(this, IncrementalDomRenderer);

		return _possibleConstructorReturn(this, (IncrementalDomRenderer.__proto__ || Object.getPrototypeOf(IncrementalDomRenderer)).apply(this, arguments));
	}

	_createClass(IncrementalDomRenderer, [{
		key: 'buildShouldUpdateArgs',

		/**
* Returns an array with the args that should be passed to the component's
* `shouldUpdate` method. This can be overridden by sub classes to change
* what the method should receive.
* @param {Object} changes
* @return {!Array}
*/
		value: function buildShouldUpdateArgs(changes) {
			return [changes.props];
		}

		/**
* @inheritDoc
*/

	}, {
		key: 'dispose',
		value: function dispose(component) {
			var data = (0, _data.getData)(component);
			var ref = data.config.ref;
			var owner = data.owner;
			if (owner && owner.components && owner.components[ref] === component) {
				delete owner.components[ref];
			}

			if (data.childComponents) {
				for (var i = 0; i < data.childComponents.length; i++) {
					var child = data.childComponents[i];
					if (!child.isDisposed()) {
						if (!child.portalElement) {
							child.element = null;
						}
						child.dispose();
					}
				}
			}

			(0, _data.clearData)(component);
		}

		/**
* Generates a key for the element currently being rendered in the given
* component. By default, just returns the original key. Sub classes can
* override this to change the behavior.
* @param {!Component} component
* @param {string} key
* @return {?string}
*/

	}, {
		key: 'generateKey',
		value: function generateKey(component, key) {
			return key;
		}

		/**
* Get the component's config data.
* @param {!Component} component
* @return {!Object}
*/

	}, {
		key: 'getConfig',
		value: function getConfig(component) {
			return (0, _data.getData)(component).config;
		}

		/**
* Get the component's incremental dom renderer data.
* @param {!Component} component
* @return {!Object}
*/

	}, {
		key: 'getData',
		value: function getData(component) {
			return (0, _data.getData)(component);
		}

		/**
* Gets the component that triggered the current patch operation.
* @return {Component}
*/

	}, {
		key: 'getPatchingComponent',
		value: function getPatchingComponent() {
			return (0, _patch2.getPatchingComponent)();
		}

		/**
* Handles a node having just been rendered. Sub classes should override this
* for custom behavior.
*/

	}, {
		key: 'handleNodeRendered',
		value: function handleNodeRendered() {}

		/**
* Checks if the given object is an incremental dom node.
* @param {!Object} node
* @return {boolean}
*/

	}, {
		key: 'isIncDomNode',
		value: function isIncDomNode(node) {
			return !!(0, _children.getOwner)(node);
		}

		/**
* Calls incremental dom's patch function to render the component.
* @param {!Component} component
*/

	}, {
		key: 'patch',
		value: function patch(component) {
			(0, _patch2.patch)(component);
		}

		/**
* Renders the renderer's component for the first time, patching its element
* through incremental dom function calls. If the first arg is a function
* instead of a component instance, creates and renders this function, which
* can either be a simple incremental dom function or a component constructor.
* @param {!Component|function()} component Can be a component instance, a
*     simple incremental dom function or a component constructor.
* @param {Object|Element=} dataOrElement Optional config data for the
*     function, or parent for the rendered content.
* @param {Element=} parent Optional parent for the rendered content.
* @return {!Component} The rendered component's instance.
*/

	}, {
		key: 'render',
		value: function render(component, dataOrElement, parent) {
			if (component[_metalComponent.Component.COMPONENT_FLAG]) {
				this.patch(component);
			} else {
				return (0, _render.renderFunction)(this, component, dataOrElement, parent);
			}
		}

		/**
* Renders the given child node via its owner renderer.
* @param {!Object} child
*/

	}, {
		key: 'renderChild',
		value: function renderChild(child) {
			(0, _render.renderChild)(child);
		}

		/**
* Calls functions from `IncrementalDOM` to build the component element's
* content. Can be overriden by subclasses (for integration with template
* engines for example).
* @param {!Component} component
*/

	}, {
		key: 'renderIncDom',
		value: function renderIncDom(component) {
			if (component.render) {
				component.render();
			} else {
				IncrementalDOM.elementVoid('div');
			}
		}

		/**
* Runs the incremental dom functions for rendering this component, without
* calling `patch`. This function needs to be called inside a `patch`.
* @param {!Component} component
*/

	}, {
		key: 'renderInsidePatch',
		value: function renderInsidePatch(component) {
			var changes = (0, _changes.getChanges)(component);

			var shouldRender = !component.wasRendered || this.shouldUpdate(component, changes) || IncrementalDOM.currentPointer() !== component.element;
			if (shouldRender) {
				this.willUpdate_(component, changes);

				(0, _render.render)(component);
			} else if (component.element) {
				this.skipRender();
			}
		}

		/**
* Sets up this component to be used by this renderer.
* @param {!Component} component
*/

	}, {
		key: 'setUp',
		value: function setUp(component) {
			component.context = {};
			component.components = {};
			component.refs = {};

			var data = (0, _data.getData)(component);
			data.config = component.getInitialConfig();
			(0, _changes.trackChanges)(component);
		}

		/**
* Checks if the component should be updated with the current state changes.
* @param {!Component} component
* @param {Object} changes
* @return {boolean}
*/

	}, {
		key: 'shouldUpdate',
		value: function shouldUpdate(component, changes) {
			if (!changes) {
				return false;
			}
			if (component.shouldUpdate) {
				return component.shouldUpdate.apply(component, _toConsumableArray(this.buildShouldUpdateArgs(changes))); // eslint-disable-line
			}
			return true;
		}

		/**
* Skips the next disposal of children components, by clearing the array as
* if there were no children rendered the last time. This can be useful for
* allowing components to be reused by other parent components in separate
* render update cycles.
* @param {!Component} component
*/

	}, {
		key: 'skipNextChildrenDisposal',
		value: function skipNextChildrenDisposal(component) {
			(0, _data.getData)(component).childComponents = null;
		}

		/**
* Skips rendering the current node.
*/

	}, {
		key: 'skipRender',
		value: function skipRender() {
			IncrementalDOM.skipNode();
		}

		/**
* Updates the renderer's component when state changes, patching its element
* through incremental dom function calls.
* @param {!Component} component
* @param {Object} data
*/

	}, {
		key: 'update',
		value: function update(component, data) {
			var changes = (0, _changes.getChanges)(component);
			if (data.forceUpdate || this.shouldUpdate(component, changes)) {
				this.willUpdate_(component, changes);
				this.patch(component);
			}
		}

		/**
* Invokes component's "willUpdate" lifecycle method if applicable.
* @param {!Component} component
* @param {Object} changes
*/

	}, {
		key: 'willUpdate_',
		value: function willUpdate_(component, changes) {
			if (!component.wasRendered || !changes) {
				return;
			}
			component.informWillUpdate.apply(component, _toConsumableArray(this.buildShouldUpdateArgs(changes)));
		}
	}]);

	return IncrementalDomRenderer;
}(_metalComponent.ComponentRenderer.constructor);

var renderer = new IncrementalDomRenderer();

// Name of this renderer. Renderers should provide this as a way to identify
// them via a simple string (when calling enableCompatibilityMode to add
// support to old features for specific renderers for example).
renderer.RENDERER_NAME = 'incremental-dom';

exports.default = renderer;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A cached reference to the hasOwnProperty function.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * A constructor function that will create blank objects.
 * @constructor
 */
function Blank() {}

Blank.prototype = Object.create(null);

/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param {!Object<string, *>} map The map to check.
 * @param {string} property The property to check.
 * @return {boolean} Whether map has property.
 */
var has = function(map, property) {
return hasOwnProperty.call(map, property);
};

/**
 * Creates an map object without a prototype.
 * @return {!Object}
 */
var createMap = function() {
return new Blank();
};

/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 * @param {!string} nodeName
 * @param {?string=} key
 * @constructor
 */
function NodeData(nodeName, key) {
/**
* The attributes and their values.
* @const {!Object<string, *>}
*/
this.attrs = createMap();

/**
* An array of attribute name/value pairs, used for quickly diffing the
* incomming attributes to see if the DOM node's attributes need to be
* updated.
* @const {Array<*>}
*/
this.attrsArr = [];

/**
* The incoming attributes for this Node, before they are updated.
* @const {!Object<string, *>}
*/
this.newAttrs = createMap();

/**
* Whether or not the statics have been applied for the node yet.
* {boolean}
*/
this.staticsApplied = false;

/**
* The key used to identify this node, used to preserve DOM nodes when they
* move within their parent.
* @const
*/
this.key = key;

/**
* Keeps track of children within this node by their key.
* {!Object<string, !Element>}
*/
this.keyMap = createMap();

/**
* Whether or not the keyMap is currently valid.
* @type {boolean}
*/
this.keyMapValid = true;

/**
* Whether or the associated node is, or contains, a focused Element.
* @type {boolean}
*/
this.focused = false;

/**
* The node name for this node.
* @const {string}
*/
this.nodeName = nodeName;

/**
* @type {?string}
*/
this.text = null;
}

/**
 * Initializes a NodeData object for a Node.
 *
 * @param {Node} node The node to initialize data for.
 * @param {string} nodeName The node name of node.
 * @param {?string=} key The key that identifies the node.
 * @return {!NodeData} The newly initialized data object
 */
var initData = function(node, nodeName, key) {
var data = new NodeData(nodeName, key);
node['__incrementalDOMData'] = data;
return data;
};

/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 *
 * @param {?Node} node The Node to retrieve the data for.
 * @return {!NodeData} The NodeData for this Node.
 */
var getData = function(node) {
importNode(node);
return node['__incrementalDOMData'];
};

/**
 * Imports node and its subtree, initializing caches.
 *
 * @param {?Node} node The Node to import.
 */
var importNode = function(node) {
if (node['__incrementalDOMData']) {
	return;
}

var isElement = node instanceof Element;
var nodeName = isElement ? node.localName : node.nodeName;
var key = isElement ? node.getAttribute('key') : null;
var data = initData(node, nodeName, key);

if (key) {
	getData(node.parentNode).keyMap[key] = node;
}

if (isElement) {
	var attributes = node.attributes;
	var attrs = data.attrs;
	var newAttrs = data.newAttrs;
	var attrsArr = data.attrsArr;

	for (var i = 0; i < attributes.length; i += 1) {
	  var attr = attributes[i];
	  var name = attr.name;
	  var value = attr.value;

	  attrs[name] = value;
	  newAttrs[name] = undefined;
	  attrsArr.push(name);
	  attrsArr.push(value);
	}
}

for (var child = node.firstChild; child; child = child.nextSibling) {
	importNode(child);
}
};

/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @param {?Node} parent
 * @return {?string} The namespace to create the tag in.
 */
var getNamespaceForTag = function(tag, parent) {
if (tag === 'svg') {
	return 'http://www.w3.org/2000/svg';
}

if (getData(parent).nodeName === 'foreignObject') {
	return null;
}

return parent.namespaceURI;
};

/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {?Node} parent
 * @param {string} tag The tag for the Element.
 * @param {?string=} key A key to identify the Element.
 * @return {!Element}
 */
var createElement = function(doc, parent, tag, key) {
var namespace = getNamespaceForTag(tag, parent);
var el = undefined;

if (namespace) {
	el = doc.createElementNS(namespace, tag);
} else {
	el = doc.createElement(tag);
}

initData(el, tag, key);

return el;
};

/**
 * Creates a Text Node.
 * @param {Document} doc The document with which to create the Element.
 * @return {!Text}
 */
var createText = function(doc) {
var node = doc.createTextNode('');
initData(node, '#text', null);
return node;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
var notifications = {
/**
* Called after patch has compleated with any Nodes that have been created
* and added to the DOM.
* @type {?function(Array<!Node>)}
*/
nodesCreated: null,

/**
* Called after patch has compleated with any Nodes that have been removed
* from the DOM.
* Note it's an applications responsibility to handle any childNodes.
* @type {?function(Array<!Node>)}
*/
nodesDeleted: null
};

/**
 * Keeps track of the state of a patch.
 * @constructor
 */
function Context() {
/**
* @type {(Array<!Node>|undefined)}
*/
this.created = notifications.nodesCreated && [];

/**
* @type {(Array<!Node>|undefined)}
*/
this.deleted = notifications.nodesDeleted && [];
}

/**
 * @param {!Node} node
 */
Context.prototype.markCreated = function(node) {
if (this.created) {
	this.created.push(node);
}
};

/**
 * @param {!Node} node
 */
Context.prototype.markDeleted = function(node) {
if (this.deleted) {
	this.deleted.push(node);
}
};

/**
 * Notifies about nodes that were created during the patch opearation.
 */
Context.prototype.notifyChanges = function() {
if (this.created && this.created.length > 0) {
	notifications.nodesCreated(this.created);
}

if (this.deleted && this.deleted.length > 0) {
	notifications.nodesDeleted(this.deleted);
}
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
* Keeps track whether or not we are in an attributes declaration (after
* elementOpenStart, but before elementOpenEnd).
* @type {boolean}
*/
var inAttributes = false;

/**
* Keeps track whether or not we are in an element that should not have its
* children cleared.
* @type {boolean}
*/
var inSkip = false;

/**
 * Makes sure that there is a current patch context.
 * @param {string} functionName
 * @param {*} context
 */
var assertInPatch = function(functionName, context) {
if (!context) {
	throw new Error('Cannot call ' + functionName + '() unless in patch.');
}
};

/**
 * Makes sure that a patch closes every node that it opened.
 * @param {?Node} openElement
 * @param {!Node|!DocumentFragment} root
 */
var assertNoUnclosedTags = function(openElement, root) {
if (openElement === root) {
	return;
}

var currentElement = openElement;
var openTags = [];
while (currentElement && currentElement !== root) {
	openTags.push(currentElement.nodeName.toLowerCase());
	currentElement = currentElement.parentNode;
}

throw new Error('One or more tags were not closed:\n' + openTags.join('\n'));
};

/**
 * Makes sure that the caller is not where attributes are expected.
 * @param {string} functionName
 */
var assertNotInAttributes = function(functionName) {
if (inAttributes) {
	throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');
}
};

/**
 * Makes sure that the caller is not inside an element that has declared skip.
 * @param {string} functionName
 */
var assertNotInSkip = function(functionName) {
if (inSkip) {
	throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');
}
};

/**
 * Makes sure that the caller is where attributes are expected.
 * @param {string} functionName
 */
var assertInAttributes = function(functionName) {
if (!inAttributes) {
	throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');
}
};

/**
 * Makes sure the patch closes virtual attributes call
 */
var assertVirtualAttributesClosed = function() {
if (inAttributes) {
	throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');
}
};

/**
* Makes sure that tags are correctly nested.
* @param {string} nodeName
* @param {string} tag
*/
var assertCloseMatchesOpenTag = function(nodeName, tag) {
if (nodeName !== tag) {
	throw new Error('Received a call to close "' + tag + '" but "' + nodeName + '" was open.');
}
};

/**
 * Makes sure that no children elements have been declared yet in the current
 * element.
 * @param {string} functionName
 * @param {?Node} previousNode
 */
var assertNoChildrenDeclaredYet = function(functionName, previousNode) {
if (previousNode !== null) {
	throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');
}
};

/**
 * Checks that a call to patchOuter actually patched the element.
 * @param {?Node} startNode The value for the currentNode when the patch
 *     started.
 * @param {?Node} currentNode The currentNode when the patch finished.
 * @param {?Node} expectedNextNode The Node that is expected to follow the
 *    currentNode after the patch;
 * @param {?Node} expectedPrevNode The Node that is expected to preceed the
 *    currentNode after the patch.
 */
var assertPatchElementNoExtras = function(startNode, currentNode, expectedNextNode, expectedPrevNode) {
var wasUpdated = currentNode.nextSibling === expectedNextNode && currentNode.previousSibling === expectedPrevNode;
var wasChanged = currentNode.nextSibling === startNode.nextSibling && currentNode.previousSibling === expectedPrevNode;
var wasRemoved = currentNode === startNode;

if (!wasUpdated && !wasChanged && !wasRemoved) {
	throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');
}
};

/**
 * Updates the state of being in an attribute declaration.
 * @param {boolean} value
 * @return {boolean} the previous value.
 */
var setInAttributes = function(value) {
var previous = inAttributes;
inAttributes = value;
return previous;
};

/**
 * Updates the state of being in a skip element.
 * @param {boolean} value
 * @return {boolean} the previous value.
 */
var setInSkip = function(value) {
var previous = inSkip;
inSkip = value;
return previous;
};

/**
 * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {!Node} node
 * @return {boolean} True if the node the root of a document, false otherwise.
 */
var isDocumentRoot = function(node) {
// For ShadowRoots, check if they are a DocumentFragment instead of if they
// are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are
// not supported.
return node instanceof Document || node instanceof DocumentFragment;
};

/**
 * @param {!Node} node The node to start at, inclusive.
 * @param {?Node} root The root ancestor to get until, exclusive.
 * @return {!Array<!Node>} The ancestry of DOM nodes.
 */
var getAncestry = function(node, root) {
var ancestry = [];
var cur = node;

while (cur !== root) {
	ancestry.push(cur);
	cur = cur.parentNode;
}

return ancestry;
};

/**
 * @param {!Node} node
 * @return {!Node} The root node of the DOM tree that contains node.
 */
var getRoot = function(node) {
var cur = node;
var prev = cur;

while (cur) {
	prev = cur;
	cur = cur.parentNode;
}

return prev;
};

/**
 * @param {!Node} node The node to get the activeElement for.
 * @return {?Element} The activeElement in the Document or ShadowRoot
 *     corresponding to node, if present.
 */
var getActiveElement = function(node) {
var root = getRoot(node);
return isDocumentRoot(root) ? root.activeElement : null;
};

/**
 * Gets the path of nodes that contain the focused node in the same document as
 * a reference node, up until the root.
 * @param {!Node} node The reference node to get the activeElement for.
 * @param {?Node} root The root to get the focused path until.
 * @return {!Array<Node>}
 */
var getFocusedPath = function(node, root) {
var activeElement = getActiveElement(node);

if (!activeElement || !node.contains(activeElement)) {
	return [];
}

return getAncestry(activeElement, root);
};

/**
 * Like insertBefore, but instead instead of moving the desired node, instead
 * moves all the other nodes after.
 * @param {?Node} parentNode
 * @param {!Node} node
 * @param {?Node} referenceNode
 */
var moveBefore = function(parentNode, node, referenceNode) {
var insertReferenceNode = node.nextSibling;
var cur = referenceNode;

while (cur !== node) {
	var next = cur.nextSibling;
	parentNode.insertBefore(cur, insertReferenceNode);
	cur = next;
}
};

/** @type {?Context} */
var context = null;

/** @type {?Node} */
var currentNode = null;

/** @type {?Node} */
var currentParent = null;

/** @type {?Document} */
var doc = null;

/**
 * @param {!Array<Node>} focusPath The nodes to mark.
 * @param {boolean} focused Whether or not they are focused.
 */
var markFocused = function(focusPath, focused) {
for (var i = 0; i < focusPath.length; i += 1) {
	getData(focusPath[i]).focused = focused;
}
};

/**
 * Returns a patcher function that sets up and restores a patch context,
 * running the run function with the provided data.
 * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run
 * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}
 * @template T
 */
var patchFactory = function(run) {
/**
* TODO(moz): These annotations won't be necessary once we switch to Closure
* Compiler's new type inference. Remove these once the switch is done.
*
* @param {(!Element|!DocumentFragment)} node
* @param {!function(T)} fn
* @param {T=} data
* @return {?Node} node
* @template T
*/
var f = function(node, fn, data) {
	var prevContext = context;
	var prevDoc = doc;
	var prevCurrentNode = currentNode;
	var prevCurrentParent = currentParent;
	var previousInAttributes = false;
	var previousInSkip = false;

	context = new Context();
	doc = node.ownerDocument;
	currentParent = node.parentNode;

	if (process.env.NODE_ENV !== 'production') {
	  previousInAttributes = setInAttributes(false);
	  previousInSkip = setInSkip(false);
	}

	var focusPath = getFocusedPath(node, currentParent);
	markFocused(focusPath, true);
	var retVal = run(node, fn, data);
	markFocused(focusPath, false);

	if (process.env.NODE_ENV !== 'production') {
	  assertVirtualAttributesClosed();
	  setInAttributes(previousInAttributes);
	  setInSkip(previousInSkip);
	}

	context.notifyChanges();

	context = prevContext;
	doc = prevDoc;
	currentNode = prevCurrentNode;
	currentParent = prevCurrentParent;

	return retVal;
};
return f;
};

/**
 * Patches the document starting at node with the provided function. This
 * function may be called during an existing patch operation.
 * @param {!Element|!DocumentFragment} node The Element or Document
 *     to patch.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {!Node} The patched node.
 * @template T
 */
var patchInner = patchFactory(function (node, fn, data) {
currentNode = node;

enterNode();
fn(data);
exitNode();

if (process.env.NODE_ENV !== 'production') {
	assertNoUnclosedTags(currentNode, node);
}

return node;
});

/**
 * Patches an Element with the the provided function. Exactly one top level
 * element call should be made corresponding to `node`.
 * @param {!Element} node The Element where the patch should start.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM. This should have at most one top level
 *     element call.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {?Node} The node if it was updated, its replacedment or null if it
 *     was removed.
 * @template T
 */
var patchOuter = patchFactory(function (node, fn, data) {
var startNode = /** @type {!Element} */{ nextSibling: node };
var expectedNextNode = null;
var expectedPrevNode = null;

if (process.env.NODE_ENV !== 'production') {
	expectedNextNode = node.nextSibling;
	expectedPrevNode = node.previousSibling;
}

currentNode = startNode;
fn(data);

if (process.env.NODE_ENV !== 'production') {
	assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);
}

if (node !== currentNode && node.parentNode) {
	removeChild(currentParent, node, getData(currentParent).keyMap);
}

return startNode === currentNode ? null : currentNode;
});

/**
 * Checks whether or not the current node matches the specified nodeName and
 * key.
 *
 * @param {!Node} matchNode A node to match the data to.
 * @param {?string} nodeName The nodeName for this node.
 * @param {?string=} key An optional key that identifies a node.
 * @return {boolean} True if the node matches, false otherwise.
 */
var matches = function(matchNode, nodeName, key) {
var data = getData(matchNode);

// Key check is done using double equals as we want to treat a null key the
// same as undefined. This should be okay as the only values allowed are
// strings, null and undefined so the == semantics are not too weird.
return nodeName === data.nodeName && key == data.key;
};

/**
 * Aligns the virtual Element definition with the actual DOM, moving the
 * corresponding DOM node to the correct location or creating it if necessary.
 * @param {string} nodeName For an Element, this should be a valid tag string.
 *     For a Text, this should be #text.
 * @param {?string=} key The key used to identify this element.
 */
var alignWithDOM = function(nodeName, key) {
if (currentNode && matches(currentNode, nodeName, key)) {
	return;
}

var parentData = getData(currentParent);
var currentNodeData = currentNode && getData(currentNode);
var keyMap = parentData.keyMap;
var node = undefined;

// Check to see if the node has moved within the parent.
if (key) {
	var keyNode = keyMap[key];
	if (keyNode) {
	  if (matches(keyNode, nodeName, key)) {
		node = keyNode;
	  } else if (keyNode === currentNode) {
		context.markDeleted(keyNode);
	  } else {
		removeChild(currentParent, keyNode, keyMap);
	  }
	}
}

// Create the node if it doesn't exist.
if (!node) {
	if (nodeName === '#text') {
	  node = createText(doc);
	} else {
	  node = createElement(doc, currentParent, nodeName, key);
	}

	if (key) {
	  keyMap[key] = node;
	}

	context.markCreated(node);
}

// Re-order the node into the right position, preserving focus if either
// node or currentNode are focused by making sure that they are not detached
// from the DOM.
if (getData(node).focused) {
	// Move everything else before the node.
	moveBefore(currentParent, node, currentNode);
} else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {
	// Remove the currentNode, which can always be added back since we hold a
	// reference through the keyMap. This prevents a large number of moves when
	// a keyed item is removed or moved backwards in the DOM.
	currentParent.replaceChild(node, currentNode);
	parentData.keyMapValid = false;
} else {
	currentParent.insertBefore(node, currentNode);
}

currentNode = node;
};

/**
 * @param {?Node} node
 * @param {?Node} child
 * @param {?Object<string, !Element>} keyMap
 */
var removeChild = function(node, child, keyMap) {
node.removeChild(child);
context.markDeleted( /** @type {!Node}*/child);

var key = getData(child).key;
if (key) {
	delete keyMap[key];
}
};

/**
 * Clears out any unvisited Nodes, as the corresponding virtual element
 * functions were never called for them.
 */
var clearUnvisitedDOM = function() {
var node = currentParent;
var data = getData(node);
var keyMap = data.keyMap;
var keyMapValid = data.keyMapValid;
var child = node.lastChild;
var key = undefined;

if (child === currentNode && keyMapValid) {
	return;
}

while (child !== currentNode) {
	removeChild(node, child, keyMap);
	child = node.lastChild;
}

// Clean the keyMap, removing any unusued keys.
if (!keyMapValid) {
	for (key in keyMap) {
	  child = keyMap[key];
	  if (child.parentNode !== node) {
		context.markDeleted(child);
		delete keyMap[key];
	  }
	}

	data.keyMapValid = true;
}
};

/**
 * Changes to the first child of the current node.
 */
var enterNode = function() {
currentParent = currentNode;
currentNode = null;
};

/**
 * @return {?Node} The next Node to be patched.
 */
var getNextNode = function() {
if (currentNode) {
	return currentNode.nextSibling;
} else {
	return currentParent.firstChild;
}
};

/**
 * Changes to the next sibling of the current node.
 */
var nextNode = function() {
currentNode = getNextNode();
};

/**
 * Changes to the parent of the current node, removing any unvisited children.
 */
var exitNode = function() {
clearUnvisitedDOM();

currentNode = currentParent;
currentParent = currentParent.parentNode;
};

/**
 * Makes sure that the current node is an Element with a matching tagName and
 * key.
 *
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @return {!Element} The corresponding Element.
 */
var coreElementOpen = function(tag, key) {
nextNode();
alignWithDOM(tag, key);
enterNode();
return (/** @type {!Element} */currentParent
);
};

/**
 * Closes the currently open Element, removing any unvisited children if
 * necessary.
 *
 * @return {!Element} The corresponding Element.
 */
var coreElementClose = function() {
if (process.env.NODE_ENV !== 'production') {
	setInSkip(false);
}

exitNode();
return (/** @type {!Element} */currentNode
);
};

/**
 * Makes sure the current node is a Text node and creates a Text node if it is
 * not.
 *
 * @return {!Text} The corresponding Text Node.
 */
var coreText = function() {
nextNode();
alignWithDOM('#text', null);
return (/** @type {!Text} */currentNode
);
};

/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
var currentElement = function() {
if (process.env.NODE_ENV !== 'production') {
	assertInPatch('currentElement', context);
	assertNotInAttributes('currentElement');
}
return (/** @type {!Element} */currentParent
);
};

/**
 * @return {Node} The Node that will be evaluated for the next instruction.
 */
var currentPointer = function() {
if (process.env.NODE_ENV !== 'production') {
	assertInPatch('currentPointer', context);
	assertNotInAttributes('currentPointer');
}
return getNextNode();
};

/**
 * Skips the children in a subtree, allowing an Element to be closed without
 * clearing out the children.
 */
var skip = function() {
if (process.env.NODE_ENV !== 'production') {
	assertNoChildrenDeclaredYet('skip', currentNode);
	setInSkip(true);
}
currentNode = currentParent.lastChild;
};

/**
 * Skips the next Node to be patched, moving the pointer forward to the next
 * sibling of the current pointer.
 */
var skipNode = nextNode;

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
var symbols = {
default: '__default'
};

/**
 * @param {string} name
 * @return {string|undefined} The namespace to use for the attribute.
 */
var getNamespace = function(name) {
if (name.lastIndexOf('xml:', 0) === 0) {
	return 'http://www.w3.org/XML/1998/namespace';
}

if (name.lastIndexOf('xlink:', 0) === 0) {
	return 'http://www.w3.org/1999/xlink';
}
};

/**
 * Applies an attribute or property to a given Element. If the value is null
 * or undefined, it is removed from the Element. Otherwise, the value is set
 * as an attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {?(boolean|number|string)=} value The attribute's value.
 */
var applyAttr = function(el, name, value) {
if (value == null) {
	el.removeAttribute(name);
} else {
	var attrNS = getNamespace(name);
	if (attrNS) {
	  el.setAttributeNS(attrNS, name, value);
	} else {
	  el.setAttribute(name, value);
	}
}
};

/**
 * Applies a property to a given Element.
 * @param {!Element} el
 * @param {string} name The property's name.
 * @param {*} value The property's value.
 */
var applyProp = function(el, name, value) {
el[name] = value;
};

/**
 * Applies a value to a style declaration. Supports CSS custom properties by
 * setting properties containing a dash using CSSStyleDeclaration.setProperty.
 * @param {CSSStyleDeclaration} style
 * @param {!string} prop
 * @param {*} value
 */
var setStyleValue = function(style, prop, value) {
if (prop.indexOf('-') >= 0) {
	style.setProperty(prop, /** @type {string} */value);
} else {
	style[prop] = value;
}
};

/**
 * Applies a style to an Element. No vendor prefix expansion is done for
 * property names/values.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} style The style to set. Either a string of css or an object
 *     containing property-value pairs.
 */
var applyStyle = function(el, name, style) {
if (typeof style === 'string') {
	el.style.cssText = style;
} else {
	el.style.cssText = '';
	var elStyle = el.style;
	var obj = /** @type {!Object<string,string>} */style;

	for (var prop in obj) {
	  if (has(obj, prop)) {
		setStyleValue(elStyle, prop, obj[prop]);
	  }
	}
}
};

/**
 * Updates a single attribute on an Element.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value. If the value is an object or
 *     function it is set on the Element, otherwise, it is set as an HTML
 *     attribute.
 */
var applyAttributeTyped = function(el, name, value) {
var type = typeof value;

if (type === 'object' || type === 'function') {
	applyProp(el, name, value);
} else {
	applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
}
};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function(el, name, value) {
var data = getData(el);
var attrs = data.attrs;

if (attrs[name] === value) {
	return;
}

var mutator = attributes[name] || attributes[symbols.default];
mutator(el, name, value);

attrs[name] = value;
};

/**
 * A publicly mutable object to provide custom mutators for attributes.
 * @const {!Object<string, function(!Element, string, *)>}
 */
var attributes = createMap();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
attributes[symbols.default] = applyAttributeTyped;

attributes['style'] = applyStyle;

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {Array<*>}
 */
var argsBuilder = [];

/**
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementOpen = function(tag, key, statics, var_args) {
if (process.env.NODE_ENV !== 'production') {
	assertNotInAttributes('elementOpen');
	assertNotInSkip('elementOpen');
}

var node = coreElementOpen(tag, key);
var data = getData(node);

if (!data.staticsApplied) {
	if (statics) {
	  for (var _i = 0; _i < statics.length; _i += 2) {
		var name = /** @type {string} */statics[_i];
		var value = statics[_i + 1];
		updateAttribute(node, name, value);
	  }
	}
	// Down the road, we may want to keep track of the statics array to use it
	// as an additional signal about whether a node matches or not. For now,
	// just use a marker so that we do not reapply statics.
	data.staticsApplied = true;
}

/*
* Checks to see if one or more attributes have changed for a given Element.
* When no attributes have changed, this is much faster than checking each
* individual argument. When attributes have changed, the overhead of this is
* minimal.
*/
var attrsArr = data.attrsArr;
var newAttrs = data.newAttrs;
var isNew = !attrsArr.length;
var i = ATTRIBUTES_OFFSET;
var j = 0;

for (; i < arguments.length; i += 2, j += 2) {
	var _attr = arguments[i];
	if (isNew) {
	  attrsArr[j] = _attr;
	  newAttrs[_attr] = undefined;
	} else if (attrsArr[j] !== _attr) {
	  break;
	}

	var value = arguments[i + 1];
	if (isNew || attrsArr[j + 1] !== value) {
	  attrsArr[j + 1] = value;
	  updateAttribute(node, _attr, value);
	}
}

if (i < arguments.length || j < attrsArr.length) {
	for (; i < arguments.length; i += 1, j += 1) {
	  attrsArr[j] = arguments[i];
	}

	if (j < attrsArr.length) {
	  attrsArr.length = j;
	}

	/*
	 * Actually perform the attribute update.
	 */
	for (i = 0; i < attrsArr.length; i += 2) {
	  var name = /** @type {string} */attrsArr[i];
	  var value = attrsArr[i + 1];
	  newAttrs[name] = value;
	}

	for (var _attr2 in newAttrs) {
	  updateAttribute(node, _attr2, newAttrs[_attr2]);
	  newAttrs[_attr2] = undefined;
	}
}

return node;
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 */
var elementOpenStart = function(tag, key, statics) {
if (process.env.NODE_ENV !== 'production') {
	assertNotInAttributes('elementOpenStart');
	setInAttributes(true);
}

argsBuilder[0] = tag;
argsBuilder[1] = key;
argsBuilder[2] = statics;
};

/***
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name
 * @param {*} value
 */
var attr = function(name, value) {
if (process.env.NODE_ENV !== 'production') {
	assertInAttributes('attr');
}

argsBuilder.push(name);
argsBuilder.push(value);
};

/**
 * Closes an open tag started with elementOpenStart.
 * @return {!Element} The corresponding Element.
 */
var elementOpenEnd = function() {
if (process.env.NODE_ENV !== 'production') {
	assertInAttributes('elementOpenEnd');
	setInAttributes(false);
}

var node = elementOpen.apply(null, argsBuilder);
argsBuilder.length = 0;
return node;
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} tag The element's tag.
 * @return {!Element} The corresponding Element.
 */
var elementClose = function(tag) {
if (process.env.NODE_ENV !== 'production') {
	assertNotInAttributes('elementClose');
}

var node = coreElementClose();

if (process.env.NODE_ENV !== 'production') {
	assertCloseMatchesOpenTag(getData(node).nodeName, tag);
}

return node;
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementVoid = function(tag, key, statics, var_args) {
elementOpen.apply(null, arguments);
return elementClose(tag);
};

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 * @return {!Text} The corresponding text node.
 */
var text = function(value, var_args) {
if (process.env.NODE_ENV !== 'production') {
	assertNotInAttributes('text');
	assertNotInSkip('text');
}

var node = coreText();
var data = getData(node);

if (data.text !== value) {
	data.text = /** @type {string} */value;

	var formatted = value;
	for (var i = 1; i < arguments.length; i += 1) {
	  /*
	   * Call the formatter function directly to prevent leaking arguments.
	   * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
	   */
	  var fn = arguments[i];
	  formatted = fn(formatted);
	}

	node.data = formatted;
}

return node;
};

exports.patch = patchInner;
exports.patchInner = patchInner;
exports.patchOuter = patchOuter;
exports.currentElement = currentElement;
exports.currentPointer = currentPointer;
exports.skip = skip;
exports.skipNode = skipNode;
exports.elementVoid = elementVoid;
exports.elementOpenStart = elementOpenStart;
exports.elementOpenEnd = elementOpenEnd;
exports.elementOpen = elementOpen;
exports.elementClose = elementClose;
exports.text = text;
exports.attr = attr;
exports.symbols = symbols;
exports.attributes = attributes;
exports.applyAttr = applyAttr;
exports.applyProp = applyProp;
exports.notifications = notifications;
exports.importNode = importNode;

//# sourceMappingURL=incremental-dom-cjs.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.IncrementalDOM = global.IncrementalDOM || {})));
}(this, (function (exports) { 'use strict';

/**
 * An array used to store the strings generated by calls to
 * elementOpen, elementOpenStart, elementOpenEnd, elementEnd and elementVoid
 */
exports.buffer = [];

/** @type {?Object} */
exports.currentParent = null;

/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
var currentElement = function currentElement() {
return exports.currentParent;
};

/**
 * @return {Node} The Node that will be evaluated for the next instruction.
 */
var currentPointer = function currentPointer() {
return {};
};

/**
 * Patches an Element with the the provided function. Exactly one top level
 * element call should be made corresponding to `node`.
 *
 * @param {?object} node The Element where the patch should start.
 * @param {!function(T)} fn A function containing open/close/etc. calls that
 *     describe the DOM. This should have at most one top level element call.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {void} Nothing.
 */
var patch = function patch(node, fn, data) {
exports.currentParent = node;
fn(data);
exports.currentParent.innerHTML = exports.buffer.join('');
exports.buffer = [];
return exports.currentParent;
};

var patchOuter = patch;
var patchInner = patch;

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 *
 * @return {void} Nothing.
 */
var text = function text(value, var_args) {
var formatted = value;
for (var i = 1; i < arguments.length; i += 1) {
	var fn = arguments[i];
	formatted = fn(formatted);
}
exports.buffer.push(formatted);
};

/** @const */
var symbols = {
default: '__default'
};

/** @const */
var attributes = {};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Array.<string>} el Buffer to append element attributes.
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function updateAttribute(el, name, value) {
var mutator = attributes[name] || attributes[symbols.default];
mutator(el, name, value);
};

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
attributes[symbols.default] = function(el, name, value) {
if (Array.isArray(el)) {
	el.push(' ' + name + '="' + value + '"');
}
};

/**
 * Truncates an array, removing items up until length.
 * @param {!Array<*>} arr The array to truncate.
 * @param {number} length The new length of the array.
 */
var truncateArray = function truncateArray(arr, length) {
while (arr.length > length) {
	arr.pop();
}
};

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {!Array<*>}
 */
var argsBuilder = [];

/**
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 * @return {void} Nothing.
 */
var attr = function attr(name, value) {
argsBuilder.push(name);
argsBuilder.push(value);
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} The Element's tag.
 * @return {void} Nothing.
 */
var elementClose = function elementClose(nameOrCtor) {
if (typeof nameOrCtor === 'function') {
	new nameOrCtor();
	return;
}
exports.buffer.push('</' + nameOrCtor + '>');
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 *
 * @param {string} The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {void} Nothing.
 */
var elementVoid = function elementVoid(nameOrCtor, key, statics, var_args) {
elementOpen.apply(null, arguments);
return elementClose(nameOrCtor);
};

/**
 * @param {!string} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {void} Nothing.
 */
var elementOpen = function elementOpen(nameOrCtor, key, statics, var_args) {
if (typeof nameOrCtor === 'function') {
	new nameOrCtor();
	return exports.currentParent;
}

exports.buffer.push('<' + nameOrCtor);

if (statics) {
	for (var _i = 0; _i < statics.length; _i += 2) {
	  var name = /** @type {string} */statics[_i];
	  var value = statics[_i + 1];
	  updateAttribute(exports.buffer, name, value);
	}
}

var i = ATTRIBUTES_OFFSET;
var j = 0;

for (; i < arguments.length; i += 2, j += 2) {
	var _name = arguments[i];
	var _value = arguments[i + 1];
	updateAttribute(exports.buffer, _name, _value);
}

exports.buffer.push('>');

return exports.currentParent;
};

/**
 * Closes an open tag started with elementOpenStart.
 *
 * @return {void} Nothing.
 */
var elementOpenEnd = function elementOpenEnd() {
elementOpen.apply(null, argsBuilder);
truncateArray(argsBuilder, 0);
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @return {void} Nothing.
 */
var elementOpenStart = function elementOpenStart(nameOrCtor, key, statics) {
argsBuilder[0] = nameOrCtor;
argsBuilder[1] = key;
argsBuilder[2] = statics;
};

/**
 * Returns the constructred DOM string at this point.
 * @param {function} fn
 * @return {string} The constructed DOM string.
 */
var renderToString = function renderToString(fn) {
patch({}, fn);
return currentElement().innerHTML;
};

exports.currentElement = currentElement;
exports.currentPointer = currentPointer;
exports.patch = patch;
exports.patchInner = patchInner;
exports.patchOuter = patchOuter;
exports.text = text;
exports.attr = attr;
exports.elementClose = elementClose;
exports.elementOpen = elementOpen;
exports.elementOpenEnd = elementOpenEnd;
exports.elementOpenStart = elementOpenStart;
exports.elementVoid = elementVoid;
exports.renderToString = renderToString;
exports.symbols = symbols;
exports.attributes = attributes;
exports.updateAttribute = updateAttribute;

Object.defineProperty(exports, '__esModule', { value: true });

})));

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getPatchingComponent = getPatchingComponent;
exports.patch = patch;

var _metalDom = __webpack_require__(11);

var _data = __webpack_require__(9);

var _render = __webpack_require__(31);

var patchingComponents_ = [];

/**
 * Guarantees that the component's element has a parent. That's necessary
 * when calling incremental dom's `patchOuter` for now, as otherwise it will
 * throw an error if the element needs to be replaced.
 * @param {Element} element
 * @return {Element} The parent, in case it was added.
 * @private
 */
function buildParentIfNecessary_(element) {
	if (!element || !element.parentNode) {
		var parent = {};
		if (typeof document !== 'undefined') {
			parent = document.createElement('div');
		}
		if (element) {
			(0, _metalDom.append)(parent, element);
		}
		return parent;
	}
}

/**
 * Calls incremental dom's patch function.
 * @param {!Component} component The component to patch.
 * @param {!Element} element The element the component should be patched on.
 * @param {boolean=} outer Flag indicating if `patchOuter` should be used
 *     instead of `patch`.
 * @private
 */
function callPatch_(component, element, outer) {
	patchingComponents_.push(component);

	var data = (0, _data.getData)(component);
	if (!data.render) {
		// Store reference to avoid binds on every patch.
		data.render = _render.render.bind(null, component);
	}

	var patchFn = outer ? IncrementalDOM.patchOuter : IncrementalDOM.patch;
	patchFn(element, data.render);

	patchingComponents_.pop();
}

/**
 * Gets the component that triggered the current patch operation.
 * @return {Component}
 */
function getPatchingComponent() {
	return patchingComponents_[patchingComponents_.length - 1];
}

/**
 * Patches the component with incremental dom function calls.
 * @param {!Component} component
 */
function patch(component) {
	if (!tryPatchEmptyWithParent_(component)) {
		if (!tryPatchWithNoParent_(component)) {
			var element = component.element;
			callPatch_(component, element, true);
		}
	}
}

/**
 * Checks if the component has no content but was rendered from another
 * component. If so, we'll need to patch this parent to make sure that any new
 * content will be added in the right position.
 * @param {!Component} component
 * @return {?boolean} True if the patch happened. Nothing otherwise.
 * @private
 */
function tryPatchEmptyWithParent_(component) {
	var data = (0, _data.getData)(component);
	if (!component.element && data.parent) {
		data.parent.getRenderer().patch(data.parent);
		return true;
	}
}

/**
 * Checks if the component's element exists and has a parent. If that's not the
 * case, a temporary parent will be created and passed to the `patch` function,
 * since incremental dom requires it. Once the patch is done the temporary
 * parent is removed and the component's content is reattached to the correct
 * final position.
 * @param {!Component} component
 * @return {?boolean} True if the patch happened. Nothing otherwise.
 * @private
 */
function tryPatchWithNoParent_(component) {
	var tempParent = buildParentIfNecessary_(component.element);
	if (tempParent) {
		callPatch_(component, tempParent);
		(0, _metalDom.exitDocument)(component.element);
		if (component.element && component.inDocument) {
			var attach = component.getAttachData();
			component.attachElement(attach.parent, attach.sibling);
		}
		return true;
	}
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.applyAttribute = applyAttribute;
exports.convertListenerNamesToFns = convertListenerNamesToFns;

var _metal = __webpack_require__(1);

var _metalDom = __webpack_require__(11);

var _metalComponent = __webpack_require__(2);

var _incrementalDomAop = __webpack_require__(16);

var HANDLE_SUFFIX = '__handle__';
var LISTENER_REGEX = /^(?:on([A-Z].+))|(?:data-on(.+))$/;

/**
 * Applies an attribute to a specified element owned by the given component.
 * @param {!Component} component
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 */
function applyAttribute(component, element, name, value) {
var eventName = getEventFromListenerAttr_(name);
if (eventName) {
	attachEvent_(component, element, name, eventName, value);
	return;
}

value = fixCheckedAttr_(name, value);
setValueAttrAsProperty_(element, name, value);

if ((0, _metal.isBoolean)(value)) {
	setBooleanAttr_(element, name, value);
} else {
	(0, _incrementalDomAop.getOriginalFn)('attributes')(element, name, value);
}
}

/**
 * Listens to the specified event, attached via incremental dom calls.
 * @param {!Component} component
 * @param {!Element} element
 * @param {string} attr
 * @param {string} eventName
 * @param {function()} fn
 * @private
 */
function attachEvent_(component, element, attr, eventName, fn) {
if ((0, _metal.isServerSide)()) {
	return;
}
var handleKey = eventName + HANDLE_SUFFIX;
if (element[handleKey]) {
	element[handleKey].removeListener();
	element[handleKey] = null;
}
if (fn) {
	element[attr] = fn;
	element[handleKey] = (0, _metalDom.delegate)(document, eventName, element, fn);
}
}

/**
 * Converts all event listener attributes given as function names to actual
 * function references. It's important to do this before calling the real
 * incremental dom `elementOpen` function, otherwise if a component passes
 * the same function name that an element was already using for another
 * component, that event won't be reattached as incremental dom will think that
 * the value hasn't changed. Passing the function references as the value will
 * guarantee that different functions will cause events to be reattached,
 * regardless of their original names.
 * @param {!Component} component
 * @param {!Object} config
 */
function convertListenerNamesToFns(component, config) {
var keys = Object.keys(config);
for (var i = 0; i < keys.length; i++) {
	var key = keys[i];
	config[key] = convertListenerNameToFn_(component, key, config[key]);
}
}

/**
 * Converts the given attribute's value to a function reference, if it's
 * currently a listener name. It also register the listener name for
 * further usage.
 * @param {!Component} component
 * @param {string} name
 * @param {*} value
 * @return {*}
 * @private
 */
function convertListenerNameToFn_(component, name, value) {
if ((0, _metal.isString)(value)) {
	var eventName = getEventFromListenerAttr_(name);
	if (eventName) {
	  var fn = (0, _metalComponent.getComponentFn)(component, value);
	  if (fn) {
		return fn;
	  }
	}
}
return value;
}

/**
 * Changes the value of the `checked` attribute to be a boolean.
 * NOTE: This is a temporary fix to account for incremental dom setting
 * "checked" as an attribute only, which can cause bugs since that won't
 * necessarily check/uncheck the element it's set on. See
 * https://github.com/google/incremental-dom/issues/198 for more details.
 * @param {string} name
 * @param {*} value
 * @return {*}
 * @private
 */
function fixCheckedAttr_(name, value) {
if (name === 'checked') {
	value = (0, _metal.isDefAndNotNull)(value) && value !== false;
}
return value;
}

/**
 * Returns the event name if the given attribute is a listener (matching the
 * `LISTENER_REGEX` regex), or null if it isn't.
 * @param {string} attr
 * @return {?string}
 * @private
 */
function getEventFromListenerAttr_(attr) {
var matches = LISTENER_REGEX.exec(attr);
var eventName = matches ? matches[1] ? matches[1] : matches[2] : null;
return eventName ? eventName.toLowerCase() : null;
}

/**
 * Sets boolean attributes manually. This is done because incremental dom sets
 * boolean values as string data attributes by default, which is counter
 * intuitive. This changes the behavior to use the actual boolean value.
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 * @private
 */
function setBooleanAttr_(element, name, value) {
if ((0, _metal.isServerSide)()) {
	return;
}
element[name] = value;
if (value) {
	element.setAttribute(name, '');
} else {
	element.removeAttribute(name);
}
}

/**
 * Sets the value of the `value` attribute directly in the element.
 * NOTE: This is a temporary fix to account for incremental dom setting "value"
 * as an attribute only, which can cause bugs since that won't necessarily
 * update the input's content it's set on. See
 * https://github.com/google/incremental-dom/issues/239 for more details. We
 * only do this if the new value is different though, as otherwise the browser
 * will automatically move the typing cursor to the end of the field.
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 * @private
 */
function setValueAttrAsProperty_(element, name, value) {
if ((0, _metal.isServerSide)()) {
	return;
}
if (name === 'value' && element.value !== value) {
	element[name] = value;
}
}

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.disposeUnused = disposeUnused;
exports.schedule = schedule;

var _data = __webpack_require__(9);

var comps_ = [];
var disposing_ = false;

/**
 * Disposes all sub components that were not rerendered since the last
 * time this function was scheduled.
 */
function disposeUnused() {
	if (disposing_) {
		return;
	}
	disposing_ = true;

	for (var i = 0; i < comps_.length; i++) {
		var comp = comps_[i];
		if (!comp.isDisposed() && !(0, _data.getData)(comp).parent) {
			// Don't let disposing cause the element to be removed, since it may
			// be currently being reused by another component.
			if (!comp.portalElement) {
				comp.element = null;
			}
			comp.dispose();
		}
	}
	comps_ = [];
	disposing_ = false;
}

/**
 * Schedules the given components to be checked and disposed if not used
 * anymore when `disposeUnused` is called.
 * @param {!Array<!Component>} comps
 */
function schedule(comps) {
	for (var i = 0; i < comps.length; i++) {
		if (!comps[i].isDisposed()) {
			(0, _data.getData)(comps[i]).parent = null;
			comps_.push(comps[i]);
		}
	}
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var SoyAop = {
	/**
* The functions that should be called instead of a template call. The last
* function in the array is the one that is intercepting at the moment. If the
* array is empty, the original function will be called instead.
* @type {!Array<function()>}
* @protected
*/
	interceptFns_: [],

	/**
* Gets the original function of the given template function. If no original exists,
* returns the given function itself.
* @param {!function()} fn
* @return {!function()}
*/
	getOriginalFn: function getOriginalFn(fn) {
		return fn.originalFn ? fn.originalFn : fn;
	},

	/**
* Handles a template call, calling the current interception function if one
* is set, or otherwise just calling the original function instead.
* @param {!function()} originalFn The original template function that was
*     intercepted.
* @param {Object=} data Template data object.
* @param {*=} ignored
* @param {Object=} ijData Template injected data object.
* @return {*} The return value of the function that is called to handle this
*     interception.
*/
	handleTemplateCall_: function handleTemplateCall_(originalFn, data, ignored, ijData) {
		var interceptFn = SoyAop.interceptFns_[SoyAop.interceptFns_.length - 1]; // eslint-disable-line
		if (interceptFn) {
			return interceptFn.call(null, originalFn, data, ignored, ijData);
		} else {
			return originalFn.call(null, data, ignored, ijData);
		}
	},

	/**
* Registers a template function that should be intercepted.
* @param {!Object} templates The original templates object containing the
*     function to be intercepted.
* @param {string} name The name of the template function to intercept.
*/
	registerForInterception: function registerForInterception(templates, name) {
		var originalFn = templates[name];
		if (!originalFn.originalFn) {
			templates[name] = SoyAop.handleTemplateCall_.bind(null, originalFn);
			templates[name].originalFn = originalFn;
		}
	},

	/**
* Starts intercepting all template calls, replacing them with a call to the
* given function instead.
* @param {!function()} fn
*/
	startInterception: function startInterception(fn) {
		SoyAop.interceptFns_.push(fn);
	},

	/**
* Stops intercepting template calls.
*/
	stopAllInterceptions: function stopAllInterceptions() {
		SoyAop.interceptFns_ = [];
	},

	/**
* Stops intercepting template calls with the last registered function.
*/
	stopInterception: function stopInterception() {
		SoyAop.interceptFns_.pop();
	}
};

exports.default = SoyAop;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from Chart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayChart.
* @public
*/

goog.module('ClayChart.incrementaldom');

var incrementalDom = goog.require('incrementaldom');
goog.require('soy.asserts');
var soyIdom = goog.require('soy.idom');

/**
* @param {$render.Params} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	opt_data = opt_data || {};
	/** @type {boolean|null|undefined} */
	var _loading = soy.asserts.assertType(opt_data._loading == null || goog.isBoolean(opt_data._loading) || opt_data._loading === 1 || opt_data._loading === 0, '_loading', opt_data._loading, 'boolean|null|undefined');
	incrementalDom.elementOpenStart('div');
	incrementalDom.attr('class', 'metal-chart-container');
	incrementalDom.elementOpenEnd();
	var chartAttrs__soy36 = function chartAttrs__soy36() {
	  if (_loading) {
		incrementalDom.attr('hidden', '');
	  }
	  incrementalDom.attr('ref', 'chart');
	};
	incrementalDom.elementOpenStart('div');
	incrementalDom.attr('class', 'metal-chart');
	chartAttrs__soy36();
	incrementalDom.elementOpenEnd();
	incrementalDom.elementClose('div');
	var placeholderAttrs__soy45 = function placeholderAttrs__soy45() {
	  if (!_loading) {
		incrementalDom.attr('hidden', '');
	  }
	  incrementalDom.attr('ref', 'placeholder');
	};
	incrementalDom.elementOpenStart('div');
	placeholderAttrs__soy45();
	incrementalDom.elementOpenEnd();
	$loading(null, opt_ijData);
	incrementalDom.elementClose('div');
	incrementalDom.elementClose('div');
};
exports.render = $render;
/**
* @typedef {{
*  _loading: (boolean|null|undefined),
* }}
*/
$render.Params;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayChart.render';
}

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $loading = function $loading(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	incrementalDom.elementOpenStart('div');
	incrementalDom.attr('aria-hidden', 'true');
	incrementalDom.attr('class', 'loading-icon');
	incrementalDom.elementOpenEnd();
	incrementalDom.elementOpenStart('span');
	incrementalDom.attr('class', 'loading-animation');
	incrementalDom.elementOpenEnd();
	incrementalDom.elementClose('span');
	incrementalDom.elementClose('div');
};
exports.loading = $loading;
if (goog.DEBUG) {
	$loading.soyTemplateName = 'ClayChart.loading';
}

exports.render.params = ["_loading"];
exports.render.types = { "_loading": "bool" };
exports.loading.params = [];
exports.loading.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayChart = function(_Component) {
_inherits(ClayChart, _Component);

function ClayChart() {
	_classCallCheck(this, ClayChart);

	return _possibleConstructorReturn(this, (ClayChart.__proto__ || Object.getPrototypeOf(ClayChart)).apply(this, arguments));
}

return ClayChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayChart, templates);
exports.ClayChart = ClayChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayAreaLineChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from AreaLineChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayAreaLineChart.
* @public
*/

goog.module('ClayAreaLineChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayAreaLineChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayAreaLineChart = function(_Component) {
_inherits(ClayAreaLineChart, _Component);

function ClayAreaLineChart() {
	_classCallCheck(this, ClayAreaLineChart);

	return _possibleConstructorReturn(this, (ClayAreaLineChart.__proto__ || Object.getPrototypeOf(ClayAreaLineChart)).apply(this, arguments));
}

return ClayAreaLineChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayAreaLineChart, templates);
exports.ClayAreaLineChart = ClayAreaLineChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AreaSplineChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _AreaSplineChartSoy = __webpack_require__(70);

var _AreaSplineChartSoy2 = _interopRequireDefault(_AreaSplineChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * AreaSpline Chart Component
 * @augments Chart
 */
var AreaSplineChart = function(_Chart) {
	_inherits(AreaSplineChart, _Chart);

	function AreaSplineChart() {
		_classCallCheck(this, AreaSplineChart);

		return _possibleConstructorReturn(this, (AreaSplineChart.__proto__ || Object.getPrototypeOf(AreaSplineChart)).apply(this, arguments));
	}

	return AreaSplineChart;
}(_Chart3.default);

AreaSplineChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default area-spline
* @instance
* @memberof AreaSplineChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.area).value('area-spline')
};

_metalSoy2.default.register(AreaSplineChart, _AreaSplineChartSoy2.default);

exports.AreaSplineChart = AreaSplineChart;
exports.default = AreaSplineChart;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayAreaSplineChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from AreaSplineChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayAreaSplineChart.
* @public
*/

goog.module('ClayAreaSplineChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayAreaSplineChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayAreaSplineChart = function(_Component) {
_inherits(ClayAreaSplineChart, _Component);

function ClayAreaSplineChart() {
	_classCallCheck(this, ClayAreaSplineChart);

	return _possibleConstructorReturn(this, (ClayAreaSplineChart.__proto__ || Object.getPrototypeOf(ClayAreaSplineChart)).apply(this, arguments));
}

return ClayAreaSplineChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayAreaSplineChart, templates);
exports.ClayAreaSplineChart = ClayAreaSplineChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AreaStepChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _AreaStepChartSoy = __webpack_require__(72);

var _AreaStepChartSoy2 = _interopRequireDefault(_AreaStepChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * AreaStep Chart Component
 * @augments Chart
 */
var AreaStepChart = function(_Chart) {
	_inherits(AreaStepChart, _Chart);

	function AreaStepChart() {
		_classCallCheck(this, AreaStepChart);

		return _possibleConstructorReturn(this, (AreaStepChart.__proto__ || Object.getPrototypeOf(AreaStepChart)).apply(this, arguments));
	}

	return AreaStepChart;
}(_Chart3.default);

AreaStepChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default area
* @instance
* @memberof AreaStepChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.area).value('area-step')
};

_metalSoy2.default.register(AreaStepChart, _AreaStepChartSoy2.default);

exports.AreaStepChart = AreaStepChart;
exports.default = AreaStepChart;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayAreaStepChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from AreaStepChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayAreaStepChart.
* @public
*/

goog.module('ClayAreaStepChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayAreaStepChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayAreaStepChart = function(_Component) {
_inherits(ClayAreaStepChart, _Component);

function ClayAreaStepChart() {
	_classCallCheck(this, ClayAreaStepChart);

	return _possibleConstructorReturn(this, (ClayAreaStepChart.__proto__ || Object.getPrototypeOf(ClayAreaStepChart)).apply(this, arguments));
}

return ClayAreaStepChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayAreaStepChart, templates);
exports.ClayAreaStepChart = ClayAreaStepChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BarChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _BarChartSoy = __webpack_require__(74);

var _BarChartSoy2 = _interopRequireDefault(_BarChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Bar Chart component.
 * @augments Chart
 */
var BarChart = function(_Chart) {
	_inherits(BarChart, _Chart);

	function BarChart() {
		_classCallCheck(this, BarChart);

		return _possibleConstructorReturn(this, (BarChart.__proto__ || Object.getPrototypeOf(BarChart)).apply(this, arguments));
	}

	return BarChart;
}(_Chart3.default);

BarChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default bar
* @instance
* @memberof BarChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.point).value('bar')
};

_metalSoy2.default.register(BarChart, _BarChartSoy2.default);

exports.BarChart = BarChart;
exports.default = BarChart;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayBarChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from BarChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayBarChart.
* @public
*/

goog.module('ClayBarChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayBarChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayBarChart = function(_Component) {
_inherits(ClayBarChart, _Component);

function ClayBarChart() {
	_classCallCheck(this, ClayBarChart);

	return _possibleConstructorReturn(this, (ClayBarChart.__proto__ || Object.getPrototypeOf(ClayBarChart)).apply(this, arguments));
}

return ClayBarChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayBarChart, templates);
exports.ClayBarChart = ClayBarChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BubbleChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _BubbleChartSoy = __webpack_require__(76);

var _BubbleChartSoy2 = _interopRequireDefault(_BubbleChartSoy);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Bubble Chart component.
 * @augments Chart
 */
var BubbleChart = function(_Chart) {
	_inherits(BubbleChart, _Chart);

	function BubbleChart() {
		_classCallCheck(this, BubbleChart);

		return _possibleConstructorReturn(this, (BubbleChart.__proto__ || Object.getPrototypeOf(BubbleChart)).apply(this, arguments));
	}

	return BubbleChart;
}(_Chart3.default);

BubbleChart.STATE = {
	/**
* Labels visibility
* @default true
* @instance
* @memberof BubbleChart
* @type {Boolean}
*/
	labels: _metalState.Config.bool().value(true),

	/**
* The variety of chart that will be rendered.
* @default donut
* @instance
* @memberof BubbleChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.string().value('bubble')
};

_metalSoy2.default.register(BubbleChart, _BubbleChartSoy2.default);

exports.BubbleChart = BubbleChart;
exports.default = BubbleChart;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayBubbleChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from BubbleChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayBubbleChart.
* @public
*/

goog.module('ClayBubbleChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayBubbleChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayBubbleChart = function(_Component) {
_inherits(ClayBubbleChart, _Component);

function ClayBubbleChart() {
	_classCallCheck(this, ClayBubbleChart);

	return _possibleConstructorReturn(this, (ClayBubbleChart.__proto__ || Object.getPrototypeOf(ClayBubbleChart)).apply(this, arguments));
}

return ClayBubbleChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayBubbleChart, templates);
exports.ClayBubbleChart = ClayBubbleChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DonutChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _DonutChartSoy = __webpack_require__(78);

var _DonutChartSoy2 = _interopRequireDefault(_DonutChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Donut Chart component.
 * @augments Chart
 */
var DonutChart = function(_Chart) {
	_inherits(DonutChart, _Chart);

	function DonutChart() {
		_classCallCheck(this, DonutChart);

		return _possibleConstructorReturn(this, (DonutChart.__proto__ || Object.getPrototypeOf(DonutChart)).apply(this, arguments));
	}

	return DonutChart;
}(_Chart3.default);

DonutChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default donut
* @instance
* @memberof DonutChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.percentage).value('donut')
};

_metalSoy2.default.register(DonutChart, _DonutChartSoy2.default);

exports.DonutChart = DonutChart;
exports.default = DonutChart;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayDonutChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from DonutChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayDonutChart.
* @public
*/

goog.module('ClayDonutChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayDonutChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayDonutChart = function(_Component) {
_inherits(ClayDonutChart, _Component);

function ClayDonutChart() {
	_classCallCheck(this, ClayDonutChart);

	return _possibleConstructorReturn(this, (ClayDonutChart.__proto__ || Object.getPrototypeOf(ClayDonutChart)).apply(this, arguments));
}

return ClayDonutChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayDonutChart, templates);
exports.ClayDonutChart = ClayDonutChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.GaugeChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _GaugeChartSoy = __webpack_require__(80);

var _GaugeChartSoy2 = _interopRequireDefault(_GaugeChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Guage Chart component.
 * @augments Chart
 */
var GaugeChart = function(_Chart) {
	_inherits(GaugeChart, _Chart);

	function GaugeChart() {
		_classCallCheck(this, GaugeChart);

		return _possibleConstructorReturn(this, (GaugeChart.__proto__ || Object.getPrototypeOf(GaugeChart)).apply(this, arguments));
	}

	return GaugeChart;
}(_Chart3.default);

GaugeChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default gauge
* @instance
* @memberof GaugeChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.gauge).value('gauge')
};

_metalSoy2.default.register(GaugeChart, _GaugeChartSoy2.default);

exports.GaugeChart = GaugeChart;
exports.default = GaugeChart;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayGaugeChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from GaugeChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayGaugeChart.
* @public
*/

goog.module('ClayGaugeChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayGaugeChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayGaugeChart = function(_Component) {
_inherits(ClayGaugeChart, _Component);

function ClayGaugeChart() {
	_classCallCheck(this, ClayGaugeChart);

	return _possibleConstructorReturn(this, (ClayGaugeChart.__proto__ || Object.getPrototypeOf(ClayGaugeChart)).apply(this, arguments));
}

return ClayGaugeChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayGaugeChart, templates);
exports.ClayGaugeChart = ClayGaugeChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Geomap = undefined;

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _d = __webpack_require__(13);

var d3 = _interopRequireWildcard(_d);

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _GeomapSoy = __webpack_require__(82);

var _GeomapSoy2 = _interopRequireDefault(_GeomapSoy);

var _metalState = __webpack_require__(3);

var _metal = __webpack_require__(1);

var _data = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Geomap component
 */
var Geomap = function(_Component) {
	_inherits(Geomap, _Component);

	function Geomap() {
		_classCallCheck(this, Geomap);

		return _possibleConstructorReturn(this, (Geomap.__proto__ || Object.getPrototypeOf(Geomap)).apply(this, arguments));
	}

	_createClass(Geomap, [{
		key: 'attached',

		/**
* @inheritDoc
*/
		value: function attached() {
			var _this2 = this;

			if ((0, _metal.isServerSide)()) {
				return;
			}

			var w = typeof this._width === 'string' ? this._width : this._width + 'px';
			var h = typeof this._height === 'string' ? this._height : this._height + 'px';

			this.svg = d3.select(this.element).append('svg').attr('width', w).attr('height', h);

			this._handleClickHandler = this._handleClick.bind(this);

			this.rect = this.svg.append('rect').attr('fill', 'rgba(1, 1, 1, 0)').attr('width', w).attr('height', h).on('click', this._handleClickHandler);

			var bounds = this.svg.node().getBoundingClientRect();

			this.svgGroup = this.svg.append('g');
			this.mapLayer = this.svgGroup.append('g');
			this.projection = d3.geoMercator().scale(100).translate([bounds.width / 2, bounds.height / 2]);

			this.path = d3.geoPath().projection(this.projection);
			this._selected = null;

			this._onDataLoadHandler = this._onDataLoad.bind(this);

			var config = this.getInitialConfig();

			(0, _data.resolveData)(config.data).then(function (val) {
				_this2._onDataLoadHandler.apply(_this2, [null, val]);

				if (_this2._pollingInterval) {
					clearInterval(_this2._pollingInterval);
				}

				if (_this2.pollingInterval) {
					_this2._pollingInterval = setInterval(function () {
						_this2._updateData(_this2.data);
					}, _this2.pollingInterval);
				}
			}).catch(function (err) {
				_this2._onDataLoadHandler.apply(_this2, [err, null]);
			});
		}

		/**
* @inheritDoc
*/

	}, {
		key: 'disposed',
		value: function disposed() {
			_get(Geomap.prototype.__proto__ || Object.getPrototypeOf(Geomap.prototype), 'disposed', this).call(this);

			if ((0, _metal.isServerSide)()) {
				return;
			}

			if (this._pollingInterval) {
				clearInterval(this._pollingInterval);
				this._pollingInterval = null;
			}

			if (this.svg) {
				this.svg.remove();
			}
		}

		/**
* Fill function
* @param {Object} d
* @protected
* @return {Number}
*/

	}, {
		key: '_fillFn',
		value: function _fillFn(d) {
			var value = d && d.properties ? d.properties[this.color.value] : 0;
			return this.colorScale(value);
		}

		/**
* Click handler
* @param {Object} d
* @protected
*/

	}, {
		key: '_handleClick',
		value: function _handleClick(d) {
			var _this3 = this;

			if (d && this._selected !== d) {
				this._selected = d;
			} else {
				this._selected = null;
			}

			// Highlight the clicked province
			this.mapLayer.selectAll('path').style('fill', function(d) {
				return _this3._selected && d === _this3._selected ? _this3.color.selected : _this3._fillFn.bind(_this3)(d);
			});
		}

		/**
* Mouse over handler
* @param {Object} feature
* @param {Number} idx
* @param {Array} selection
* @protected
*/

	}, {
		key: '_handleMouseOver',
		value: function _handleMouseOver(feature, idx, selection) {
			var node = selection[idx];
			d3.select(node).style('fill', this.color.selected);
		}

		/**
* Mouse over handler
* @param {Object} feature
* @param {Number} idx
* @param {Array} selection
* @protected
*/

	}, {
		key: '_handleMouseOut',
		value: function _handleMouseOut(feature, idx, selection) {
			var node = selection[idx];
			d3.select(node).style('fill', this._fillFn.bind(this));
		}

		/**
* Data load handler
* @param {Error} err
* @param {Object} mapData
* @protected
*/

	}, {
		key: '_onDataLoad',
		value: function _onDataLoad(err, mapData) {
			var _this4 = this;

			if (err) {
				throw err;
			}
			var features = mapData.features;

			// Calculate domain based on values received
			var values = features.map(function (f) {
				return f.properties[_this4.color.value];
			});

			this._domainMin = Math.min.apply(null, values);
			this._domainMax = Math.max.apply(null, values);

			this.colorScale = d3.scaleLinear().domain([this._domainMin, this._domainMax]).range([this.color.range.min, this.color.range.max]);

			this.mapLayer.selectAll('path').data(features).enter().append('path').attr('d', this.path).attr('vector-effect', 'non-scaling-stroke').attr('fill', this._fillFn.bind(this)).on('click', this._handleClickHandler).on('mouseout', this._handleMouseOut.bind(this)).on('mouseover', this._handleMouseOver.bind(this));
		}

		/**
* @inheritDoc
* @param {Object} data The updated data
* @protected
*/

	}, {
		key: '_updateData',
		value: function _updateData(data) {
			var _this5 = this;

			(0, _data.resolveData)(data).then(function (val) {
				_this5._onDataLoadHandler.apply(_this5, [null, val]);
			}).catch(function (err) {
				_this5._onDataLoadHandler.apply(_this5, [err, null]);
			});
		}
	}]);

	return Geomap;
}(_metalComponent2.default);

_metalSoy2.default.register(Geomap, _GeomapSoy2.default);

/**
 * GeoMap state definition.
 * @type {!Object}
 * @static
 */
Geomap.STATE = {
	/**
* Minimum value for domain
* @instance
* @memberof Geomap
* @type {!Number}
*/
	_domainMin: _metalState.Config.number().internal(),

	/**
* Maximum value for domain
* @instance
* @memberof Geomap
* @type {!Number}
*/
	_domainMax: _metalState.Config.number().internal(),

	/**
* Height of the map
* @default 480
* @instance
* @memberof Geomap
* @type {?Number}
*/
	_height: _metalState.Config.oneOfType([_metalState.Config.string(), _metalState.Config.number()]).value('100%').internal(),

	/**
* Width of the map
* @default 640
* @instance
* @memberof Geomap
* @type {?Number}
*/
	_width: _metalState.Config.oneOfType([_metalState.Config.string(), _metalState.Config.number()]).value('100%').internal(),

	/**
* Color configuration.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?Object}
*/
	color: _metalState.Config.shapeOf({
		range: _metalState.Config.shapeOf({
			max: _metalState.Config.string().required(),
			min: _metalState.Config.string().required()
		}),
		selected: _metalState.Config.string(),
		value: _metalState.Config.string().required()
	}).value({
		range: {
			min: '#b1d4ff',
			max: '#0065e4'
		},
		selected: '#4b9bff',
		value: 'pop_est'
	}),

	/**
* Data that will be rendered to the chart.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?(Array|undefined)}
*/
	data: _metalState.Config.oneOfType([_metalState.Config.object(), _metalState.Config.func(), _metalState.Config.string()]),

	/**
* Set an interval (in ms) to fetch the data.
* @default undefined
* @instance
* @memberof ChartBase
* @type {?Number}
*/
	pollingInterval: _metalState.Config.number()
};

exports.Geomap = Geomap;
exports.default = Geomap;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayGeomap = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from Geomap.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayGeomap.
* @public
*/

goog.module('ClayGeomap.incrementaldom');

goog.require('goog.soy.data.SanitizedContent');
var incrementalDom = goog.require('incrementaldom');
goog.require('soy.asserts');
var soyIdom = goog.require('soy.idom');

/**
* @param {$render.Params} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	opt_data = opt_data || {};
	/** @type {!goog.soy.data.SanitizedContent|null|string|undefined} */
	var _height = soy.asserts.assertType(opt_data._height == null || goog.isString(opt_data._height) || opt_data._height instanceof goog.soy.data.SanitizedContent, '_height', opt_data._height, '!goog.soy.data.SanitizedContent|null|string|undefined');
	/** @type {!goog.soy.data.SanitizedContent|null|string|undefined} */
	var _width = soy.asserts.assertType(opt_data._width == null || goog.isString(opt_data._width) || opt_data._width instanceof goog.soy.data.SanitizedContent, '_width', opt_data._width, '!goog.soy.data.SanitizedContent|null|string|undefined');
	incrementalDom.elementOpenStart('div');
	incrementalDom.attr('style', 'width:' + _width + ';height:' + _height);
	incrementalDom.elementOpenEnd();
	incrementalDom.elementClose('div');
};
exports.render = $render;
/**
* @typedef {{
*  _height: (!goog.soy.data.SanitizedContent|null|string|undefined),
*  _width: (!goog.soy.data.SanitizedContent|null|string|undefined),
* }}
*/
$render.Params;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayGeomap.render';
}

exports.render.params = ["_height", "_width"];
exports.render.types = { "_height": "string", "_width": "string" };
exports.templates = templates = exports;
return exports;
});

var ClayGeomap = function(_Component) {
_inherits(ClayGeomap, _Component);

function ClayGeomap() {
	_classCallCheck(this, ClayGeomap);

	return _possibleConstructorReturn(this, (ClayGeomap.__proto__ || Object.getPrototypeOf(ClayGeomap)).apply(this, arguments));
}

return ClayGeomap;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayGeomap, templates);
exports.ClayGeomap = ClayGeomap;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LineChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _LineChartSoy = __webpack_require__(84);

var _LineChartSoy2 = _interopRequireDefault(_LineChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Line Chart component.
 * @augments Chart
 */
var LineChart = function(_Chart) {
	_inherits(LineChart, _Chart);

	function LineChart() {
		_classCallCheck(this, LineChart);

		return _possibleConstructorReturn(this, (LineChart.__proto__ || Object.getPrototypeOf(LineChart)).apply(this, arguments));
	}

	return LineChart;
}(_Chart3.default);

LineChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default line
* @instance
* @memberof LineChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.point).value('line')
};

_metalSoy2.default.register(LineChart, _LineChartSoy2.default);

exports.LineChart = LineChart;
exports.default = LineChart;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayLineChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from LineChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayLineChart.
* @public
*/

goog.module('ClayLineChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayLineChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayLineChart = function(_Component) {
_inherits(ClayLineChart, _Component);

function ClayLineChart() {
	_classCallCheck(this, ClayLineChart);

	return _possibleConstructorReturn(this, (ClayLineChart.__proto__ || Object.getPrototypeOf(ClayLineChart)).apply(this, arguments));
}

return ClayLineChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayLineChart, templates);
exports.ClayLineChart = ClayLineChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PieChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _PieChartSoy = __webpack_require__(86);

var _PieChartSoy2 = _interopRequireDefault(_PieChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Pie Chart component.
 * @augments Chart
 */
var PieChart = function(_Chart) {
	_inherits(PieChart, _Chart);

	function PieChart() {
		_classCallCheck(this, PieChart);

		return _possibleConstructorReturn(this, (PieChart.__proto__ || Object.getPrototypeOf(PieChart)).apply(this, arguments));
	}

	return PieChart;
}(_Chart3.default);

PieChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default pie
* @instance
* @memberof PieChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.percentage).value('pie')
};

_metalSoy2.default.register(PieChart, _PieChartSoy2.default);

exports.PieChart = PieChart;
exports.default = PieChart;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayPieChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from PieChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayPieChart.
* @public
*/

goog.module('ClayPieChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayPieChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayPieChart = function(_Component) {
_inherits(ClayPieChart, _Component);

function ClayPieChart() {
	_classCallCheck(this, ClayPieChart);

	return _possibleConstructorReturn(this, (ClayPieChart.__proto__ || Object.getPrototypeOf(ClayPieChart)).apply(this, arguments));
}

return ClayPieChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayPieChart, templates);
exports.ClayPieChart = ClayPieChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PredictiveChart = undefined;

var _createClass = function() { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _PredictiveChartSoy = __webpack_require__(88);

var _PredictiveChartSoy2 = _interopRequireDefault(_PredictiveChartSoy);

var _metalState = __webpack_require__(3);

var _metal = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_AXIS_X = {
	tick: {
		culling: {
			max: 1
		},
		fit: true,
		format: '%Y-%m-%d'
	},
	type: 'timeseries'
};

var DEFAULT_TOOLTIP = {
	contents: function contents(data, defaultTitleFormat, defaultValueFormat, colorFn) {
		var datum = data[0];
		var color = colorFn(datum);
		var title = defaultTitleFormat(datum.x);
		var value = (0, _metal.isObject)(datum.value) && datum.value.hasOwnProperty('mid') ? datum.value.mid : Array.isArray(datum.value) ? datum.value[1] : datum.value;

		return '<table class="bb-tooltip">\n\t\t\t<tbody>\n\t\t\t\t<tr><th colspan="2">' + title + '</th></tr>\n\t\t\t\t<tr class="bb-tooltip-name-data1">\n\t\t\t\t\t<td class="name">\n\t\t\t\t\t\t<span style="background-color:' + color + '"></span>' + datum.id + '\n\t\t\t\t\t</td>\n\t\t\t\t\t<td class="value">' + value + '</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>';
	},

	grouped: false
};

/**
 * Predictive Chart component.
 * @augments Chart
 */

var PredictiveChart = function(_Chart) {
	_inherits(PredictiveChart, _Chart);

	function PredictiveChart() {
		_classCallCheck(this, PredictiveChart);

		return _possibleConstructorReturn(this, (PredictiveChart.__proto__ || Object.getPrototypeOf(PredictiveChart)).apply(this, arguments));
	}

	_createClass(PredictiveChart, [{
		key: 'attached',

		/**
* @inheritDoc
*/
		value: function attached() {
			_get(PredictiveChart.prototype.__proto__ || Object.getPrototypeOf(PredictiveChart.prototype), 'attached', this).call(this);
		}

		/**
* @inheritDoc
*/

	}, {
		key: 'created',
		value: function created() {
			var config = this.getInitialConfig();

			if ((0, _metal.isDefAndNotNull)(config.timeseries)) {
				config.data.push({ data: config.timeseries, id: 'x' });
			}

			if ((0, _metal.isDefAndNotNull)(this.data)) {
				this._normalizeData();
			}

			if ((0, _metal.isDefAndNotNull)(this.axisXTickFormat)) {
				this.axisX.tick.format = this.axisXTickFormat;
			}

			if ((0, _metal.isDefAndNotNull)(this.predictionDate)) {
				if ((0, _metal.isString)(this.predictionDate)) {
					this.predictionDate = new Date(this.predictionDate);
				}

				if (!(0, _metal.isDefAndNotNull)(this.regions)) {
					this.regions = [];
				}

				this.regions.push({
					axis: 'x',
					start: this.predictionDate
				});
			}

			if ((0, _metal.isDefAndNotNull)(this.tooltipContents)) {
				this.tooltip.contents = this.tooltipContents;
			}
		}

		/**
* Normalizes the data.
* @memberof PredictiveChart
* @private
*/

	}, {
		key: '_normalizeData',
		value: function _normalizeData() {
			this.data = this.data.map(function (dataSeries) {
				if (dataSeries.id !== 'x') {
					dataSeries.data = dataSeries.data.map(function (element) {
						return (0, _metal.isNumber)(element) ? { low: element, mid: element, high: element } : element;
					});
				}

				return dataSeries;
			});
		}
	}]);

	return PredictiveChart;
}(_Chart3.default);

PredictiveChart.STATE = {
	/**
* X axis configuration.
* @default DEFAULT_AXIS_X
* @instance
* @memberof PredictiveChart
* @type {Object}
*/
	axisX: _metalState.Config.shapeOf({
		tick: _metalState.Config.shapeOf({
			culling: _metalState.Config.shapeOf({
				max: _metalState.Config.number().required()
			}),
			fit: _metalState.Config.bool(),
			format: _metalState.Config.oneOfType([_metalState.Config.func(), _metalState.Config.string()])
		}),
		type: _metalState.Config.oneOf(['timeseries']).required()
	}).value(DEFAULT_AXIS_X),

	/**
* The axisX tick format configuration.
* This can be a function or a string.
*
* For more information on the supported formats, please
* see https://github.com/d3/d3-time-format
*
* @default '%Y-%m-%d'
* @instance
* @memberof PredictiveChart
* @type {Function|String}
*/
	axisXTickFormat: _metalState.Config.oneOfType([_metalState.Config.func(), _metalState.Config.string()]),

	/**
* The prediction date used to define the <code>region</code>
* on the X axis.
* @default undefined
* @instance
* @memberof PredictiveChart
* @type {Date}
*/
	predictionDate: {
		validator: function validator(val) {
			return val instanceof Date || (0, _metal.isString)(val);
		}
	},

	/**
* The timeseries configuration
* @default undefined
* @instance
* @memberof PredictiveChart
* @type {Array}
*/
	timeseries: _metalState.Config.array(),

	/**
* Toolip configuration.
* @default DEFAULT_TOOLTIP
* @instance
* @memberof PredictiveChart
* @type {Date}
*/
	tooltip: _metalState.Config.shapeOf({
		contents: _metalState.Config.func(),
		grouped: _metalState.Config.bool()
	}).value(DEFAULT_TOOLTIP),

	/**
* Tooltip format title function
* @default undefined
* @instance
* @memberof PredictiveChart
* @type {Function}
*/
	tooltipContents: _metalState.Config.func(),

	/**
* The variety of chart that will be rendered.
* @default area-line-range
* @instance
* @memberof PredictiveChart
* @type {string}
*/
	type: _metalState.Config.oneOf(['area-line-range', 'area-spline-range']).value('area-line-range'),

	/**
* X configuration
* @default x
* @instance
* @memberof PredictiveChart
* @type {string}
*/
	x: _metalState.Config.oneOf(['x']).value('x')
};

_metalSoy2.default.register(PredictiveChart, _PredictiveChartSoy2.default);

exports.PredictiveChart = PredictiveChart;
exports.default = PredictiveChart;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayPredictiveChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from PredictiveChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayPredictiveChart.
* @public
*/

goog.module('ClayPredictiveChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayPredictiveChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayPredictiveChart = function(_Component) {
_inherits(ClayPredictiveChart, _Component);

function ClayPredictiveChart() {
	_classCallCheck(this, ClayPredictiveChart);

	return _possibleConstructorReturn(this, (ClayPredictiveChart.__proto__ || Object.getPrototypeOf(ClayPredictiveChart)).apply(this, arguments));
}

return ClayPredictiveChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayPredictiveChart, templates);
exports.ClayPredictiveChart = ClayPredictiveChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ScatterChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _ScatterChartSoy = __webpack_require__(90);

var _ScatterChartSoy2 = _interopRequireDefault(_ScatterChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Scatter Chart component.
 * @augments Chart
 */
var ScatterChart = function(_Chart) {
	_inherits(ScatterChart, _Chart);

	function ScatterChart() {
		_classCallCheck(this, ScatterChart);

		return _possibleConstructorReturn(this, (ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).apply(this, arguments));
	}

	return ScatterChart;
}(_Chart3.default);

ScatterChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default scatter
* @instance
* @memberof ScatterChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.point).value('scatter')
};

_metalSoy2.default.register(ScatterChart, _ScatterChartSoy2.default);

exports.ScatterChart = ScatterChart;
exports.default = ScatterChart;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayScatterChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from ScatterChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayScatterChart.
* @public
*/

goog.module('ClayScatterChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayScatterChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayScatterChart = function(_Component) {
_inherits(ClayScatterChart, _Component);

function ClayScatterChart() {
	_classCallCheck(this, ClayScatterChart);

	return _possibleConstructorReturn(this, (ClayScatterChart.__proto__ || Object.getPrototypeOf(ClayScatterChart)).apply(this, arguments));
}

return ClayScatterChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayScatterChart, templates);
exports.ClayScatterChart = ClayScatterChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SplineChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _SplineChartSoy = __webpack_require__(92);

var _SplineChartSoy2 = _interopRequireDefault(_SplineChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Spline Chart component.
 * @augments Chart
 */
var SplineChart = function(_Chart) {
	_inherits(SplineChart, _Chart);

	function SplineChart() {
		_classCallCheck(this, SplineChart);

		return _possibleConstructorReturn(this, (SplineChart.__proto__ || Object.getPrototypeOf(SplineChart)).apply(this, arguments));
	}

	return SplineChart;
}(_Chart3.default);

SplineChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default spline
* @instance
* @memberof SplineChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.point).value('spline')
};

_metalSoy2.default.register(SplineChart, _SplineChartSoy2.default);

exports.SplineChart = SplineChart;
exports.default = SplineChart;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClaySplineChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from SplineChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClaySplineChart.
* @public
*/

goog.module('ClaySplineChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClaySplineChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClaySplineChart = function(_Component) {
_inherits(ClaySplineChart, _Component);

function ClaySplineChart() {
	_classCallCheck(this, ClaySplineChart);

	return _possibleConstructorReturn(this, (ClaySplineChart.__proto__ || Object.getPrototypeOf(ClaySplineChart)).apply(this, arguments));
}

return ClaySplineChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClaySplineChart, templates);
exports.ClaySplineChart = ClaySplineChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.StepChart = undefined;

var _Chart2 = __webpack_require__(4);

var _Chart3 = _interopRequireDefault(_Chart2);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

var _StepChartSoy = __webpack_require__(94);

var _StepChartSoy2 = _interopRequireDefault(_StepChartSoy);

var _types = __webpack_require__(5);

var _types2 = _interopRequireDefault(_types);

var _metalState = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Step Chart component.
 * @augments Chart
 */
var StepChart = function(_Chart) {
	_inherits(StepChart, _Chart);

	function StepChart() {
		_classCallCheck(this, StepChart);

		return _possibleConstructorReturn(this, (StepChart.__proto__ || Object.getPrototypeOf(StepChart)).apply(this, arguments));
	}

	return StepChart;
}(_Chart3.default);

StepChart.STATE = {
	/**
* The variety of chart that will be rendered.
* @default step
* @instance
* @memberof StepChart
* @type {?(string|undefined)}
*/
	type: _metalState.Config.oneOf(_types2.default.point).value('step')
};

_metalSoy2.default.register(StepChart, _StepChartSoy2.default);

exports.StepChart = StepChart;
exports.default = StepChart;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
value: true
});
exports.templates = exports.ClayStepChart = undefined;

var _metalComponent = __webpack_require__(2);

var _metalComponent2 = _interopRequireDefault(_metalComponent);

var _metalSoy = __webpack_require__(0);

var _metalSoy2 = _interopRequireDefault(_metalSoy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */

var templates;
goog.loadModule(function (exports) {
var soy = goog.require('soy');
var soydata = goog.require('soydata');
// This file was automatically generated from StepChart.soy.
// Please don't edit this file by hand.

/**
* @fileoverview Templates in namespace ClayStepChart.
* @public
*/

goog.module('ClayStepChart.incrementaldom');

var soyIdom = goog.require('soy.idom');

var $templateAlias1 = _metalSoy2.default.getTemplate('ClayChart.incrementaldom', 'render');

/**
* @param {Object<string, *>=} opt_data
* @param {Object<string, *>=} opt_ijData
* @param {Object<string, *>=} opt_ijData_deprecated
* @return {void}
* @suppress {checkTypes|uselessCode}
*/
var $render = function $render(opt_data, opt_ijData, opt_ijData_deprecated) {
	opt_ijData = opt_ijData_deprecated || opt_ijData;
	$templateAlias1(null, opt_ijData);
};
exports.render = $render;
if (goog.DEBUG) {
	$render.soyTemplateName = 'ClayStepChart.render';
}

exports.render.params = [];
exports.render.types = {};
exports.templates = templates = exports;
return exports;
});

var ClayStepChart = function(_Component) {
_inherits(ClayStepChart, _Component);

function ClayStepChart() {
	_classCallCheck(this, ClayStepChart);

	return _possibleConstructorReturn(this, (ClayStepChart.__proto__ || Object.getPrototypeOf(ClayStepChart)).apply(this, arguments));
}

return ClayStepChart;
}(_metalComponent2.default);

_metalSoy2.default.register(ClayStepChart, templates);
exports.ClayStepChart = ClayStepChart;
exports.templates = templates;
exports.default = templates;
/* jshint ignore:end */

/***/ }),
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.StepChart = exports.SplineChart = exports.ScatterChart = exports.PredictiveChart = exports.PieChart = exports.LineChart = exports.Geomap = exports.GaugeChart = exports.DonutChart = exports.d3 = exports.Chart = exports.bb = exports.BubbleChart = exports.BarChart = exports.AreaStepChart = exports.AreaSplineChart = exports.AreaLineChart = undefined;

var _AreaLineChart = __webpack_require__(32);

var _AreaLineChart2 = _interopRequireDefault(_AreaLineChart);

var _AreaSplineChart = __webpack_require__(69);

var _AreaSplineChart2 = _interopRequireDefault(_AreaSplineChart);

var _AreaStepChart = __webpack_require__(71);

var _AreaStepChart2 = _interopRequireDefault(_AreaStepChart);

var _BarChart = __webpack_require__(73);

var _BarChart2 = _interopRequireDefault(_BarChart);

var _BubbleChart = __webpack_require__(75);

var _BubbleChart2 = _interopRequireDefault(_BubbleChart);

var _Chart = __webpack_require__(4);

var _Chart2 = _interopRequireDefault(_Chart);

var _DonutChart = __webpack_require__(77);

var _DonutChart2 = _interopRequireDefault(_DonutChart);

var _GaugeChart = __webpack_require__(79);

var _GaugeChart2 = _interopRequireDefault(_GaugeChart);

var _Geomap = __webpack_require__(81);

var _Geomap2 = _interopRequireDefault(_Geomap);

var _LineChart = __webpack_require__(83);

var _LineChart2 = _interopRequireDefault(_LineChart);

var _PieChart = __webpack_require__(85);

var _PieChart2 = _interopRequireDefault(_PieChart);

var _PredictiveChart = __webpack_require__(87);

var _PredictiveChart2 = _interopRequireDefault(_PredictiveChart);

var _ScatterChart = __webpack_require__(89);

var _ScatterChart2 = _interopRequireDefault(_ScatterChart);

var _SplineChart = __webpack_require__(91);

var _SplineChart2 = _interopRequireDefault(_SplineChart);

var _StepChart = __webpack_require__(93);

var _StepChart2 = _interopRequireDefault(_StepChart);

var _ChartBase = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.AreaLineChart = _AreaLineChart2.default;
exports.AreaSplineChart = _AreaSplineChart2.default;
exports.AreaStepChart = _AreaStepChart2.default;
exports.BarChart = _BarChart2.default;
exports.BubbleChart = _BubbleChart2.default;
exports.bb = _ChartBase.bb;
exports.Chart = _Chart2.default;
exports.d3 = _ChartBase.d3;
exports.DonutChart = _DonutChart2.default;
exports.GaugeChart = _GaugeChart2.default;
exports.Geomap = _Geomap2.default;
exports.LineChart = _LineChart2.default;
exports.PieChart = _PieChart2.default;
exports.PredictiveChart = _PredictiveChart2.default;
exports.ScatterChart = _ScatterChart2.default;
exports.SplineChart = _SplineChart2.default;
exports.StepChart = _StepChart2.default;
exports.default = _Chart2.default;

/***/ })
/******/ ]);
//# sourceMappingURL=clay-charts.js.map